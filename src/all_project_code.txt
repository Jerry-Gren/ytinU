./light_structs.h:
```
#pragma once
#include <glm/glm.hpp>

// 材质属性
struct Material
{
    // --- PBR 核心参数 ---
    glm::vec3 albedo = glm::vec3(1.0f); // 基础色 (原 diffuse)
    float metallic = 0.0f;              // 金属度 (0=绝缘体, 1=金属)
    float roughness = 0.5f;             // 粗糙度 (0=光滑, 1=粗糙)
    float ao = 1.0f;                    // 环境光遮蔽 (Ambient Occlusion)

    // --- 透明/玻璃高级参数 ---
    // PBR 工作流中，F0 (反射率) 通常由 metallic 决定
    // 但为了兼容你的玻璃效果，我们保留 IOR 和 transparency
    float refractionIndex = 1.52f; // 折射率 (玻璃默认 1.52)
    float transparency = 0.0f;     // 透明度 (0=不透明)
    
    // [兼容性保留] 
    // 反射率 (Reflectivity) 在 PBR 中通常不需要手动调 (非金属固定0.04，金属等于Albedo)
    // 但为了让现在的 Shader 能跑，或者作为额外的艺术控制，我们暂时保留它
    float reflectivity = 0.5f;
};

// 平行光 (太阳光)
struct DirLight
{
    glm::vec3 direction = glm::vec3(-0.2f, -1.0f, -0.3f);
    glm::vec3 color = glm::vec3(1.0f); // 包含强度
    float intensity = 1.0f;
};

// 点光源 (灯泡)
struct PointLight
{
    glm::vec3 position = glm::vec3(0.0f);

    float constant = 1.0f;
    float linear = 0.09f;
    float quadratic = 0.032f;

    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;
};

// 聚光灯 (手电筒)
struct SpotLight
{
    glm::vec3 position = glm::vec3(0.0f);
    glm::vec3 direction = glm::vec3(0.0f, -1.0f, 0.0f);
    float cutOff = glm::cos(glm::radians(12.5f));
    float outerCutOff = glm::cos(glm::radians(17.5f));

    float constant = 1.0f;
    float linear = 0.09f;
    float quadratic = 0.032f;

    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;
};
```

./main.cpp:
```
#include <cstdlib>
#include <iostream>
#include <filesystem>

#include "scene_roaming.h"

std::string getExecutableDir() {
    return std::filesystem::current_path().string(); 
}

Options getOptions(int argc, char* argv[]) {
    Options options;
    options.windowTitle = "Scene Roaming";
    options.windowWidth = 1920;
    options.windowHeight = 1080;
    options.windowResizable = true;
    options.vSync = true;
    options.msaa = true;
    options.glVersion = {3, 3};
    options.backgroundColor = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);

    std::string exeDir = getExecutableDir();
    options.assetRootDir = exeDir + "/";

    std::cout << "[Info] Asset Root: " << options.assetRootDir << std::endl;

    return options;
}

int main(int argc, char* argv[]) {
    Options options = getOptions(argc, argv);

    try {
        SceneRoaming app(options);
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        exit(EXIT_FAILURE);
    } catch (...) {
        std::cerr << "Unknown exception" << std::endl;
        exit(EXIT_FAILURE);
    }

    return 0;
}
```

./scene_roaming.cpp:
```
#include "imgui.h"
#include "imgui_internal.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "scene_roaming.h"
#include "ImGuiFileDialog.h"
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/easing.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <filesystem>
#include <algorithm> // for std::sort

#include "engine/utils/image_utils.h"

// 辅助结构：用于排序轴的绘制顺序
struct GizmoAxisData {
    glm::vec3 dir;       // 原始方向
    ImU32 mainColor;     // 主颜色 (外圈或实心)
    ImU32 fillColor;     // 填充颜色 (仅负轴使用，稍淡)
    char label;          // 标签文字 ('X', 'Y', 'Z' 或 0)
    bool isNegative;     // 是否是负轴
    float zDepth;        // 变换后的深度 (用于排序)
    ImVec2 screenPos;    // 变换后的屏幕位置
};

void SceneRoaming::updateContentScale()
{
    float x, y;
    glfwGetWindowContentScale(_window, &x, &y);
    // 取较大的那个作为主缩放比例
    _contentScale = (x > y) ? x : y;
}

SceneRoaming::SceneRoaming(const Options &options) : Application(options)
{
    glfwSetInputMode(_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

    // 在初始化 ImGui 之前，必须先获取当前显示器的缩放比例！
    // 否则 initImGui 里的字体加载逻辑会一直使用默认的 1.0f
    updateContentScale();

    // 标记项目未打开
    _isProjectOpen = false;

    // 1. 在做任何场景加载之前，先设置资源根目录！
    // 这样 ResourceManager 才知道去哪里找文件
    ResourceManager::Get().setProjectRoot(options.assetRootDir);

    // =================================================
    // [新逻辑] 初始化子系统
    // =================================================
    _scene = std::make_unique<Scene>();
    _renderer = std::make_unique<Renderer>();

    // 1. 初始化渲染资源 (Shader, Skybox 等)
    _renderer->init();

    // 2. 初始化场景数据 (创建默认灯光等)
    _scene->createDefaultScene();

    // 初始化面板
    _sceneViewPanel = std::make_unique<SceneViewPanel>();
    _hierarchyPanel = std::make_unique<HierarchyPanel>();
    _inspectorPanel = std::make_unique<InspectorPanel>();
    _projectPanel = std::make_unique<ProjectPanel>();

    initImGui();
    // initSceneFBO 不需要在这里调，第一次 renderUI 时会根据窗口大小自动调
}

SceneRoaming::~SceneRoaming()
{
    // 在 OpenGL 上下文销毁前，清空资源缓存
    ResourceManager::Get().shutdown();
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
}

void SceneRoaming::initImGui()
{
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void)io;

    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

    ImGui::StyleColorsDark(); // 使用暗色主题

    ImGui_ImplGlfw_InitForOpenGL(_window, true);
    ImGui_ImplOpenGL3_Init("#version 330");

    // --- High DPI 适配逻辑 ---

    // 1. 缩放 UI 样式 (按钮大小、间距等)
    if (_contentScale > 1.0f)
    {
        ImGuiStyle& style = ImGui::GetStyle();
        style.ScaleAllSizes(_contentScale);
    }

    // 2. 缩放字体
    // ImGui 默认字体是位图字体，直接缩放会模糊。
    // 强烈建议加载一个 TTF 字体并指定像素大小。
    // Windows 路径示例 (你可以换成你的项目内的字体路径 "media/fonts/arial.ttf")
    std::string fontPath = getAssetFullPath("media/fonts/Roboto-Regular.ttf");
    // 如果没有字体文件，可以用 Windows 自带的，或者暂时忽略字体清晰度
    // fontPath = "C:\\Windows\\Fonts\\segoeui.ttf"; 
    std::cout << "[Info] Attempting to load font from: " << fontPath << std::endl;
    
    float fontSize = 16.0f * _contentScale; // 基础字号 16

    if (std::filesystem::exists(fontPath)) 
    {
        io.Fonts->AddFontFromFileTTF(fontPath.c_str(), fontSize);
    }
    else
    {
        // 如果找不到字体，使用默认字体并缩放 (可能会模糊)
        io.FontGlobalScale = _contentScale;
    }
}

void SceneRoaming::renderFrame()
{
    int currentW, currentH;
    glfwGetFramebufferSize(_window, &currentW, &currentH);

    // 如果长或宽为0（最小化状态），什么都不做，直接返回
    if (currentW == 0 || currentH == 0) {
        // 稍微休眠一下，避免空转占用 CPU 100%
        // (在 Windows 上可以使用 std::this_thread::sleep_for，或者简单的 return)
        return;
    }

    static bool isFullscreen = false;
    static int lastWindowX, lastWindowY, lastWindowW, lastWindowH;
    if (glfwGetKey(_window, GLFW_KEY_F11) == GLFW_PRESS)
    {
        // 简单的去抖动 (Debounce)，防止一帧多次触发
        static double lastTime = 0.0;
        double now = glfwGetTime();
        if (now - lastTime > 0.2) 
        {
            lastTime = now;
            isFullscreen = !isFullscreen;

            if (isFullscreen)
            {
                // 保存当前窗口位置和大小
                glfwGetWindowPos(_window, &lastWindowX, &lastWindowY);
                glfwGetWindowSize(_window, &lastWindowW, &lastWindowH);

                // 获取主显示器
                GLFWmonitor* monitor = glfwGetPrimaryMonitor();
                const GLFWvidmode* mode = glfwGetVideoMode(monitor);
                
                // 切换到全屏
                glfwSetWindowMonitor(_window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
            }
            else
            {
                // 恢复窗口模式
                glfwSetWindowMonitor(_window, nullptr, lastWindowX, lastWindowY, lastWindowW, lastWindowH, 0);
            }
        }
    }

    updateContentScale();

    // =========================================================
    // 2. 开启 ImGui 新帧 (必须在所有逻辑之前)
    // =========================================================
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    if (ImGui::IsKeyPressed(ImGuiKey_F12, false)) 
    {
        // 直接设置延迟，无需自己写 static bool 防抖
        _screenshotDelay = 1; 
    }

    // 1. 处理输入 (委托给 SceneViewPanel)
    // 它内部会调用 _cameraController->update() 和 handleInput()
    // 需要传入 Scene 指针用于射线检测
    _sceneViewPanel->onInputUpdate(ImGui::GetIO().DeltaTime, _scene.get(), _selectedObject);

    // =========================================================
    // 3. 清理主屏幕 (Back Buffer)
    // =========================================================
    // 注意：这里的 Viewport 是整个窗口的大小，不是 FBO 的大小
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(0, 0, currentW, currentH);
    // 清除为黑色 (ImGui 窗口背后的颜色)
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // =========================================================
    // 4. 执行 UI 逻辑 (并在内部触发 3D 渲染)
    // =========================================================
    // renderUI 会计算布局 -> 调整 FBO -> renderScene -> 提交 ImGui::Image
    renderUI();

    // =========================================================
    // 5. 提交 ImGui 绘制数据
    // =========================================================
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    // 在物理删除之前，检查选中物体是否即将死亡
    if (_scene && _selectedObject)
    {
        // 如果当前选中的物体在删除队列里，说明它将在下面这行代码中变为野指针
        if (_scene->isMarkedForDestruction(_selectedObject))
        {
            _selectedObject = nullptr; // 强制取消选中，保护指针安全
            // 可选：打印一条日志
            std::cout << "[System] Auto-deselected object pending destruction." << std::endl;
        }
    }

    if (_scene) {
        _scene->destroyMarkedObjects();
    }

    if (_screenshotDelay > 0)
    {
        // 倒计时减一
        _screenshotDelay--;
    }
    else if (_screenshotDelay == 0) // 倒计时结束，执行截屏
    {
        int w, h;
        glfwGetFramebufferSize(_window, &w, &h);
        std::string path = ResourceManager::Get().getProjectRoot() + "/screenshot.png";
        
        // 此时这一帧已经是“没有菜单”的全新一帧了
        ImageUtils::saveScreenshot(path, w, h);
        
        // 重置为 -1，停止截屏
        _screenshotDelay = -1;
    }
}

void SceneRoaming::renderUI()
{
    if (!_isProjectOpen)
    {
        renderProjectSelector(); // 阻塞式界面
        ImVec2 maxSize = ImGui::GetIO().DisplaySize;
        ImVec2 minSize = ImVec2(maxSize.x * 0.5f, maxSize.y * 0.5f);

        if (ImGuiFileDialog::Instance()->Display("ChooseDirDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
        {
            if (ImGuiFileDialog::Instance()->IsOk())
            {
                std::string filePathName = ImGuiFileDialog::Instance()->GetCurrentPath();
                if (filePathName.length() < sizeof(_projectPathBuf)) {
                    strcpy(_projectPathBuf, filePathName.c_str());
                }
            }
            ImGuiFileDialog::Instance()->Close();
        }
    } else {
        setupDockspace();

        _sceneViewPanel->onImGuiRender(_scene.get(), _renderer.get(), _selectedObject, _contentScale);

        // 1. Hierarchy
        _hierarchyPanel->onImGuiRender(_scene, _selectedObject); // 传入引用，允许面板修改选中项

        // 2. Inspector
        // 注意：我们需要检测 Inspector 是否删除了物体
        // 如果它删除了，selectedObject 可能会悬空，这里需要一种机制处理
        // 在 InspectorPanel 里我们直接调用了 removeGameObject。
        // 为了安全，我们可以在每帧开始时检查 _selectedObject 是否还在 _scene 里（可选但推荐）
        // 或者简单的：相信用户操作流
        _inspectorPanel->onImGuiRender(_selectedObject, _scene.get());

        // 如果 Inspector 刚刚把物体删了，我们需要把 _selectedObject 置空
        // 我们可以通过检查 Scene 是否还包含它来判断，或者让 Inspector 返回状态
        // 简单的 Hack：如果 _selectedObject 变成了野指针会崩溃。
        // [修正] InspectorPanel 内部做删除时，我们无法立即把这里的指针置空。
        // 建议修改 HierarchyPanel/InspectorPanel 的逻辑，或者：
        // 在 Scene 里加一个 isValid(GameObject*) 函数进行校验。
        // 鉴于目前架构，如果 Inspector 点击删除，下一帧这个指针就失效了。
        // 最简单的修复：给 Inspector 传 _selectedObject 的**引用**，让它在删除后置空！
        
        // 3. Project
        _projectPanel->onImGuiRender();
    }

    // 6. 渲染结束 (保持不变)
    ImGui::Render();
}

void SceneRoaming::setupDockspace()
{
    // =======================================================
    // [核心] 真正的布局重置逻辑 (DockBuilder)
    // =======================================================
    
    // 获取主视口 ID
    ImGuiID dockspace_id = ImGui::GetID("MyDockSpace");

    // 如果需要重置，或者第一次运行且没有 ini 记录
    // (ImGui::DockBuilderGetNode 判断该 ID 是否已存在)
    if (!_isLayoutInitialized || (ImGui::DockBuilderGetNode(dockspace_id) == NULL))
    {
        // 1. 清除当前所有布局
        ImGui::DockBuilderRemoveNode(dockspace_id); 
        
        // 2. 添加一个空的根节点，覆盖整个视口
        ImGui::DockBuilderAddNode(dockspace_id, ImGuiDockNodeFlags_DockSpace);
        ImGui::DockBuilderSetNodeSize(dockspace_id, ImGui::GetMainViewport()->Size);

        // 3. [关键] 切分节点 (Split)
        // 类似于切蛋糕：先切一刀，再在剩下的部分切一刀
        
        ImGuiID dock_main_id = dockspace_id; // 初始 ID
        ImGuiID dock_right_id = 0;
        ImGuiID dock_left_id = 0;
        ImGuiID dock_bottom_id = 0;

        // 第一刀：把右边切出来 (占 20%) -> 放 Inspector
        dock_right_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.2f, nullptr, &dock_main_id);
        
        // 第二刀：把左边切出来 (占 20%) -> 放 Hierarchy
        dock_left_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Left, 0.2f, nullptr, &dock_main_id);
        
        // 第三刀：把下面切出来 (占 25%) -> 放 Project
        dock_bottom_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Down, 0.25f, nullptr, &dock_main_id);
        
        // 剩下的 dock_main_id 就是中间的部分 -> 放 3D Viewport

        // 4. 将窗口绑定到对应的 ID
        // 注意：这里的字符串必须和你 Begin() 里的名字完全一致！
        ImGui::DockBuilderDockWindow("3D Viewport", dock_main_id);
        ImGui::DockBuilderDockWindow("Scene Hierarchy", dock_left_id);
        ImGui::DockBuilderDockWindow("Inspector", dock_right_id);
        ImGui::DockBuilderDockWindow("Project / Assets", dock_bottom_id);

        // 5. 完成构建
        ImGui::DockBuilderFinish(dockspace_id);

        _isLayoutInitialized = true;
    }

    // =======================================================
    // 正常渲染
    // =======================================================

    // 绑定到我们刚才构建的 ID
    ImGui::DockSpaceOverViewport(dockspace_id, ImGui::GetMainViewport());

    // =======================================================
    // 2. 顶部菜单栏 (可选，模仿 Blender)
    // =======================================================
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            // 导入场景按钮
            if (ImGui::MenuItem("Import as Single Mesh (.obj)"))
            {
                IGFD::FileDialogConfig config;
                config.path = ResourceManager::Get().getProjectRoot();
                ImGuiFileDialog::Instance()->OpenDialog("ImportMeshKey", "Import Single Mesh", ".obj", config);
            }

            if (ImGui::MenuItem("Import as Scene (.obj)"))
            {
                IGFD::FileDialogConfig config;
                config.path = ResourceManager::Get().getProjectRoot();
                
                ImGuiFileDialog::Instance()->OpenDialog("ImportSceneKey", "Import Scene and Split Objects", ".obj", config);
            }

            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Splits the OBJ file into multiple objects based on 'o' or 'g' tags.");
            }

            // 导出场景按钮
            if (ImGui::MenuItem("Export Scene (.obj)"))
            {
                // 1. 构造保存路径 (默认保存到项目根目录)
                // 如果你想做得更高级，可以像 Open Project 那样弹出一个 ImGuiFileDialog
                std::string exportPath = ResourceManager::Get().getProjectRoot() + "/scene_export.obj";
                
                // 2. 执行导出
                if (_scene) {
                    _scene->exportToOBJ(exportPath);
                }
            }

            ImGui::Separator();

            if (ImGui::MenuItem("Save Screenshot (.png)"))
            {
                // 1. 立即关闭当前的 Popup 菜单 (让下一帧不渲染它)
                ImGui::CloseCurrentPopup();

                // 2. 设置延迟帧数
                // 为什么是 2？
                // Frame 0 (当前帧): 菜单还在，逻辑处理完。
                // Frame 1 (下一帧): ImGui 生成了没有菜单的画面，渲染完成 -> 截屏！
                _screenshotDelay = 2; 
            }

            ImGui::Separator();

            if (ImGui::MenuItem("Exit")) glfwSetWindowShouldClose(_window, true);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("View"))
        {
            if (ImGui::MenuItem("Reset Layout")) _isLayoutInitialized = false;
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }

    // 检查并渲染文件对话框
    if (ImGuiFileDialog::Instance()->Display("ImportMeshKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            std::string path = ImGuiFileDialog::Instance()->GetFilePathName();
            // 调用单体加载逻辑 (你现有的 CustomOBJ 逻辑)
            // 这里可以直接调用 Scene 里的辅助函数，或者在这里写逻辑
            // 建议在 Scene 里加一个 importSingleMesh(path)
            if (_scene) {
                _scene->importSingleMeshFromOBJ(path);
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }

    // 这里的 Key "ImportSceneKey" 必须和上面 OpenDialog 里的 Key 一致
    if (ImGuiFileDialog::Instance()->Display("ImportSceneKey"))
    {
        // 如果用户点击了 OK
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            // 获取完整文件路径
            std::string path = ImGuiFileDialog::Instance()->GetFilePathName();
            
            // 调用我们刚刚写好的 Import 逻辑
            if (_scene) {
                _scene->importSceneFromOBJ(path);
            }
        }
        
        // 关闭对话框
        ImGuiFileDialog::Instance()->Close();
    }
}

void SceneRoaming::renderProjectSelector()
{
    // 获取视口中心
    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImVec2 center = viewport->GetCenter();

    // 设定窗口大小
    ImVec2 windowSize(600, 300); // 稍微宽一点，高一点
    ImGui::SetNextWindowPos(center, ImGuiCond_Always, ImVec2(0.5f, 0.5f)); // 真正的屏幕居中
    ImGui::SetNextWindowSize(windowSize);

    ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
    
    // [UI美化] 稍微加点圆角和阴影 (如果支持)
    ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 10.0f);
    ImGui::Begin("Project Setup", nullptr, flags);

    // 垂直居中内容
    float contentHeight = 120.0f; // 估算内容高度
    ImGui::SetCursorPosY((windowSize.y - contentHeight) * 0.5f);

    // 大标题
    ImGui::PushFont(ImGui::GetIO().Fonts->Fonts[0]); // 假设默认字体
    // 如果你有大字体，这里 Push 大字体
    float textWidth = ImGui::CalcTextSize("Select or Create Project Folder").x;
    ImGui::SetCursorPosX((windowSize.x - textWidth) * 0.5f);
    ImGui::Text("Select or Create Project Folder");
    ImGui::PopFont();
    
    ImGui::Dummy(ImVec2(0, 20)); // 间距

    // --- 路径输入行 ---
    // 动态计算宽度：总宽 - 按钮宽 - 间距 - 左右padding
    float padding = 40.0f; // 左右留白
    float btnWidth = 100.0f;
    float spacing = ImGui::GetStyle().ItemSpacing.x;
    float inputWidth = windowSize.x - (padding * 2) - btnWidth - spacing;

    ImGui::SetCursorPosX(padding); // 左对齐开始
    
    // 输入框
    ImGui::PushItemWidth(inputWidth);
    ImGui::InputText("##Path", _projectPathBuf, sizeof(_projectPathBuf));
    ImGui::PopItemWidth();

    ImGui::SameLine();

    // 浏览按钮
    if (ImGui::Button("Browse...", ImVec2(btnWidth, 0)))
    {
        IGFD::FileDialogConfig config;
        config.path = ".";
        ImGuiFileDialog::Instance()->OpenDialog("ChooseDirDlgKey", "Choose Project Directory", nullptr, config);
    }

    ImGui::Dummy(ImVec2(0, 20)); // 间距

    // --- 确认按钮 (居中) ---
    float confirmBtnWidth = 200.0f;
    ImGui::SetCursorPosX((windowSize.x - confirmBtnWidth) * 0.5f);
    
    // [UX] 如果路径为空，禁用按钮
    bool hasPath = strlen(_projectPathBuf) > 0;
    if (!hasPath) ImGui::BeginDisabled();
    
    if (ImGui::Button("Open / Create Project", ImVec2(confirmBtnWidth, 40)))
    {
        std::string path(_projectPathBuf);
        if (!std::filesystem::exists(path)) {
            std::filesystem::create_directories(path);
        }
        ResourceManager::Get().setProjectRoot(path);
        _isProjectOpen = true;
    }
    
    if (!hasPath) ImGui::EndDisabled();

    ImGui::End();
    ImGui::PopStyleVar(); // Pop WindowRounding
}
```

./scene_roaming.h:
```
#pragma once

#include <memory>
#include <vector>
#include <imgui.h>
#include "base/application.h"
#include "base/glsl_program.h"
#include "engine/scene.h"
#include "engine/renderer.h"
#include "editor/editor_camera.h"
#include "editor/panels/hierarchy_panel.h"
#include "editor/panels/inspector_panel.h"
#include "editor/panels/project_panel.h"
#include "editor/panels/scene_view_panel.h"
#include "engine/scene_object.h"
#include "engine/outline_pass.h"
#include "engine/resource_manager.h"

class SceneRoaming : public Application
{
public:
    SceneRoaming(const Options &options);
    ~SceneRoaming();

    void handleInput() override {};
    void renderFrame() override;

private:
    std::unique_ptr<Scene> _scene;       // 负责数据
    std::unique_ptr<Renderer> _renderer; // 负责画画

    std::unique_ptr<SceneViewPanel> _sceneViewPanel;
    std::unique_ptr<HierarchyPanel> _hierarchyPanel;
    std::unique_ptr<InspectorPanel> _inspectorPanel;
    std::unique_ptr<ProjectPanel> _projectPanel;

    // 编辑器状态变量
    bool _isLayoutInitialized = false; // 用于只在第一次运行时设置窗口位置
    bool _isProjectOpen = false;
    char _projectPathBuf[256] = "";
    float _contentScale = 1.0f;

    // 选中状态
    GameObject *_selectedObject = nullptr;

    // UI 相关
    void initImGui();
    void renderUI();
    void renderProjectSelector();
    void setupDockspace();
    void updateContentScale();

    // -1 表示不截屏，>0 表示倒计时
    int _screenshotDelay = -1;
};
```

./editor/editor_camera.cpp:
```
#include "editor_camera.h"
#include "base/camera.h"
#include "engine/scene_object.h" // 为了访问 GameObject 的 Transform
#include <imgui.h>
#include <imgui_internal.h>
#include <GLFW/glfw3.h>
#include <glm/gtx/vector_angle.hpp>
#include <algorithm> // for std::sort

// 那个 GizmoAxisData 结构体也可以搬到这里来
struct GizmoAxisData {
    glm::vec3 dir;       // 原始方向
    ImU32 mainColor;     // 主颜色 (外圈或实心)
    ImU32 fillColor;     // 填充颜色 (仅负轴使用，稍淡)
    char label;          // 标签文字 ('X', 'Y', 'Z' 或 0)
    bool isNegative;     // 是否是负轴
    float zDepth;        // 变换后的深度 (用于排序)
    ImVec2 screenPos;    // 变换后的屏幕位置
};

#include "editor_camera.h"
#include <glm/gtc/matrix_transform.hpp> // for glm::lookAt
#include <glm/gtc/quaternion.hpp>     // for glm::quat_cast

EditorCamera::EditorCamera(int width, int height)
{
    // 1. 计算宽高比 (使用传入的参数)
    float aspect = (float)width / (float)height;
    
    // 2. 初始化相机容器
    _cameras.resize(2);

    constexpr float znear = 0.1f;
    constexpr float zfar = 10000.0f;

    // =============================================
    // Setup Perspective Camera (Index 0)
    // =============================================
    _cameras[0] = std::make_unique<PerspectiveCamera>(glm::radians(60.0f), aspect, znear, zfar);

    // [搬运] 初始状态：看着原点，距离 15 米
    _pivot = glm::vec3(0.0f, 0.5f, 0.0f); // 原 _cameraPivot
    
    // [搬运] 稍微抬高一点角度
    glm::vec3 startPos = glm::vec3(0.0f, 5.0f, 15.0f);
    
    // [搬运] 初始化平滑缩放变量
    _currentOrbitDist = glm::length(startPos - _pivot);
    _targetOrbitDist = _currentOrbitDist;
    
    // [搬运] 设置相机位置
    _cameras[0]->transform.position = startPos;

    // [搬运] 计算初始旋转 (LookAt)
    // 注意：这里需要 include <glm/gtc/matrix_transform.hpp>
    glm::mat4 view = glm::lookAt(_cameras[0]->transform.position, _pivot, glm::vec3(0, 1, 0));
    _cameras[0]->transform.rotation = glm::quat_cast(glm::inverse(view));

    // =============================================
    // Setup Orthographic Camera (Index 1)
    // =============================================
    _cameras[1] = std::make_unique<OrthographicCamera>(-4.0f * aspect, 4.0f * aspect, -4.0f, 4.0f, znear, zfar);
    _cameras[1]->transform.position = glm::vec3(0.0f, 0.0f, 15.0f);
    
    // 默认激活透视相机
    _activeCameraIndex = 0;
}

void EditorCamera::update(float deltaTime)
{
    updateSmoothZoom(deltaTime);
    updateAnimation(deltaTime);
}

// [搬运来源] SceneRoaming::renderUI 中处理窗口大小变化的逻辑
void EditorCamera::onResize(int width, int height)
{
    float aspect = (float)width / (float)height;
    if (auto pCam = dynamic_cast<PerspectiveCamera *>(_cameras[_activeCameraIndex].get())) {
        pCam->aspect = aspect;
    }
    // 如果有正交相机也需要更新
    if (auto oCam = dynamic_cast<OrthographicCamera *>(_cameras[1].get())) {
        oCam->left = -4.0f * aspect;
        oCam->right = 4.0f * aspect;
    }
}

void EditorCamera::handleInput(const glm::vec3& scenePivot)
{
    // 1. [互斥锁] 如果正在拖拽 Gizmo，绝对不要处理相机旋转/平移
    if (_isGizmoDragging) return;

    ImGuiIO& io = ImGui::GetIO();
    
    // 2. 如果 ImGui 想要捕获键盘（例如在输入框打字），不处理快捷键
    if (io.WantCaptureKeyboard) return;

    Camera* cam = getActiveCamera();
    float dt = io.DeltaTime;
    const float friction = 30.0f;

    // =========================================================
    // 输入获取
    // =========================================================
    float dx = io.MouseDelta.x;
    float dy = io.MouseDelta.y;
    float scrollX = io.MouseWheelH;
    float scrollY = io.MouseWheel;

    bool isShift = io.KeyShift;
    bool isCtrl = io.KeyCtrl;
    bool isLMB = io.MouseDown[0];
    bool isRMB = io.MouseDown[1];
    bool isMMB = io.MouseDown[2];

    // =========================================================
    // [Blender 风格] 设备推断逻辑
    // =========================================================
    bool isFractional = (scrollY != 0.0f) && (std::abs(scrollY - std::round(scrollY)) > 0.02f);
    bool hasHorizontal = (scrollX != 0.0f);
    bool isMouseStep = (std::abs(scrollY) >= 0.9f);
    
    // 判定是否为物理鼠标滚轮
    bool isPhysicalMouse = isMouseStep && !hasHorizontal && !isFractional;

    // =========================================================
    // 意图定义
    // =========================================================
    bool intentZoom = false;
    bool intentOrbit = false;
    bool intentPan = false;

    // 缩放：Ctrl + 滚轮/触摸板，或者 物理滚轮直接滚动
    if (isCtrl || (isPhysicalMouse && !isShift)) {
        intentZoom = true;
    }
    // 平移：Shift + 中键/触摸板
    else if (isShift) {
        intentPan = true;
    }
    // 旋转：中键，或者 触摸板双指滑动
    else if (isMMB || (scrollX != 0 || scrollY != 0)) {
        intentOrbit = true;
    }

    // =========================================================
    // 状态更新 (用于控制 Gizmo 显示等)
    // =========================================================
    if (intentPan || intentZoom || intentOrbit)
    {
        _isControlling = true;
    }
    else
    {
        // 如果没有按键，且不是在惯性滑动中（这里简单用按键判断），则标记结束
        if (!isLMB && !isMMB && !isRMB && scrollX == 0 && scrollY == 0) 
        {
            _isControlling = false;
        }
    }

    // =========================================================
    // 执行逻辑
    // =========================================================

    // --- 1. 平移 (Pan) ---
    if (intentPan)
    {
        float sens = 0.002f * _currentOrbitDist;
        glm::vec3 delta(0.0f);
        glm::vec3 right = cam->transform.getRight();
        glm::vec3 up = cam->transform.getUp();

        if (isMMB) { 
            // 鼠标中键拖拽
            delta = (right * -dx * sens) + (up * dy * sens);
        } else {     
            // 触摸板滑动
            float trackpadSens = 5.0f * sens; 
            delta = (right * -scrollX * trackpadSens) + (up * scrollY * trackpadSens);
        }
        
        // 应用平移：相机位置和 Pivot 都要动
        cam->transform.position += delta;
        _pivot += delta; 
    }
    
    // --- 2. 缩放 (Zoom) ---
    else if (intentZoom)
    {
        float zoomFactor = 1.0f;
        float inputVal = scrollY != 0 ? scrollY : scrollX;

        if (isPhysicalMouse) {
            // 物理滚轮：固定步进 (10%)
            zoomFactor = (inputVal > 0) ? 0.9f : 1.1f;
        } else {
            // 触控板捏合：线性平滑缩放
            float safeInput = glm::clamp(inputVal, -2.0f, 2.0f);
            zoomFactor = 1.0f - (safeInput * 0.3f); 
        }

        // 修改目标距离，updateSmoothZoom 会负责插值
        _targetOrbitDist *= zoomFactor;
        if (_targetOrbitDist < 0.1f) _targetOrbitDist = 0.1f;
    }

    // --- 3. 旋转 (Orbit) ---
    else if (intentOrbit)
    {
        float targetDeltaX = 0.0f;
        float targetDeltaY = 0.0f;

        if (isMMB) {
            // 鼠标中键：直接映射
            float mouseSens = 0.0015f; // 可以微调灵敏度
            targetDeltaX = -dx * mouseSens;
            targetDeltaY = -dy * mouseSens;
            
            // 鼠标模式下，直接应用，不使用惯性变量干扰
            // (或者你可以选择让鼠标也有惯性，看手感喜好)
        } else {
            // 触控板：需要惯性平滑
            float trackpadScaleX = 0.15f;
            float trackpadScaleY = 0.12f;
            targetDeltaX = -scrollX * trackpadScaleX;
            targetDeltaY = -scrollY * trackpadScaleY;
            
            // 更新惯性变量
            _smoothOrbitDelta.x = glm::mix(_smoothOrbitDelta.x, targetDeltaX, dt * friction);
            _smoothOrbitDelta.y = glm::mix(_smoothOrbitDelta.y, targetDeltaY, dt * friction);
        }

        // 决定最终的旋转量
        float activeDx = isMMB ? targetDeltaX : _smoothOrbitDelta.x;
        float activeDy = isMMB ? targetDeltaY : _smoothOrbitDelta.y;

        rotateCamera(activeDx, activeDy);
    }
    
    // --- 4. 惯性衰减 ---
    // 即使没有输入，惯性也需要慢慢停下来
    else {
        _smoothOrbitDelta = glm::mix(_smoothOrbitDelta, glm::vec2(0.0f), dt * 30.0f);
        
        // 如果还有残余惯性，继续旋转一点点
        if (glm::length(_smoothOrbitDelta) > 0.001f) {
             rotateCamera(_smoothOrbitDelta.x, _smoothOrbitDelta.y);
             _isControlling = true; // 只要还在转，就算 controlling
        }
    }
}

// ... 依次搬运 rotateCamera, frameObject, updateAnimation 等函数 ...
Ray EditorCamera::screenPointToRay(float mouseX, float mouseY, float viewportX, float viewportY, float viewportW, float viewportH)
{
    // 1. 安全检查
    if (viewportW <= 0 || viewportH <= 0) 
        return Ray(glm::vec3(0), glm::vec3(0,0,1));

    // 2. [新增] 计算局部坐标 (Local Space)
    // 鼠标在整个窗口的坐标 - 视口图片左上角的坐标 = 鼠标在视口内的坐标
    float localX = mouseX - viewportX;
    float localY = mouseY - viewportY;

    // 3. 归一化设备坐标 (NDC: -1 ~ 1)
    float x = (2.0f * localX) / viewportW - 1.0f;
    float y = 1.0f - (2.0f * localY) / viewportH; // OpenGL Y轴向上，屏幕坐标向下，需要翻转

    // 4. 获取当前相机矩阵
    // 注意：这里访问的是 EditorCamera 自己的成员 _cameras
    Camera* cam = _cameras[_activeCameraIndex].get();
    glm::mat4 proj = cam->getProjectionMatrix();
    glm::mat4 view = cam->getViewMatrix();
    
    // 5. 反投影 (Unproject)
    glm::mat4 invVP = glm::inverse(proj * view);
    glm::vec4 screenPos = glm::vec4(x, y, 1.0f, 1.0f);
    glm::vec4 worldPos = invVP * screenPos;

    if (worldPos.w != 0.0f) worldPos /= worldPos.w;

    // 6. 计算方向
    glm::vec3 dir = glm::normalize(glm::vec3(worldPos) - cam->transform.position);

    return Ray(cam->transform.position, dir);
}

// =======================================================================================
// 动画与平滑逻辑
// =======================================================================================

// [搬运来源] SceneRoaming::updateSmoothZoom
// [改动] 参数改为传入 deltaTime，不再依赖 ImGui::GetIO()
void EditorCamera::updateSmoothZoom(float dt)
{
    if (_isAnimating) return;

    float smoothFactor = 10.0f * dt;
    
    if (std::abs(_targetOrbitDist - _currentOrbitDist) < 0.01f) {
        _currentOrbitDist = _targetOrbitDist;
    } else {
        _currentOrbitDist = glm::mix(_currentOrbitDist, _targetOrbitDist, smoothFactor);
    }

    // 根据新的距离更新相机位置
    glm::vec3 dir = glm::normalize(_cameras[_activeCameraIndex]->transform.position - _pivot);
    _cameras[_activeCameraIndex]->transform.position = _pivot + dir * _currentOrbitDist;
}

// [搬运来源] SceneRoaming::startCameraAnimation
// [改动] 变量名 _cameraPivot -> _pivot, activeCameraIndex -> _activeCameraIndex
void EditorCamera::startAnimation(const glm::vec3& targetPos, const glm::quat& targetRot, const glm::vec3& targetPivot)
{
    _animStartPos = _cameras[_activeCameraIndex]->transform.position;
    _animStartPivot = _pivot;
    _animStartRot = _cameras[_activeCameraIndex]->transform.rotation;

    _animTargetPos = targetPos;
    _animTargetPivot = targetPivot;
    _animTargetRot = targetRot;

    // 最短路径检查
    if (glm::dot(_animStartRot, _animTargetRot) < 0.0f)
    {
        _animTargetRot = -_animTargetRot;
    }

    _targetOrbitDist = glm::length(targetPos - targetPivot);

    _animTime = 0.0f;
    _isAnimating = true;
}

// [搬运来源] SceneRoaming::updateCameraAnimation
void EditorCamera::updateAnimation(float dt)
{
    if (!_isAnimating) return;

    _animTime += dt;
    float t = _animTime / _animDuration;
    
    if (t >= 1.0f) {
        t = 1.0f;
        _isAnimating = false;
        // 强制吸附
        _pivot = _animTargetPivot;
        _currentOrbitDist = _targetOrbitDist;
        _cameras[_activeCameraIndex]->transform.position = _animTargetPos;
        _cameras[_activeCameraIndex]->transform.rotation = _animTargetRot;
        return;
    }

    float smoothT = 1.0f - pow(1.0f - t, 4.0f);

    // 插值逻辑
    glm::vec3 currentPivot = glm::mix(_animStartPivot, _animTargetPivot, smoothT);
    _pivot = currentPivot; 

    float startDist = glm::length(_animStartPos - _animStartPivot);
    float targetDist = glm::length(_animTargetPos - _animTargetPivot);
    float currentDist = glm::mix(startDist, targetDist, smoothT);
    _currentOrbitDist = currentDist; 

    glm::quat currentRot = glm::slerp(_animStartRot, _animTargetRot, smoothT);

    glm::vec3 offset = currentRot * glm::vec3(0.0f, 0.0f, 1.0f) * currentDist;
    glm::vec3 currentPos = currentPivot + offset;

    _cameras[_activeCameraIndex]->transform.rotation = currentRot;
    _cameras[_activeCameraIndex]->transform.position = currentPos;
}

// =======================================================================================
// 控制逻辑
// =======================================================================================

// [搬运来源] SceneRoaming::rotateCamera
void EditorCamera::rotateCamera(float dx, float dy)
{
    if (glm::length(glm::vec2(dx, dy)) < 0.00001f) return;

    Camera* cam = _cameras[_activeCameraIndex].get();

    glm::vec3 worldUp = glm::vec3(0, 1, 0);
    glm::vec3 camRight = cam->transform.getRight();

    glm::quat qYaw = glm::angleAxis(dx, worldUp);
    glm::quat qPitch = glm::angleAxis(dy, camRight);
    glm::quat qRotation = qYaw * qPitch;

    glm::vec3 pivotToCam = cam->transform.position - _pivot;
    pivotToCam = qRotation * pivotToCam; 
    cam->transform.position = _pivot + pivotToCam;

    cam->transform.rotation = qRotation * cam->transform.rotation;
    cam->transform.rotation = glm::normalize(cam->transform.rotation);
}

// [搬运来源] SceneRoaming::switchToView
void EditorCamera::switchToView(const glm::vec3& dir)
{
    glm::vec3 targetPos = _pivot + glm::normalize(dir) * _targetOrbitDist; 
    
    glm::vec3 up = glm::vec3(0, 1, 0);
    if (std::abs(dir.y) > 0.9f) {
        up = glm::vec3(0, 0, -1);
    }

    glm::mat4 targetViewMat = glm::lookAt(targetPos, _pivot, up);
    glm::quat targetRot = glm::quat_cast(glm::inverse(targetViewMat));

    startAnimation(targetPos, targetRot, _pivot);
}

// [搬运来源] SceneRoaming::frameSelectedObject
// [改动] 参数改为 GameObject* obj
void EditorCamera::frameObject(GameObject* obj)
{
    if (!obj) return;

    BoundingBox bounds;
    // bool hasBounds = false; // 未使用
    glm::vec3 centerOffset(0.0f); 
    float objectRadius = 1.0f;    

    if (auto mesh = obj->getComponent<MeshComponent>()) {
        bounds = mesh->model->getBoundingBox();
        // hasBounds = true;

        glm::vec3 localCenter = (bounds.min + bounds.max) * 0.5f;
        centerOffset = obj->transform.rotation * (localCenter * obj->transform.scale);

        glm::vec3 size = (bounds.max - bounds.min) * obj->transform.scale;
        objectRadius = glm::length(size) * 0.5f; 
    }

    glm::vec3 targetPivot = obj->transform.position + centerOffset;

    if (objectRadius < 0.5f) objectRadius = 0.5f;
    
    float halfFov = glm::radians(30.0f);
    float dist = objectRadius / glm::sin(halfFov);
    dist *= 1.3f; 

    _targetOrbitDist = dist; 

    glm::vec3 fixedDir = glm::normalize(glm::vec3(0.0f, 1.0f, 1.0f));
    glm::vec3 targetPos = targetPivot + fixedDir * dist;

    glm::vec3 targetUp = glm::vec3(0, 1, 0);
    glm::mat4 targetView = glm::lookAt(targetPos, targetPivot, targetUp);
    glm::quat targetRot = glm::quat_cast(glm::inverse(targetView));

    startAnimation(targetPos, targetRot, targetPivot);
}

// =======================================================================================
// Gizmo 绘制与交互
// =======================================================================================

// [搬运来源] SceneRoaming::renderUI 中 "{ // [新增] 绘制 View Gizmo ... }" 代码块
// [改动] 封装了原本在 renderUI 里的交互逻辑
bool EditorCamera::drawViewGizmo(const glm::vec2& viewportPos, const glm::vec2& viewportSize)
{
    float gizmoSize = 65.0f; 
    float safePadding = gizmoSize + 15.0f + 30.0f;

    ImVec2 gizmoCenter = ImVec2(
        viewportPos.x + viewportSize.x - safePadding,
        viewportPos.y + safePadding
    );

    glm::mat4 view = _cameras[_activeCameraIndex]->getViewMatrix();
    bool isGizmoHovered = false;

    // 调用内部绘制函数 (对应旧的 drawViewGizmo)
    glm::vec3 clickedDir = drawGizmoInternal(
        ImGui::GetWindowDrawList(), 
        glm::vec2(gizmoCenter.x, gizmoCenter.y), 
        gizmoSize,
        isGizmoHovered
    );

    // --- 拖拽逻辑 ---
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) && isGizmoHovered && glm::length(clickedDir) < 0.1f)
    {
        _isGizmoDragging = true;
    }

    if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
    {
        _isGizmoDragging = false;
    }

    if (_isGizmoDragging)
    {
        ImVec2 delta = ImGui::GetIO().MouseDelta;
        float sens = 0.005f; 
        rotateCamera(-delta.x * sens, -delta.y * sens);
    }

    // --- 点击吸附逻辑 (Snap View) ---
    if (!_isGizmoDragging && glm::length(clickedDir) > 0.1f)
    {
        float dist = glm::length(_cameras[_activeCameraIndex]->transform.position - _pivot);
        if (dist < 1.0f) dist = 5.0f;

        glm::vec3 targetPos = _pivot + clickedDir * dist;
        glm::vec3 up = glm::vec3(0, 1, 0); 
        glm::vec3 currentDir = glm::normalize(_cameras[_activeCameraIndex]->transform.position - _pivot);
        glm::vec3 currentUp = _cameras[_activeCameraIndex]->transform.getUp();

        // 逻辑完全搬运自 SceneRoaming
        if (abs(clickedDir.y) > 0.9f) {
            float invert = (currentUp.y < -0.1f) ? -1.0f : 1.0f;
            if (abs(currentDir.z) > abs(currentDir.x)) {
                float sign = (currentDir.z >= 0.0f) ? 1.0f : -1.0f;
                if (clickedDir.y > 0) up = glm::vec3(0, 0, -1.0f * sign * invert);
                else                  up = glm::vec3(0, 0, 1.0f * sign * invert);
            } else {
                float sign = (currentDir.x >= 0.0f) ? 1.0f : -1.0f;
                if (clickedDir.y > 0) up = glm::vec3(-1.0f * sign * invert, 0, 0);
                else                  up = glm::vec3(1.0f * sign * invert, 0, 0);
            }
        }
        else {
            float dot = glm::dot(clickedDir, currentUp);
            bool isBackFlip  = dot > 0.5f;   
            bool isFrontFlip = dot < -0.5f;  
            bool isTopHemi    = currentDir.y > 0.1f;  
            bool isAlreadyUpsideDown = currentUp.y < -0.1f;

            if (isBackFlip) {
                if (isTopHemi) up = glm::vec3(0, -1, 0); 
                else           up = glm::vec3(0, 1, 0);  
            }
            else if (isFrontFlip) {
                if (isTopHemi) up = glm::vec3(0, 1, 0);
                else           up = glm::vec3(0, -1, 0); 
            }
            else {
                if (isAlreadyUpsideDown) up = glm::vec3(0, -1, 0); 
                else                     up = glm::vec3(0, 1, 0);
            }
        }

        glm::mat4 targetViewMat = glm::lookAt(targetPos, _pivot, up); 
        glm::quat targetRot = glm::quat_cast(glm::inverse(targetViewMat));
        startAnimation(targetPos, targetRot, _pivot);
    }

    return isGizmoHovered;
}

// [搬运来源] SceneRoaming::drawViewGizmo (最原始的那个绘制函数)
// [改动] 参数简化，不再传入 cameraPos 等，因为类成员里有
glm::vec3 EditorCamera::drawGizmoInternal(ImDrawList* drawList, const glm::vec2& centerPos, float axisLength, bool& outGizmoHovered)
{
    ImVec2 center(centerPos.x, centerPos.y);

    float circleRadius = 15.0f;    
    float lineThickness = 4.0f;   
    float outlineThickness = 3.0f; 
    float fontSize = 23.0f;
    float bgRadius = axisLength + circleRadius * 2.0f;

    ImU32 colR = IM_COL32(240, 55, 82, 255);
    ImU32 colG = IM_COL32(110, 159, 29, 255);
    ImU32 colB = IM_COL32(47, 132, 229, 255);
    ImU32 colR_Trans = IM_COL32(240, 55, 82, 100);
    ImU32 colG_Trans = IM_COL32(110, 159, 29, 100);
    ImU32 colB_Trans = IM_COL32(47, 132, 229, 100);
    ImU32 colText = IM_COL32(0, 0, 0, 255);
    ImU32 colBgHover = IM_COL32(255, 255, 255, 30); 

    ImVec2 mousePos = ImGui::GetMousePos();
    float distFromCenter = sqrtf(powf(mousePos.x - center.x, 2) + powf(mousePos.y - center.y, 2));
    outGizmoHovered = (distFromCenter < bgRadius);

    if (outGizmoHovered || _isGizmoDragging) {
        drawList->AddCircleFilled(center, bgRadius, colBgHover);
    }

    std::vector<GizmoAxisData> axes = {
        { {1,0,0},  colR, 0,          'X', false },
        { {0,1,0},  colG, 0,          'Y', false },
        { {0,0,1},  colB, 0,          'Z', false },
        { {-1,0,0}, colR, colR_Trans, 0,   true },
        { {0,-1,0}, colG, colG_Trans, 0,   true },
        { {0,0,-1}, colB, colB_Trans, 0,   true }
    };

    glm::mat4 viewMatrix = _cameras[_activeCameraIndex]->getViewMatrix();
    glm::mat3 viewRot = glm::mat3(viewMatrix);
    
    for (auto& axis : axes) {
        glm::vec3 localDir = viewRot * axis.dir;
        axis.zDepth = localDir.z;
        axis.screenPos = ImVec2(
            center.x + localDir.x * axisLength,
            center.y - localDir.y * axisLength
        );
    }

    std::sort(axes.begin(), axes.end(), [](const GizmoAxisData& a, const GizmoAxisData& b) {
        return a.zDepth < b.zDepth;
    });

    bool isMouseClicked = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
    const GizmoAxisData* hoveredAxis = nullptr;

    ImFont* font = ImGui::GetFont();
    for (const auto& axis : axes)
    {
        float dist = sqrtf(powf(mousePos.x - axis.screenPos.x, 2) + powf(mousePos.y - axis.screenPos.y, 2));
        if (dist <= circleRadius + 2.0f) hoveredAxis = &axis;
        bool isHovered = (hoveredAxis == &axis);
        if (_isGizmoDragging) isHovered = false;

        if (!axis.isNegative)
        {
            if (isHovered) drawList->AddCircle(axis.screenPos, circleRadius + 2.0f, IM_COL32(255,255,255,150), 0, 2.0f);
            glm::vec2 dir2D = glm::vec2(axis.screenPos.x - center.x, axis.screenPos.y - center.y);
            float len = glm::length(dir2D);
            if (len > circleRadius) 
            {
                dir2D /= len;
                ImVec2 lineEndPos = ImVec2(
                    axis.screenPos.x - dir2D.x * (circleRadius - 1.5f), 
                    axis.screenPos.y - dir2D.y * (circleRadius - 1.5f)
                );
                drawList->AddLine(center, lineEndPos, axis.mainColor, lineThickness);
            }
            drawList->AddCircleFilled(axis.screenPos, circleRadius - 1.0f, axis.mainColor);
            drawList->AddCircle(axis.screenPos, circleRadius, axis.mainColor, 0, outlineThickness);

            char text[2] = { axis.label, '\0' };
            ImVec2 textSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, text);
            ImVec2 opticalOffset = ImVec2(0.4f, 0.4f); 
            ImVec2 textPos = ImVec2(
                axis.screenPos.x - textSize.x * 0.5f + opticalOffset.x,
                axis.screenPos.y - textSize.y * 0.5f + opticalOffset.y
            );
            drawList->AddText(font, fontSize, textPos, colText, text);
        }
        else
        {
            if (isHovered) drawList->AddCircle(axis.screenPos, circleRadius + 2.0f, IM_COL32(255,255,255,150), 0, 2.0f);
            drawList->AddCircleFilled(axis.screenPos, circleRadius - 1.0f, axis.fillColor);
            drawList->AddCircle(axis.screenPos, circleRadius, axis.mainColor, 0, outlineThickness);
        }
    }

    if (_isGizmoDragging) return glm::vec3(0,0,0);
    if (isMouseClicked && hoveredAxis) return hoveredAxis->dir;

    return glm::vec3(0, 0, 0); 
}
```

./editor/editor_camera.h:
```
#pragma once

#include <memory>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>
#include "base/camera.h"
#include "engine/physics_utils.h"

// 前置声明
class GameObject; 
class Scene;
struct ImDrawList;

class EditorCamera
{
public:
    EditorCamera(int width, int height);
    ~EditorCamera() = default;

    // --- 核心更新 ---
    // 每帧调用，处理输入和平滑插值
    void update(float deltaTime);
    
    // 当窗口大小改变时调用
    void onResize(int width, int height);

    // --- 输入处理 ---
    // 接管 ImGui 的输入
    void handleInput(const glm::vec3& scenePivot = glm::vec3(0.0f));

    // --- 功能接口 ---
    Camera* getActiveCamera() const { return _cameras[_activeCameraIndex].get(); }
    
    // 获取当前的 Pivot (注视点)
    glm::vec3 getPivot() const { return _pivot; }

    // 聚焦物体 (对应原来的 frameSelectedObject)
    void frameObject(GameObject* obj);

    // 切换视角 (对应原来的 switchToView)
    void switchToView(const glm::vec3& dir);

    // 屏幕射线 (对应原来的 screenPointToRay)
    // 需要传入视口的位置和大小 (ImGui Image 的 Rect)
    Ray screenPointToRay(float mouseX, float mouseY, float viewportX, float viewportY, float viewportW, float viewportH);

    // 绘制右上角的 View Gizmo (返回是否被 Hover)
    bool drawViewGizmo(const glm::vec2& viewportPos, const glm::vec2& viewportSize);

    // 用于外部查询是否正在操作相机 (SceneRoaming 可以用它来决定是否绘制选择框等)
    bool isControlling() const { return _isControlling; }

private:
    // --- 内部状态 (从 SceneRoaming 搬过来的) ---
    std::vector<std::unique_ptr<Camera>> _cameras;
    int _activeCameraIndex = 0;

    glm::vec3 _pivot = glm::vec3(0.0f);
    glm::vec2 _smoothOrbitDelta = glm::vec2(0.0f);
    
    // 平滑缩放变量
    float _currentOrbitDist = 15.0f;
    float _targetOrbitDist = 15.0f;

    // 动画变量
    bool _isAnimating = false;
    float _animTime = 0.0f;
    float _animDuration = 0.3f;
    glm::vec3 _animStartPos, _animTargetPos;
    glm::vec3 _animStartPivot, _animTargetPivot;
    glm::quat _animStartRot, _animTargetRot;

    // Gizmo 拖拽状态
    bool _isGizmoDragging = false;
    bool _isControlling = false;

    // --- 内部辅助函数 ---
    void rotateCamera(float dx, float dy);
    void startAnimation(const glm::vec3& targetPos, const glm::quat& targetRot, const glm::vec3& targetPivot);
    void updateAnimation(float dt);
    void updateSmoothZoom(float dt);
    
    // 那个很长的绘制 Gizmo 的函数
    glm::vec3 drawGizmoInternal(ImDrawList* drawList, const glm::vec2& center, float size, bool& outHovered);
};
```

./editor/panels/hierarchy_panel.cpp:
```
#include "hierarchy_panel.h"
#include <imgui.h>

HierarchyPanel::HierarchyPanel() : Panel("Scene Hierarchy") {}

void HierarchyPanel::onImGuiRender(const std::unique_ptr<Scene>& scene, GameObject*& selectedObject)
{
    if (!_isOpen) return;

    // 注意：ImGui::Begin 需要传入指针来控制关闭按钮
    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    // 1. 添加物体按钮
    if (ImGui::Button("+ Add Object"))
        ImGui::OpenPopup("AddObjPopup");
    
    if (ImGui::BeginPopup("AddObjPopup"))
    {
        if (ImGui::MenuItem("Cube")) {
            scene->createCube(); 
        }
        if (ImGui::MenuItem("Point Light")) {
            scene->createPointLight();
        }
        ImGui::EndPopup();
    }

    ImGui::Separator();

    // 2. 遍历物体列表
    const auto& objects = scene->getGameObjects();
    
    for (int i = 0; i < objects.size(); ++i)
    {
        auto &go = objects[i];
        
        // 使用 Selectable 模拟列表项
        ImGui::PushID(go->getInstanceID());
        if (ImGui::Selectable(go->name.c_str(), selectedObject == go.get()))
        {
            selectedObject = go.get();
        }
        ImGui::PopID();
    }

    // 3. 点击空白处取消选择
    if (ImGui::IsMouseDown(0) && ImGui::IsWindowHovered())
        selectedObject = nullptr;

    ImGui::End();
}
```

./editor/panels/hierarchy_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/scene.h"

class HierarchyPanel : public Panel {
public:
    HierarchyPanel();
    
    // 我们需要传入 Scene 指针来遍历物体
    // 我们需要传入 selectedObject 的引用，以便面板能修改当前选中的物体
    void onImGuiRender(const std::unique_ptr<Scene>& scene, GameObject*& selectedObject);

    // 覆盖基类接口 (虽然主要用上面的带参版本)
    void onImGuiRender() override {} 
};
```

./editor/panels/inspector_panel.cpp:
```
#include "inspector_panel.h"
#include "engine/geometry_factory.h"
#include "engine/resource_manager.h"
#include <imgui.h>
#include <glm/gtc/type_ptr.hpp>

InspectorPanel::InspectorPanel() : Panel("Inspector") {}

void InspectorPanel::onImGuiRender(GameObject*& selectedObject, Scene* sceneContext)
{
    if (!_isOpen) return;

    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    if (selectedObject)
    {
        // 1. Name & Delete Object
        char nameBuf[128];
        strcpy(nameBuf, selectedObject->name.c_str());

        ImGuiStyle& style = ImGui::GetStyle();
        float availableWidth = ImGui::GetContentRegionAvail().x;
        const char* btnLabel = "Delete Object"; 
        float buttonWidth = ImGui::CalcTextSize(btnLabel).x + style.FramePadding.x * 2.0f;
        float inputWidth = availableWidth - buttonWidth - style.ItemSpacing.x;

        ImGui::SetNextItemWidth(inputWidth);
        if (ImGui::InputText("##Name", nameBuf, sizeof(nameBuf)))
            selectedObject->name = nameBuf;

        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1));
        bool shouldDeleteObj = ImGui::Button(btnLabel);
        ImGui::PopStyleColor();

        if (shouldDeleteObj && sceneContext)
        {
            sceneContext->markForDestruction(selectedObject);
            selectedObject = nullptr;
            // 立即结束当前 Frame 的绘制，防止访问野指针
            ImGui::End(); 
            return;
        }
        else 
        {
            // 只有没删除的时候才继续绘制
            ImGui::Separator();
            drawComponents(selectedObject);
        }
    }
    else
    {
        float availW = ImGui::GetContentRegionAvail().x;
        float textW = ImGui::CalcTextSize("No Object Selected").x;
        if (availW > textW) ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availW - textW) * 0.5f);
        ImGui::TextDisabled("No Object Selected");
    }

    ImGui::End();
}

void InspectorPanel::drawComponents(GameObject* obj)
{
    // 2. Transform
    if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen))
    {
        ImGui::DragFloat3("Position", glm::value_ptr(obj->transform.position), 0.1f);
        if (ImGui::DragFloat3("Rotation", glm::value_ptr(obj->transform.rotationEuler), 0.5f))
        {
            obj->transform.setRotation(obj->transform.rotationEuler);
        }
        ImGui::DragFloat3("Scale", glm::value_ptr(obj->transform.scale), 0.1f);
    }

    // 3. Components Loop
    Component *compToRemove = nullptr;
    for (auto &comp : obj->components)
    {
        ImGui::PushID(comp->getInstanceID());

        std::string headerName = "Unknown Component";
        if (comp->getType() == ComponentType::MeshRenderer) headerName = "Mesh Renderer";
        else if (comp->getType() == ComponentType::Light) headerName = "Light Source";
        else if (comp->getType() == ComponentType::ReflectionProbe) headerName = "Reflection Probe";

        bool isOpen = ImGui::CollapsingHeader(headerName.c_str(), ImGuiTreeNodeFlags_DefaultOpen);
        if (isOpen)
        {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
            if (ImGui::Button("Remove Component", ImVec2(-1, 0))) 
                compToRemove = comp.get();
            ImGui::PopStyleColor();

            ImGui::Dummy(ImVec2(0, 5));
            drawComponentUI(comp.get()); // 调用具体绘制
            ImGui::Dummy(ImVec2(0, 10));
        }
        ImGui::PopID();
    }

    if (compToRemove) obj->removeComponent(compToRemove);

    // 4. Add Component
    ImGui::Separator();
    if (ImGui::Button("Add Component..."))
        ImGui::OpenPopup("AddCompPopup");

    if (ImGui::BeginPopup("AddCompPopup"))
    {
        bool hasMesh = obj->getComponent<MeshComponent>() != nullptr;
        bool hasLight = obj->getComponent<LightComponent>() != nullptr;

        if (ImGui::MenuItem("Mesh Renderer", nullptr, false, !hasMesh))
            obj->addComponent<MeshComponent>(GeometryFactory::createCube());

        if (ImGui::MenuItem("Light Source", nullptr, false, !hasLight))
        {
            auto light = obj->addComponent<LightComponent>(LightType::Point);
            if (hasMesh) {
                auto mesh = obj->getComponent<MeshComponent>();
                mesh->isGizmo = true; 
            }
        }

        bool hasProbe = obj->getComponent<ReflectionProbeComponent>() != nullptr;
        if (ImGui::MenuItem("Reflection Probe", nullptr, false, !hasProbe))
        {
            obj->addComponent<ReflectionProbeComponent>();
        }
        ImGui::EndPopup();
    }
}

// [搬运] 从 SceneRoaming::drawComponentUI 原封不动搬过来
void InspectorPanel::drawComponentUI(Component *comp)
{
    // ... 这里请粘贴原 SceneRoaming.cpp 中 drawComponentUI 的完整内容 ...
    // ... 包含 Mesh Filter, Shape Combo, Light Type Combo 等几百行代码 ...
    // 注意：需要确保 geometry_factory.h 和 resource_manager.h 已包含
    // --- Case 1: Mesh Renderer ---
    if (comp->getType() == ComponentType::MeshRenderer)
    {
        auto mesh = static_cast<MeshComponent *>(comp);
        bool needRebuild = false;

        auto lightComp = comp->owner->getComponent<LightComponent>();

        if (lightComp && mesh->isGizmo)
        {
            // Gizmo 通常只需要设置 albedo 即可
            mesh->material.albedo = lightComp->color; 
            // 可以顺便把 PBR 参数设为无光泽，防止 Gizmo 反光
            mesh->material.metallic = 0.0f;
            mesh->material.roughness = 1.0f;
        }

        ImGui::Checkbox("Is Gizmo (Unlit)", &mesh->isGizmo);
        ImGui::SameLine();
        ImGui::Checkbox("Double Sided", &mesh->doubleSided);

        bool canFlatShade = (mesh->shapeType == MeshShapeType::Sphere ||
                             mesh->shapeType == MeshShapeType::Cylinder || 
                             mesh->shapeType == MeshShapeType::Cone ||
                             mesh->shapeType == MeshShapeType::Prism || 
                             mesh->shapeType == MeshShapeType::Frustum ||
                             mesh->shapeType == MeshShapeType::CustomOBJ);
        
        if (canFlatShade) {
            ImGui::SameLine();
            if (ImGui::Checkbox("Flat Shade", &mesh->useFlatShade)) {
                needRebuild = true;
            }
        }

        // Mesh Filter 设置区域
        ImGui::Separator();
        ImGui::Text("Mesh Filter");

        // 1. 形状选择下拉菜单
        const char *shapeNames[] = {"Cube", "Sphere", "Cylinder", "Cone", "Prism", "Frustum", "Plane", "Custom OBJ"};
        int currentItem = (int)mesh->shapeType;

        if (ImGui::Combo("Shape", &currentItem, shapeNames, IM_ARRAYSIZE(shapeNames)))
        {
            mesh->shapeType = (MeshShapeType)currentItem;
            
            switch (mesh->shapeType) {
                case MeshShapeType::Cube:
                    mesh->doubleSided = false;
                    break;
                case MeshShapeType::Sphere:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Cylinder:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Cone:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Prism:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = true; // 硬边
                    break;
                case MeshShapeType::Frustum:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = true; // 硬边
                    break;
                case MeshShapeType::Plane:
                    mesh->doubleSided = true;
                    break;
                default:
                    mesh->doubleSided = false;
                    break;
            }
            
            if (mesh->shapeType != MeshShapeType::CustomOBJ)
            {
                needRebuild = true; // <--- 立即触发重建
            }
        }

        // 2. 根据类型显示不同的参数滑块
        switch (mesh->shapeType)
        {
        case MeshShapeType::Cube:
            if (ImGui::DragFloat("Size", &mesh->params.size, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            break;

        case MeshShapeType::Sphere:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            if (ImGui::SliderInt("Stacks", &mesh->params.stacks, 2, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Cylinder:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Cone:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Prism: // 多面棱柱
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Sides", &mesh->params.sides, 3, 32))
                needRebuild = true;
            break;

        case MeshShapeType::Frustum: // 多面棱台
            if (ImGui::DragFloat("Top Radius", &mesh->params.topRadius, 0.05f, 0.0f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Btm Radius", &mesh->params.bottomRadius, 0.05f, 0.0f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Sides", &mesh->params.sides, 3, 32))
                needRebuild = true;
            break;

        case MeshShapeType::Plane:
            if (ImGui::DragFloat("Width", &mesh->params.width, 0.1f))
                needRebuild = true; // 复用 params 里的变量，或者在 struct 加 width/depth
                                    // 暂时复用 params.size 作为 width, params.height 作为 depth，或者我们在 struct 里加
                                    // 为了简单，我们复用 size=width, height=depth
            if (ImGui::DragFloat("Depth", &mesh->params.depth, 0.1f))
                needRebuild = true;
            break;

        case MeshShapeType::CustomOBJ:
            {
                // 显示当前路径 (只读，或可编辑)
                std::string fullPath = mesh->params.objPath;
                std::string fileName = std::filesystem::path(fullPath).filename().string();

                drawResourceSlot("Mesh File", fileName, fullPath, "ASSET_OBJ",
                    // OnDrop
                    [&](const std::string& path) {
                        bool initialFlatState = false;
                        // 既然是新文件，重置 subMeshName，默认加载整个文件
                        memset(mesh->params.subMeshName, 0, sizeof(mesh->params.subMeshName));
                        auto newModel = ResourceManager::Get().getModel(path, initialFlatState, "");
                        if (newModel) {
                            mesh->setMesh(newModel);
                            mesh->isGizmo = false;
                            mesh->doubleSided = false;
                            mesh->useFlatShade = initialFlatState;

                            if (!newModel->hasUVs()) {
                                // 如果模型没有 UV，自动开启 Triplanar，并给一个合理的缩放
                                mesh->useTriplanar = true;
                                mesh->triplanarScale = 0.2f; // 0.2 通常适合房间大小的物体，1.0 适合小物体，可自行调整默认值
                            } else {
                                // 如果有 UV，默认使用原始 UV
                                mesh->useTriplanar = false;
                                mesh->triplanarScale = 1.0f;
                            }
                            
                            strncpy(mesh->params.objPath, path.c_str(), sizeof(mesh->params.objPath) - 1);
                            mesh->params.objPath[sizeof(mesh->params.objPath) - 1] = '\0';
                        }
                    },
                    // OnClear
                    nullptr
                );
                
                // 提示信息可以移到 Tooltip 或者保留在下方
                // ImGui::TextDisabled("(?)"); 
                break;
            }
        }

        // 3. 执行重建逻辑
        if (needRebuild)
        {
            std::shared_ptr<Model> newModel = nullptr;
            auto &p = mesh->params;

            switch (mesh->shapeType)
            {
            case MeshShapeType::Cube:
                newModel = GeometryFactory::createCube(p.size);
                break;
            case MeshShapeType::Sphere:
                newModel = GeometryFactory::createSphere(p.radius, p.stacks, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Cylinder:
                newModel = GeometryFactory::createCylinder(p.radius, p.height, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Cone:
                newModel = GeometryFactory::createCone(p.radius, p.height, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Prism:
                newModel = GeometryFactory::createPrism(p.radius, p.height, p.sides, mesh->useFlatShade);
                break;
            case MeshShapeType::Frustum:
                newModel = GeometryFactory::createPyramidFrustum(p.topRadius, p.bottomRadius, p.height, p.sides, mesh->useFlatShade);
                break;
            case MeshShapeType::Plane:
                newModel = GeometryFactory::createPlane(p.width, p.depth);
                break;
            case MeshShapeType::CustomOBJ:
                if (strlen(p.objPath) > 0) {
                    newModel = ResourceManager::Get().getModel(p.objPath, mesh->useFlatShade, p.subMeshName);
                }
                break;
            default:
                break;
            }

            if (newModel)
            {
                // 保持原有的 Transform 不变，只换 Mesh
                // 但是 Model 类里也有 Transform (local transform)，新建的 Model transform 是默认的
                // 如果需要保留 Model 内部的 transform (例如箭头缩放)，这里需要额外处理
                // 不过 GeometryFactory 创建出来的 Model transform 都是默认的，所以直接覆盖没问题

                // 继承旧 Model 的局部缩放? 通常不需要，GeometryFactory 出来的都是标准大小
                // 如果之前对 Gizmo 做了特殊缩放，可能会丢失，但这里是用户主动重建，重置是合理的。

                mesh->setMesh(std::move(newModel));
            }
        }

        ImGui::Separator();

        // 材质 UI
        if (ImGui::TreeNode("PBR Material"))
        {
            if (lightComp)
            {
                ImGui::TextColored(ImVec4(1, 1, 0, 1), "[Locked]");
                ImGui::SameLine();
                ImGui::TextWrapped("Color is controlled by the Light Source component.");

                // 仅显示只读的颜色预览 (使用 ColorButton)
                ImGui::ColorButton("##prev", ImVec4(mesh->material.albedo.r, mesh->material.albedo.g, mesh->material.albedo.b, 1));
            }
            else
            {
                // [逻辑] 没有光源组件，正常显示编辑器
                // PBR 参数滑块
                ImGui::ColorEdit3("Albedo", glm::value_ptr(mesh->material.albedo));
                if (mesh->ormMap)
                {
                    // 样式优化：显示一个稍微暗淡的提示信息
                    ImGui::Spacing();
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 0.5f, 0.5f, 1.0f));
                    ImGui::Text("[Physical Props Controlled by Texture]");
                    ImGui::BulletText("R: Occlusion");
                    ImGui::BulletText("G: Roughness");
                    ImGui::BulletText("B: Metallic");
                    ImGui::PopStyleColor();
                    ImGui::Spacing();
                }
                else
                {
                    // 没有 ORM 贴图时，显示手动滑块
                    ImGui::SliderFloat("Metallic", &mesh->material.metallic, 0.0f, 1.0f);
                    ImGui::SliderFloat("Roughness", &mesh->material.roughness, 0.0f, 1.0f);
                    ImGui::SliderFloat("AO", &mesh->material.ao, 0.0f, 1.0f);
                }
            }

            // 纹理贴图设置 (Texture Map)
            ImGui::Spacing();
            ImGui::Separator();
        
            std::string fullPath = mesh->diffuseMap ? mesh->diffuseMap->getUri() : "";
            std::string fileName = std::filesystem::path(fullPath).filename().string();

            drawResourceSlot("Albedo Map", fileName, fullPath, "ASSET_TEXTURE",
                // OnDrop
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) mesh->diffuseMap = tex;
                },
                // OnClear
                [&]() {
                    mesh->diffuseMap = nullptr;
                }
            );

            if (mesh->diffuseMap) // 只有有纹理时才显示这些选项
            {
                ImGui::Dummy(ImVec2(0, 5));
                ImGui::Text("UV Mapping");

                if (mesh->model && !mesh->model->hasUVs()) 
                {
                    ImGui::SameLine();
                    // 黄色警告文字
                    ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), " [!] No UVs"); 
                    // 注意：如果你没有集成 FontAwesome (ICON_FA...)，可以直接写 "[!]" 或 "No UVs"
                    
                    if (ImGui::IsItemHovered()) {
                        ImGui::SetTooltip("This model has no UV coordinates.\nStandard texture mapping will fail.\nTriplanar Mapping is highly recommended.");
                    }
                }
                
                // 开关
                ImGui::Checkbox("Use Triplanar Mapping", &mesh->useTriplanar);
                
                // 提示信息
                if (ImGui::IsItemHovered())
                    ImGui::SetTooltip("Auto-generate UVs based on world position.\nUseful for models with missing or bad UVs.");

                // 如果开启了，显示缩放滑块
                if (mesh->useTriplanar) {
                    ImGui::DragFloat("Tiling", &mesh->triplanarScale, 0.01f, 0.01f, 10.0f);
                    
                    ImGui::Dummy(ImVec2(0, 5));
                    ImGui::Text("Detailed Controls:");
                    
                    // 定义一个临时 Helper Lambda，用于画带吸附功能的滑块
                    auto DrawRotSlider = [](const char* label, float& val) {
                        // 宽度稍微设小一点以适应分栏
                        ImGui::PushItemWidth(-1); 
                        if (ImGui::SliderFloat(label, &val, 0.0f, 270.0f, "%.0f")) {
                            val = floor((val + 45.0f) / 90.0f) * 90.0f;
                        }
                        ImGui::PopItemWidth();
                    };

                    // 使用两列布局：左边是正轴，右边是负轴
                    ImGui::Columns(2, "TriplanarDetailed", true); // true = 显示中间的分隔线
                    
                    // --- 表头 ---
                    ImGui::Text("Positive (+)"); 
                    ImGui::NextColumn();
                    ImGui::Text("Negative (-)");
                    ImGui::NextColumn();
                    ImGui::Separator();

                    // --- X 轴行 ---
                    ImGui::Text("Right (+X)");
                    DrawRotSlider("##RotPosX", mesh->triRotPosX);
                    ImGui::Checkbox("Flip##PosX", &mesh->triFlipPosX);
                    
                    ImGui::NextColumn(); // ----------------------
                    
                    ImGui::Text("Left (-X)");
                    DrawRotSlider("##RotNegX", mesh->triRotNegX);
                    ImGui::Checkbox("Flip##NegX", &mesh->triFlipNegX);
                    
                    ImGui::NextColumn(); 
                    ImGui::Separator();

                    // --- Y 轴行 ---
                    ImGui::Text("Top (+Y)");
                    DrawRotSlider("##RotPosY", mesh->triRotPosY);
                    ImGui::Checkbox("Flip##PosY", &mesh->triFlipPosY);

                    ImGui::NextColumn(); // ----------------------

                    ImGui::Text("Bottom (-Y)");
                    DrawRotSlider("##RotNegY", mesh->triRotNegY);
                    ImGui::Checkbox("Flip##NegY", &mesh->triFlipNegY);

                    ImGui::NextColumn();
                    ImGui::Separator();

                    // --- Z 轴行 ---
                    ImGui::Text("Front (+Z)");
                    DrawRotSlider("##RotPosZ", mesh->triRotPosZ);
                    ImGui::Checkbox("Flip##PosZ", &mesh->triFlipPosZ);

                    ImGui::NextColumn(); // ----------------------

                    ImGui::Text("Back (-Z)");
                    DrawRotSlider("##RotNegZ", mesh->triRotNegZ);
                    ImGui::Checkbox("Flip##NegZ", &mesh->triFlipNegZ);

                    // --- 结束 ---
                    ImGui::Columns(1); 
                    ImGui::Separator();
                }
            }

            ImGui::Separator();

            std::string normPath = mesh->normalMap ? mesh->normalMap->getUri() : "";
            std::string normName = std::filesystem::path(normPath).filename().string();

            drawResourceSlot("Normal Map", normName, normPath, "ASSET_TEXTURE",
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) mesh->normalMap = tex;
                },
                [&]() { mesh->normalMap = nullptr; }
            );

            if (mesh->normalMap)
            {
                ImGui::Indent();
                
                ImGui::DragFloat("Strength", &mesh->normalStrength, 0.05f, 0.0f, 5.0f);
                ImGui::Checkbox("Flip Y (DirectX)", &mesh->flipNormalY);
                
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Check this if the bumps look inverted.\n(Common for DirectX/Unreal assets)");
                }
                
                ImGui::Unindent();
            }

            ImGui::Separator();

            std::string ormPath = mesh->ormMap ? mesh->ormMap->getUri() : "";
            std::string ormName = std::filesystem::path(ormPath).filename().string();

            drawResourceSlot("ORM Map", ormName, ormPath, "ASSET_TEXTURE",
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) mesh->ormMap = tex;
                },
                [&]() { mesh->ormMap = nullptr; }
            );

            if (mesh->ormMap) {
                // 如果有贴图，提示用户滑块将失效或作为乘数
                // 现代做法通常是：有贴图时，贴图完全接管。
                // 可以在这里加个 Tooltip 解释 R=AO, G=Rough, B=Metal
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Packed Texture:\nRed = Occlusion\nGreen = Roughness\nBlue = Metallic");
                }
            }

            ImGui::Separator();

            std::string emissivePath = mesh->emissiveMap ? mesh->emissiveMap->getUri() : "";
            std::string emissiveName = std::filesystem::path(emissivePath).filename().string();

            drawResourceSlot("Emissive Map", emissiveName, emissivePath, "ASSET_TEXTURE",
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) {
                        mesh->emissiveMap = tex;
                        // [体验优化] 如果用户拖入了贴图且颜色为纯黑，自动设为纯白，否则看不见贴图
                        if (mesh->emissiveColor == glm::vec3(0.0f)) {
                            mesh->emissiveColor = glm::vec3(1.0f);
                        }
                    }
                },
                [&]() { mesh->emissiveMap = nullptr; }
            );

            // 颜色选择器 (HDR 颜色通常允许超过 1.0，但标准 ColorEdit 限制在 0-1，强度由 Strength 控制)
            ImGui::ColorEdit3("Emissive Color", glm::value_ptr(mesh->emissiveColor));
            
            // 强度滑块 (允许超过 1.0 以产生泛光效果，上限设大一点比如 10.0 or 20.0)
            ImGui::DragFloat("Intensity", &mesh->emissiveStrength, 0.1f, 0.0f, 20.0f);

            ImGui::Separator();

            std::string opacityPath = mesh->opacityMap ? mesh->opacityMap->getUri() : "";
            std::string opacityName = std::filesystem::path(opacityPath).filename().string();

            drawResourceSlot("Opacity Map", opacityName, opacityPath, "ASSET_TEXTURE",
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) mesh->opacityMap = tex;
                },
                [&]() { mesh->opacityMap = nullptr; }
            );

            if (mesh->opacityMap)
            {
                // 显示剪裁阈值滑块
                ImGui::DragFloat("Alpha Cutoff", &mesh->alphaCutoff, 0.01f, 0.0f, 1.0f);
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Pixels darker than this value will be discarded.\nUseful for foliage, fences, and grates.");
                }
            }

            ImGui::Separator();

            ImGui::Text("Advanced (Reflection / Refraction)");

            // 反射率
            ImGui::SliderFloat("Reflectivity", &mesh->material.reflectivity, 0.0f, 1.0f);
            
            // 透明度 (控制折射混合)
            ImGui::SliderFloat("Transparency", &mesh->material.transparency, 0.0f, 1.0f);

            // 只有当开启透明时，才需要调折射率
            if (mesh->material.transparency > 0.0f)
            {
                // 提供一些常用预设
                if (ImGui::BeginCombo("IOR Preset", "Custom"))
                {
                    if (ImGui::Selectable("Air (1.00)")) mesh->material.refractionIndex = 1.00f;
                    if (ImGui::Selectable("Water (1.33)")) mesh->material.refractionIndex = 1.33f;
                    if (ImGui::Selectable("Glass (1.52)")) mesh->material.refractionIndex = 1.52f;
                    if (ImGui::Selectable("Diamond (2.42)")) mesh->material.refractionIndex = 2.42f;
                    ImGui::EndCombo();
                }
                ImGui::DragFloat("IOR", &mesh->material.refractionIndex, 0.01f, 1.0f, 3.0f);
            }

            ImGui::TreePop();
        }
    }

    // --- Case 2: Light Source ---
    else if (comp->getType() == ComponentType::Light)
    {
        auto light = static_cast<LightComponent *>(comp);

        // 下拉菜单选择光源类型
        const char *typeNames[] = {"Directional", "Point", "Spot"};
        int currentType = (int)light->type;
        if (ImGui::Combo("Type", &currentType, typeNames, 3))
        {
            light->type = (LightType)currentType;
        }

        ImGui::ColorEdit3("Color", glm::value_ptr(light->color));
        ImGui::DragFloat("Intensity", &light->intensity, 0.1f, 0.0f, 10.0f);

        // 平行光和点光源现在都支持阴影，聚光灯暂时不支持（可以置灰）
        bool supportsShadows = (light->type == LightType::Directional || light->type == LightType::Point);
        if (!supportsShadows) ImGui::BeginDisabled();
        ImGui::Checkbox("Cast Shadows", &light->castShadows);
        if (!supportsShadows) ImGui::EndDisabled();

        ImGui::Separator();

        if (light->type == LightType::Directional) {
            ImGui::Text("Directional Settings");
            
            // 2. 只有开启阴影时才显示详细参数
            if (light->castShadows)
            {
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Hardware Limit: Only the first 4 active shadow-casting lights will render shadows.");
                }
                
                ImGui::Indent(); // 缩进一下，表示层级关系
                ImGui::Text("Shadow Settings");
                
                // Depth Bias
                ImGui::DragFloat("Depth Bias", &light->shadowBias, 0.0001f, 0.0f, 0.1f, "%.4f");
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pushes the shadow away, which fixes z-fighting.");

                // Normal Bias
                ImGui::DragFloat("Normal Bias", &light->shadowNormalBias, 0.001f, 0.0f, 1.0f, "%.3f");
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Shrinks the shadow caster along normals, which fixes acne.");

                // 剔除模式
                const char* cullModeNames[] = { "Cull Back", "Cull Front" };
                int currentCull = (light->shadowCullFace == GL_FRONT) ? 1 : 0;

                if (ImGui::Combo("Cull Face", &currentCull, cullModeNames, 2)) {
                    light->shadowCullFace = (currentCull == 1) ? GL_FRONT : GL_BACK;
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Front: Best for solid objects (no acne).\nBack: Best for thin objects (no leaking).");
                }
                
                ImGui::Unindent();
            }
        }

        if (light->type == LightType::Point || light->type == LightType::Spot)
        {
            ImGui::Text("Point Settings");
            ImGui::DragFloat("Range", &light->range, 0.1f, 0.1f, 1000.0f);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("The radius where light intensity falls to zero.");

            if (light->castShadows) {
                ImGui::Indent();
                ImGui::Text("Shadow Config");
                ImGui::DragFloat("Bias", &light->shadowBias, 0.001f, 0.0f, 0.5f, "%.3f");
                
                // 强度和柔和度
                ImGui::SliderFloat("Strength", &light->shadowStrength, 0.0f, 1.0f);
                ImGui::SliderFloat("Softness", &light->shadowRadius, 0.0f, 0.5f);
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Controls the blur radius of the shadow (PCF).");
                
                ImGui::Unindent();
            }
        }

        if (light->type == LightType::Spot)
        {
            ImGui::Text("Spot Settings");
            // [新增] 聚光灯也应该用 Range
            ImGui::DragFloat("Range", &light->range, 0.1f, 0.1f, 1000.0f);

            ImGui::Text("Spot Angle");
            float innerDeg = glm::degrees(glm::acos(light->cutOff));
            float outerDeg = glm::degrees(glm::acos(light->outerCutOff));

            if (ImGui::DragFloat("Inner (Deg)", &innerDeg, 0.5f, 0.0f, 180.0f))
            {
                light->cutOff = glm::cos(glm::radians(innerDeg));
            }
            if (ImGui::DragFloat("Outer (Deg)", &outerDeg, 0.5f, 0.0f, 180.0f))
            {
                light->outerCutOff = glm::cos(glm::radians(outerDeg));
            }
        }
    }

    // --- Case 3: Ref;ection Probe ---
    else if (comp->getType() == ComponentType::ReflectionProbe)
    {
        auto probe = static_cast<ReflectionProbeComponent*>(comp);
        ImGui::Text("Resolution: %d x %d", probe->resolution, probe->resolution);

        ImGui::DragFloat3("Box Size", glm::value_ptr(probe->boxSize), 0.1f, 0.1f, 100.0f);
        
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("The size of the room/environment for correct reflections.\nAdjust this to match your walls.");
        }

        ImGui::TextDisabled("Real-time baked environment map");
    }
}

void InspectorPanel::drawResourceSlot(const char* label, 
                                      const std::string& currentName, 
                                      const std::string& fullPath,
                                      const char* payloadType,
                                      std::function<void(const std::string&)> onDrop,
                                      std::function<void()> onClear) // 允许传入 nullptr
{
    ImGui::PushID(label);

    // 1. 绘制左侧标签
    ImGui::Text("%s", label);
    
    // 2. 计算布局
    bool allowClear = (onClear != nullptr); // [新增] 检查是否有清除回调
    
    float clearBtnSize = ImGui::GetFrameHeight();
    // 如果允许清除，留出 X 按钮的空间；否则占满 (-1.0f)
    float slotWidth = allowClear ? (ImGui::GetContentRegionAvail().x - clearBtnSize - 5.0f) : -1.0f;
    
    // 准备按钮文本
    std::string btnText = currentName.empty() ? "(None)" : currentName;

    // 3. 资源按钮
    ImGui::PushStyleVar(ImGuiStyleVar_ButtonTextAlign, ImVec2(0.0f, 0.5f)); 
    if (ImGui::Button(btnText.c_str(), ImVec2(slotWidth, 0))) {
        // 点击逻辑 (可选)
    }
    ImGui::PopStyleVar();

    // Tooltip
    if (ImGui::IsItemHovered() && !fullPath.empty()) {
        ImGui::SetTooltip("%s", fullPath.c_str());
    }

    // 4. 拖拽接收
    if (ImGui::BeginDragDropTarget())
    {
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(payloadType))
        {
            const char* path = (const char*)payload->Data;
            if (onDrop) onDrop(path);
        }
        ImGui::EndDragDropTarget();
    }

    // 5. [修改] 只有在允许清除时，才绘制 X 按钮和右键菜单
    if (allowClear) {
        ImGui::SameLine();
        if (ImGui::Button("X", ImVec2(clearBtnSize, 0))) {
            onClear();
        }
        
        // 右键清除菜单
        if (ImGui::BeginPopupContextItem()) {
            if (ImGui::MenuItem("Clear")) {
                onClear();
            }
            ImGui::EndPopup();
        }
    }

    ImGui::PopID();
}
```

./editor/panels/inspector_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/scene_object.h"
#include "engine/scene.h"

class InspectorPanel : public Panel {
public:
    InspectorPanel();
    
    // 渲染选中物体的属性
    void onImGuiRender(GameObject*& selectedObject, Scene* sceneContext);

    void onImGuiRender() override {}

private:
    // 内部辅助函数：绘制组件列表
    void drawComponents(GameObject* obj);
    
    // 内部辅助函数：绘制单个组件的具体 UI
    void drawComponentUI(Component* comp);

    // 通用资源槽绘制函数
    // label: 属性名 (如 "Diffuse Map")
    // currentName: 当前资源的显示名称 (如 "box.png" 或 "(None)")
    // fullPath: 完整路径 (用于 Tooltip 显示)
    // payloadType: 拖拽类型 (如 "ASSET_OBJ")
    // onDrop: 接收到拖拽时的回调
    // onClear: 点击清除时的回调
    void drawResourceSlot(const char* label, 
                          const std::string& currentName, 
                          const std::string& fullPath, 
                          const char* payloadType,
                          std::function<void(const std::string&)> onDrop,
                          std::function<void()> onClear);
};
```

./editor/panels/panel.h:
```
#pragma once
#include <string>
#include <imgui.h>

class Panel {
public:
    Panel(const std::string& title) : _title(title) {}
    virtual ~Panel() = default;

    // 核心绘制函数
    // 子类实现具体的 ImGui::Begin() ... End() 逻辑
    virtual void onImGuiRender() = 0;

    // 显示/隐藏控制
    void open() { _isOpen = true; }
    void close() { _isOpen = false; }
    bool isOpen() const { return _isOpen; }
    
    // 设置是否可见的引用 (用于 MenuItem 的 bool*)
    bool* getOpenPtr() { return &_isOpen; }

protected:
    std::string _title;
    bool _isOpen = true;
};
```

./editor/panels/project_panel.cpp:
```
#include "project_panel.h"
#include <imgui.h>
#include <algorithm>

ProjectPanel::ProjectPanel() : Panel("Project / Assets") {}

void ProjectPanel::onImGuiRender()
{
    if (!_isOpen) return;

    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    const auto& files = ResourceManager::Get().getFileList();
    
    float padding = 10.0f;
    float thumbnailSize = 80.0f;
    float cellSize = thumbnailSize + padding;
    float panelWidth = ImGui::GetContentRegionAvail().x;
    int columnCount = (int)(panelWidth / cellSize);
    if (columnCount < 1) columnCount = 1;

    ImGui::Columns(columnCount, 0, false);

    for (const auto& file : files)
    {
        std::string filename = file.first;
        std::string relativePath = file.second;

        std::string ext = std::filesystem::path(filename).extension().string();
        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
        bool isModel = (ext == ".obj");
        bool isTexture = (ext == ".png" || ext == ".jpg" || ext == ".jpeg" || ext == ".bmp" || ext == ".tga");

        ImGui::PushID(relativePath.c_str());

        // 按钮代表文件
        ImGui::Button(filename.c_str(), ImVec2(80, 80));

        // 拖拽源
        if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_SourceAllowNullID))
        {
            if (isModel) {
                ImGui::SetDragDropPayload("ASSET_OBJ", relativePath.c_str(), relativePath.size() + 1);
                ImGui::Text("Model: %s", filename.c_str());
            }
            else if (isTexture)
            {
                ImGui::SetDragDropPayload("ASSET_TEXTURE", relativePath.c_str(), relativePath.size() + 1);
                ImGui::Text("Texture: %s", filename.c_str());
            }
            ImGui::EndDragDropSource();
        }

        ImGui::TextWrapped("%s", filename.c_str());
        ImGui::PopID();
        ImGui::NextColumn();
    }

    ImGui::Columns(1);
    ImGui::End();
}
```

./editor/panels/project_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/resource_manager.h"

class ProjectPanel : public Panel {
public:
    ProjectPanel();
    void onImGuiRender() override;
private:
    // 这里可以缓存一些缩略图纹理 ID
};
```

./editor/panels/scene_view_panel.cpp:
```
#include "scene_view_panel.h"
#include <imgui.h>
#include <iostream>
#include <limits> // for std::numeric_limits

SceneViewPanel::SceneViewPanel() : Panel("3D Viewport")
{
    // 初始化 FBO (初始大小可以为 0，后面会自动 Resize)
    initFBO(100, 100); 
    
    // 初始化相机控制器
    // 初始宽高暂定为 800x600，会在第一次渲染时修正
    _cameraController = std::make_unique<EditorCamera>(800, 600);
}

SceneViewPanel::~SceneViewPanel()
{
    if (_fbo.id) glDeleteFramebuffers(1, &_fbo.id);
    if (_fbo.texture) glDeleteTextures(1, &_fbo.texture);
    if (_fbo.rbo) glDeleteRenderbuffers(1, &_fbo.rbo);
}

void SceneViewPanel::initFBO(int width, int height)
{
    _fbo.width = width;
    _fbo.height = height;

    glGenFramebuffers(1, &_fbo.id);
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo.id);

    glGenTextures(1, &_fbo.texture);
    glBindTexture(GL_TEXTURE_2D, _fbo.texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _fbo.texture, 0);

    glGenRenderbuffers(1, &_fbo.rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, _fbo.rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _fbo.rbo);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: SceneView Framebuffer is not complete!" << std::endl;
    
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void SceneViewPanel::resizeFBO(int width, int height)
{
    if (_fbo.width == width && _fbo.height == height) return;
    
    glDeleteFramebuffers(1, &_fbo.id);
    glDeleteTextures(1, &_fbo.texture);
    glDeleteRenderbuffers(1, &_fbo.rbo);
    initFBO(width, height);
}
// [修改后的签名]
void SceneViewPanel::onImGuiRender(Scene* scene, Renderer* renderer, GameObject*& selectedObject, float contentScale)
{
    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f)); 
    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End(); ImGui::PopStyleVar(); return;
    }

    _isFocused = ImGui::IsWindowFocused(); 
    _isHovered = ImGui::IsWindowHovered();

    ImVec2 viewportPanelSize = ImGui::GetContentRegionAvail();
    if (viewportPanelSize.x <= 0) viewportPanelSize.x = 1;
    if (viewportPanelSize.y <= 0) viewportPanelSize.y = 1;

    int rawWidth = (int)(viewportPanelSize.x * contentScale);
    int rawHeight = (int)(viewportPanelSize.y * contentScale);

    // 2. Resize FBO
    if (rawWidth != _fbo.width || rawHeight != _fbo.height)
    {
        resizeFBO(rawWidth, rawHeight);
        renderer->onResize(rawWidth, rawHeight);
        _cameraController->onResize(rawWidth, rawHeight);
    }

    // 3. 执行渲染 (Render to FBO)
    // 注意：这里我们直接调用 renderer，不再需要 SceneRoaming 中转
    if (_fbo.id != 0) {
        renderer->render(*scene, 
                         _cameraController->getActiveCamera(), 
                         _fbo.id, rawWidth, rawHeight, 
                         contentScale, selectedObject);
    }

    // 4. 绘制 Image
    ImGui::Image((ImTextureID)(intptr_t)_fbo.texture, viewportPanelSize, ImVec2(0, 1), ImVec2(1, 0));

    // 记录视口位置 (用于射线检测和 Gizmo)
    _viewportPos = ImGui::GetItemRectMin();
    _viewportSize = ImGui::GetItemRectSize();

    // 5. 绘制 Gizmo
    _cameraController->drawViewGizmo(
        glm::vec2(_viewportPos.x, _viewportPos.y), 
        glm::vec2(_viewportSize.x, _viewportSize.y)
    );

    ImGui::End();
    ImGui::PopStyleVar();
}

// [完整签名]
void SceneViewPanel::onInputUpdate(float dt, Scene* scene, GameObject*& selectedObject)
{
    // 如果键盘正被 UI 占用（例如正在输入文字），不处理 3D 快捷键
    if (ImGui::GetIO().WantCaptureKeyboard) return;

    _isControlling = _cameraController->isControlling();

    // 快捷键 (F 聚焦)
    // 这里需要 GLFW 窗口句柄来检测按键吗？ ImGui 提供了 IsKeyPressed
    if (ImGui::IsKeyPressed(ImGuiKey_F)) {
        _cameraController->frameObject(selectedObject);
    }
    
    // Key 1: Front View (+Z)
    if (ImGui::IsKeyPressed(ImGuiKey_1) || ImGui::IsKeyPressed(ImGuiKey_Keypad1)) {
        _cameraController->switchToView(glm::vec3(0, 0, 1));
    }
    // Key 3: Right View (+X)
    if (ImGui::IsKeyPressed(ImGuiKey_3) || ImGui::IsKeyPressed(ImGuiKey_Keypad3)) {
        _cameraController->switchToView(glm::vec3(1, 0, 0));
    }
    // Key 7: Top View (+Y)
    if (ImGui::IsKeyPressed(ImGuiKey_7) || ImGui::IsKeyPressed(ImGuiKey_Keypad7)) {
        _cameraController->switchToView(glm::vec3(0, 1, 0));
    }

    // Delete
    if (ImGui::IsKeyPressed(ImGuiKey_Delete) && selectedObject)
    {
        if (scene) scene->markForDestruction(selectedObject);
        selectedObject = nullptr; 
    }

    if (_isHovered || _isFocused || _isControlling) {
        _cameraController->handleInput(); 
    }
    _cameraController->update(dt);

    // 拾取逻辑
    if (_isHovered && ImGui::IsMouseClicked(0) && !ImGui::IsKeyDown(ImGuiKey_LeftAlt)) {
        // 还要检查是否点到了 Gizmo (isControlling)
        if (!_cameraController->isControlling()) {
            handleMousePick(scene, selectedObject);
        }
    }
}

// [搬运] handleMousePick
void SceneViewPanel::handleMousePick(Scene* scene, GameObject*& selectedObject)
{
    // [变化1] 使用成员变量 _isHovered
    if (!_isHovered) 
        return;

    // [变化2] 使用 ImGui 获取鼠标绝对坐标 (替代 glfwGetCursorPos)
    ImVec2 mousePos = ImGui::GetMousePos();
    float mouseX = mousePos.x;
    float mouseY = mousePos.y;

    // [变化3] 使用成员变量 _cameraController, _viewportPos, _viewportSize
    auto camRay = _cameraController->screenPointToRay(
        mouseX, mouseY, 
        _viewportPos.x, _viewportPos.y, 
        _viewportSize.x, _viewportSize.y
    );

    // 转换成 Physics Ray
    // (假设 EditorCamera::Ray 和 PhysicsUtils::Ray 结构一致，或者是同一种类型)
    Ray worldRay(camRay.origin, camRay.direction);

    // [调试]
    // std::cout << "Ray Dir: " << worldRay.direction.x << ", " 
    //           << worldRay.direction.y << ", " << worldRay.direction.z << std::endl;

    GameObject *closestObj = nullptr;
    float closestDist = std::numeric_limits<float>::max();

    // [变化4] 使用传入的 scene 指针
    if (scene) 
    {
        const auto& objects = scene->getGameObjects();
        for (const auto &go : objects)
        {
            auto meshComp = go->getComponent<MeshComponent>();
            if (!meshComp || !meshComp->enabled) continue;

            // --- 以下数学逻辑完全保持不变 ---

            // 1. 计算 Model Matrix
            glm::mat4 modelMatrix = go->transform.getLocalMatrix();
            modelMatrix = modelMatrix * meshComp->model->transform.getLocalMatrix();

            // 2. 将射线转到局部空间
            glm::mat4 invModel = glm::inverse(modelMatrix);

            glm::vec3 localOrigin = glm::vec3(invModel * glm::vec4(worldRay.origin, 1.0f));
            glm::vec3 localDir = glm::vec3(invModel * glm::vec4(worldRay.direction, 0.0f));
            
            // 归一化
            localDir = glm::normalize(localDir);

            Ray localRay(localOrigin, localDir);

            // 3. 检测
            float tBox = 0.0f;
            if (PhysicsUtils::intersectRayAABB(localRay, meshComp->model->getBoundingBox(), tBox))
            {
                // 如果只击中盒子，还不算选中，必须击中三角形
                // 只有当 AABB 击中时，才进行昂贵的 Mesh 检测
                
                // ==================================================
                // Phase 2: 精测 (Narrow Phase) - Mesh
                // ==================================================
                float tMesh = 0.0f;
                const auto& verts = meshComp->model->getVertices();
                const auto& indices = meshComp->model->getIndices();

                if (PhysicsUtils::intersectRayMesh(localRay, verts, indices, tMesh))
                {
                    // [关键] tMesh 是局部空间的距离。
                    // 为了在不同缩放的物体之间正确排序，我们需要把它转换回世界空间距离。
                    // WorldPos = WorldOrigin + WorldDir * tWorld
                    // LocalPos = LocalOrigin + LocalDir * tMesh
                    // 简单的近似：把 LocalHitPos 转回 WorldPos，然后算距离。
                    
                    glm::vec3 localHitPos = localRay.origin + localRay.direction * tMesh;
                    glm::vec3 worldHitPos = glm::vec3(modelMatrix * glm::vec4(localHitPos, 1.0f));
                    float worldDist = glm::distance(worldRay.origin, worldHitPos);

                    if (worldDist < closestDist)
                    {
                        closestDist = worldDist;
                        closestObj = go.get();
                    }
                }
            }
        }
    }

    // [变化5] 更新传入的引用引用
    selectedObject = closestObj;
    
    // [调试]
    if(selectedObject) std::cout << "Picked: " << selectedObject->name << std::endl;
}
```

./editor/panels/scene_view_panel.h:
```
#pragma once
#include "panel.h"
#include <memory>
#include <glad/gl.h>
#include "editor/editor_camera.h"
#include "engine/renderer.h"
#include "engine/scene.h"

class SceneViewPanel : public Panel {
public:
    SceneViewPanel();
    ~SceneViewPanel();

    // 核心绘制函数
    // 需要传入 Scene 和 Renderer，因为面板只负责"显示"，不负责"拥有"数据
    void onImGuiRender(Scene* scene, Renderer* renderer, GameObject*& selectedObject, float contentScale);

    // 2. [关键修复] 必须覆盖基类的纯虚函数，否则此类为抽象类
    // 给一个空实现即可，因为我们不会通过 Panel* 多态指针来调用这个函数
    void onImGuiRender() override {}

    // 处理输入 (键盘/鼠标)
    // 之前在 SceneRoaming::handleInput 里的逻辑移到这里
    void onInputUpdate(float dt, Scene* scene, GameObject*& selectedObject);

    // 获取内部的相机 (供外部查询，如 Renderer 需要相机矩阵)
    Camera* getCamera() const { return _cameraController->getActiveCamera(); }

private:
    std::unique_ptr<EditorCamera> _cameraController;

    // FBO 相关资源
    struct FrameBuffer {
        GLuint id = 0;
        GLuint texture = 0;
        GLuint rbo = 0;
        int width = 0;
        int height = 0;
    } _fbo;

    // 视口状态
    ImVec2 _viewportPos = {0, 0};
    ImVec2 _viewportSize = {0, 0};
    bool _isHovered = false;
    bool _isFocused = false;
    bool _isControlling = false;

    // 内部辅助
    void initFBO(int width, int height);
    void resizeFBO(int width, int height);
    void handleMousePick(Scene* scene, GameObject*& selectedObject);
};
```

./engine/geometry_factory.cpp:
```
#include "geometry_factory.h"
#include <cmath>

// 辅助函数：添加四边形面 (由两个三角形组成)
static void addQuad(std::vector<Vertex> &vertices, std::vector<uint32_t> &indices,
                    const Vertex &v0, const Vertex &v1, const Vertex &v2, const Vertex &v3)
{
    // 两个三角形: 0-1-2 和 0-2-3
    uint32_t baseIndex = static_cast<uint32_t>(vertices.size());
    vertices.push_back(v0);
    vertices.push_back(v1);
    vertices.push_back(v2);
    vertices.push_back(v3);

    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 1);
    indices.push_back(baseIndex + 2);

    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 2);
    indices.push_back(baseIndex + 3);
}

void GeometryFactory::convertToFlat(std::vector<Vertex>& vertices, std::vector<uint32_t>& indices)
{
    std::vector<Vertex> newVertices;
    std::vector<uint32_t> newIndices;

    newVertices.reserve(indices.size());
    newIndices.reserve(indices.size());

    for (size_t i = 0; i < indices.size(); i += 3)
    {
        uint32_t i0 = indices[i];
        uint32_t i1 = indices[i+1];
        uint32_t i2 = indices[i+2];

        Vertex v0 = vertices[i0];
        Vertex v1 = vertices[i1];
        Vertex v2 = vertices[i2];

        // 重新计算面法线
        glm::vec3 edge1 = v1.position - v0.position;
        glm::vec3 edge2 = v2.position - v0.position;
        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

        v0.normal = faceNormal;
        v1.normal = faceNormal;
        v2.normal = faceNormal;

        newVertices.push_back(v0);
        newVertices.push_back(v1);
        newVertices.push_back(v2);

        uint32_t startIdx = static_cast<uint32_t>(newVertices.size()) - 3;
        newIndices.push_back(startIdx);
        newIndices.push_back(startIdx + 1);
        newIndices.push_back(startIdx + 2);
    }

    vertices = std::move(newVertices);
    indices = std::move(newIndices);
}

std::shared_ptr<Model> GeometryFactory::createFrustum(float topRadius, float bottomRadius, float height, int slices, bool useFlatShade)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;

    float halfH = height / 2.0f;

    // ==========================================
    // 1. 生成侧面 (Side)
    // ==========================================
    // 我们需要多生成一个点来闭合纹理坐标 (0.0 -> 1.0)
    for (int i = 0; i <= slices; ++i)
    {
        float u = (float)i / (float)slices;
        float theta = u * 2.0f * glm::pi<float>();

        float cosTheta = cos(theta);
        float sinTheta = sin(theta);

        // 顶点位置
        glm::vec3 topPos(cosTheta * topRadius, halfH, sinTheta * topRadius);
        glm::vec3 bottomPos(cosTheta * bottomRadius, -halfH, sinTheta * bottomRadius);

        // 1. 计算半径差 (底 - 顶)
        //    如果底比顶大 (圆锥)，diff > 0，法线应该朝上 (Y > 0)
        //    如果底比顶小 (倒圆台)，diff < 0，法线应该朝下 (Y < 0)
        float rDiff = bottomRadius - topRadius;

        // 2. 计算斜边长度 (勾股定理)
        //    用于归一化，确保法线长度为 1
        float slantLen = std::sqrt(rDiff * rDiff + height * height);

        // 3. 计算法线分量
        //    水平分量由高度决定 (面越陡，法线越平)
        //    垂直分量由半径差决定 (面越平，法线越竖)
        float nx = cosTheta * (height / slantLen);
        float ny = rDiff / slantLen; 
        float nz = sinTheta * (height / slantLen);

        glm::vec3 normal(nx, ny, nz);

        // 如果是棱柱/棱台（sides较少），通常需要 Flat Shading（每个面独立顶点），
        // 但为了代码简洁，这里使用 Smooth Shading（共用顶点）。
        // 如果觉得棱柱看起来太圆滑，可以后续改为每个面独立生成顶点。

        vertices.push_back(Vertex(bottomPos, normal, glm::vec2(u, 0.0f))); // 偶数索引
        vertices.push_back(Vertex(topPos, normal, glm::vec2(u, 1.0f)));    // 奇数索引
    }

    // 侧面索引生成 (Triangle Strip 逻辑转为 Triangles)
    for (int i = 0; i < slices; ++i)
    {
        // 当前列的两个顶点索引
        int currentBottom = i * 2;
        int currentTop = currentBottom + 1;
        // 下一列的两个顶点索引
        int nextBottom = currentBottom + 2;
        int nextTop = currentTop + 2;

        // 三角形 1
        indices.push_back(currentBottom);
        indices.push_back(currentTop);
        indices.push_back(nextBottom);

        // 三角形 2
        indices.push_back(currentTop);
        indices.push_back(nextTop);
        indices.push_back(nextBottom);
    }
    

    // ==========================================
    // 2. 生成顶盖 (Top Cap) - 如果半径 > 0
    // ==========================================
    if (topRadius > 1e-6)
    {
        uint32_t centerIndex = static_cast<uint32_t>(vertices.size());

        // 中心点
        vertices.push_back(Vertex(glm::vec3(0, halfH, 0), glm::vec3(0, 1, 0), glm::vec2(0.5f, 0.5f)));

        // 圆环点
        for (int i = 0; i <= slices; ++i)
        {
            float u = (float)i / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();
            float x = cos(theta) * topRadius;
            float z = sin(theta) * topRadius;

            // 纹理坐标简单映射
            float uMap = (cos(theta) * 0.5f) + 0.5f;
            float vMap = (sin(theta) * 0.5f) + 0.5f;

            vertices.push_back(Vertex(glm::vec3(x, halfH, z), glm::vec3(0, 1, 0), glm::vec2(uMap, vMap)));
        }

        // 索引 (Triangle Fan)
        for (int i = 0; i < slices; ++i)
        {
            indices.push_back(centerIndex);
            indices.push_back(centerIndex + 1 + i + 1); // 下一点
            indices.push_back(centerIndex + 1 + i);     // 当前点
        }
    }

    // ==========================================
    // 3. 生成底盖 (Bottom Cap) - 如果半径 > 0
    // ==========================================
    if (bottomRadius > 1e-6)
    {
        uint32_t centerIndex = static_cast<uint32_t>(vertices.size());

        // 中心点
        vertices.push_back(Vertex(glm::vec3(0, -halfH, 0), glm::vec3(0, -1, 0), glm::vec2(0.5f, 0.5f)));

        // 圆环点
        for (int i = 0; i <= slices; ++i)
        {
            float u = (float)i / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();
            float x = cos(theta) * bottomRadius;
            float z = sin(theta) * bottomRadius;

            float uMap = (cos(theta) * 0.5f) + 0.5f;
            float vMap = (sin(theta) * 0.5f) + 0.5f;

            vertices.push_back(Vertex(glm::vec3(x, -halfH, z), glm::vec3(0, -1, 0), glm::vec2(uMap, vMap)));
        }

        // 索引 (Triangle Fan) - 注意顺序相反以保持逆时针
        for (int i = 0; i < slices; ++i)
        {
            indices.push_back(centerIndex);
            indices.push_back(centerIndex + 1 + i);     // 当前点
            indices.push_back(centerIndex + 1 + i + 1); // 下一点
        }
    }

    if (useFlatShade) {
        convertToFlat(vertices, indices);
    }

    computeTangents(vertices, indices);

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createCube(float size)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    float h = size / 2.0f;

    // 前面 (Normal +Z)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, h), glm::vec3(0, 0, 1), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, h), glm::vec3(0, 0, 1), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, h), glm::vec3(0, 0, 1), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, h), glm::vec3(0, 0, 1), glm::vec2(0, 1)});
    // 后面 (Normal -Z)
    addQuad(vertices, indices,
            Vertex{glm::vec3(h, -h, -h), glm::vec3(0, 0, -1), glm::vec2(0, 0)},
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(0, 0, -1), glm::vec2(1, 0)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(0, 0, -1), glm::vec2(1, 1)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(0, 0, -1), glm::vec2(0, 1)});
    // 左面 (Normal -X)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(-1, 0, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(-h, -h, h), glm::vec3(-1, 0, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(-h, h, h), glm::vec3(-1, 0, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(-1, 0, 0), glm::vec2(0, 1)});
    // 右面 (Normal +X)
    addQuad(vertices, indices,
            Vertex{glm::vec3(h, -h, h), glm::vec3(1, 0, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, -h), glm::vec3(1, 0, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(1, 0, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(h, h, h), glm::vec3(1, 0, 0), glm::vec2(0, 1)});
    // 上面 (Normal +Y)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, h, h), glm::vec3(0, 1, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, h, h), glm::vec3(0, 1, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(0, 1, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(0, 1, 0), glm::vec2(0, 1)});
    // 下面 (Normal -Y)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(0, -1, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, -h), glm::vec3(0, -1, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, -h, h), glm::vec3(0, -1, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, -h, h), glm::vec3(0, -1, 0), glm::vec2(0, 1)});

    computeTangents(vertices, indices);

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createPlane(float width, float depth)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    float w = width / 2.0f;
    float d = depth / 2.0f;

    // 一个向上平铺的大矩形
    addQuad(vertices, indices,
            Vertex{glm::vec3(-w, 0, d), glm::vec3(0, 1, 0), glm::vec2(0, 0)},         // 左下
            Vertex{glm::vec3(w, 0, d), glm::vec3(0, 1, 0), glm::vec2(width, 0)},      // 右下 (UV重复)
            Vertex{glm::vec3(w, 0, -d), glm::vec3(0, 1, 0), glm::vec2(width, depth)}, // 右上
            Vertex{glm::vec3(-w, 0, -d), glm::vec3(0, 1, 0), glm::vec2(0, depth)}     // 左上
    );

    computeTangents(vertices, indices);

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createSphere(float radius, int stacks, int slices, bool useFlatShade)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;

    for (int i = 0; i <= stacks; ++i)
    {
        float v = (float)i / (float)stacks;
        float phi = v * glm::pi<float>();

        for (int j = 0; j <= slices; ++j)
        {
            float u = (float)j / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();

            float x = cos(theta) * sin(phi);
            float y = cos(phi);
            float z = sin(theta) * sin(phi);

            glm::vec3 pos = glm::vec3(x, y, z) * radius;
            glm::vec3 normal = glm::vec3(x, y, z);
            glm::vec2 uv = glm::vec2(u, v);

            vertices.push_back(Vertex(pos, normal, uv));
        }
    }

    for (int i = 0; i < stacks; ++i)
    {
        for (int j = 0; j < slices; ++j)
        {
            int first = (i * (slices + 1)) + j;
            int second = first + slices + 1;

            indices.push_back(first);
            indices.push_back(first + 1);
            indices.push_back(second);

            indices.push_back(second);
            indices.push_back(first + 1);
            indices.push_back(second + 1);
        }
    }

    if (useFlatShade) {
        convertToFlat(vertices, indices);
    }

    computeTangents(vertices, indices);

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createCylinder(float radius, float height, int slices, bool useFlatShade)
{
    return createFrustum(radius, radius, height, slices, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createCone(float radius, float height, int slices, bool useFlatShade)
{
    return createFrustum(0.0f, radius, height, slices, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createPrism(float radius, float height, int sides, bool useFlatShade)
{
    // 棱柱本质上就是 slices 很少的圆柱
    return createFrustum(radius, radius, height, sides, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createPyramidFrustum(float topRadius, float bottomRadius, float height, int sides, bool useFlatShade)
{
    // 棱台本质上就是 slices 很少的圆台
    return createFrustum(topRadius, bottomRadius, height, sides, useFlatShade);
}

void GeometryFactory::computeTangents(std::vector<Vertex>& vertices, const std::vector<uint32_t>& indices)
{
    // 1. 初始化所有切线为 0
    for (auto& v : vertices) {
        v.tangent = glm::vec3(0.0f);
    }

    // 2. 遍历所有三角形，累加切线
    for (size_t i = 0; i < indices.size(); i += 3)
    {
        Vertex& v0 = vertices[indices[i]];
        Vertex& v1 = vertices[indices[i+1]];
        Vertex& v2 = vertices[indices[i+2]];

        glm::vec3 edge1 = v1.position - v0.position;
        glm::vec3 edge2 = v2.position - v0.position;

        glm::vec2 deltaUV1 = v1.texCoord - v0.texCoord;
        glm::vec2 deltaUV2 = v2.texCoord - v0.texCoord;

        float f = 1.0f / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);

        glm::vec3 tangent;
        tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
        tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
        tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);

        // 累加到三个顶点上 (平滑切线)
        v0.tangent += tangent;
        v1.tangent += tangent;
        v2.tangent += tangent;
    }

    // 3. 正交化 (Gram-Schmidt) 并归一化
    for (auto& v : vertices)
    {
        // 重新正交化，确保切线垂直于法线
        v.tangent = glm::normalize(v.tangent - v.normal * glm::dot(v.normal, v.tangent));
        
        // (可选) 这里可以计算 Bitangent 的手性并存储到 w 分量，但目前我们先只算 Tangent
    }
}
```

./engine/geometry_factory.h:
```
#pragma once

#include <vector>
#include <memory>
#include "base/vertex.h"
#include "model.h" // 我们需要返回 Model 对象

class GeometryFactory
{
public:
    // 1. 立方体 (用于墙壁、地板、箱子)
    static std::shared_ptr<Model> createCube(float size = 1.0f);

    // 5. 平面 (专门用于地板，虽然可以用压扁的立方体代替，但单面更高效)
    static std::shared_ptr<Model> createPlane(float width = 10.0f, float depth = 10.0f);

    // 2. 球体 (用于装饰、测试光照)
    // stacks: 纬度切片数, slices: 经度切片数 (越高越圆)
    static std::shared_ptr<Model> createSphere(float radius = 0.5f, int stacks = 16, int slices = 32, bool useFlatShade = false);

    // -----------------------------------------------------------------------
    // 通用几何生成核心 (Frustum)
    // -----------------------------------------------------------------------
    // 这是一个万能函数：
    // - topRadius == bottomRadius, slices > 20 -> 圆柱
    // - topRadius == 0                         -> 圆锥
    // - topRadius != bottomRadius              -> 圆台
    // - slices == 3, 4, 5, 6...                -> 三棱柱/台, 四棱柱/台...
    static std::shared_ptr<Model> createFrustum(float topRadius, float bottomRadius, float height, int slices, bool useFlatShade);

    // 4. 圆柱体 (Cylinder) - 实际上是调用 createFrustum
    static std::shared_ptr<Model> createCylinder(float radius = 0.5f, float height = 1.0f, int slices = 32, bool useFlatShade = false);

    // 5. 圆锥体 (Cone) - 实际上是调用 createFrustum
    static std::shared_ptr<Model> createCone(float radius = 0.5f, float height = 1.0f, int slices = 32, bool useFlatShade = false);

    // 6. 多面棱柱 (Prism) - 比如六棱柱: radius=1, slices=6
    static std::shared_ptr<Model> createPrism(float radius = 0.5f, float height = 1.0f, int sides = 6, bool useFlatShade = false);

    // 7. 多面棱台 (Prism Frustum) - 比如四棱台: topR=0.5, bottomR=1, slices=4
    static std::shared_ptr<Model> createPyramidFrustum(float topRadius, float bottomRadius, float height, int sides = 4, bool useFlatShade = false);

    // 通用切线计算函数 (修改 vertices 数组的内容)
    static void computeTangents(std::vector<Vertex>& vertices, const std::vector<uint32_t>& indices);
    
private:
    static void convertToFlat(std::vector<Vertex>& vertices, std::vector<uint32_t>& indices);
};
```

./engine/model.cpp:
```
#include "model.h"
#include "obj_loader.h"

#include <algorithm>
#include <iostream>
#include <limits>

Model::Model(const std::string &filepath, bool useFlatShade)
    : _isUploaded(false)
{
    // 1. 调用 OBJLoader 获取数据
    // 这里利用了 C++ 的返回值优化 (RVO)，不会产生不必要的深拷贝
    MeshData data = OBJLoader::load(filepath, useFlatShade);

    // 2. 将数据移动到 Model 的成员变量中
    _vertices = std::move(data.vertices);
    _indices = std::move(data.indices);
    _hasUVs = data.hasUVs;

    // 3. 后续初始化流程保持不变
    computeBoundingBox();
}

Model::Model(const std::vector<Vertex> &vertices, const std::vector<uint32_t> &indices)
    : _vertices(vertices), _indices(indices), _isUploaded(false)
{
    _hasUVs = true;
    computeBoundingBox();
}

Model::Model(Model &&rhs) noexcept
    : _vertices(std::move(rhs._vertices)), _indices(std::move(rhs._indices)),
      _boundingBox(std::move(rhs._boundingBox)), _vao(rhs._vao), _vbo(rhs._vbo), _ebo(rhs._ebo),
      _boxVao(rhs._boxVao), _boxVbo(rhs._boxVbo), _boxEbo(rhs._boxEbo)
{
    rhs._vao = 0;
    rhs._vbo = 0;
    rhs._ebo = 0;

    rhs._boxVao = 0;
    rhs._boxVbo = 0;
    rhs._boxEbo = 0;
}

Model::~Model()
{
    cleanup();
}

BoundingBox Model::getBoundingBox() const
{
    return _boundingBox;
}

void Model::initGL()
{
    if (_isUploaded) return; // 防止重复初始化

    // 确保此时有 OpenGL 上下文 (如果没有，glGetError 或 glGen* 会报错/崩溃，但此时通常都在渲染循环里了)
    initGLResources();
    initBoxGLResources();

    _isUploaded = true;
}

void Model::draw()
{
    if (!_isUploaded) {
        // const_cast 是一种妥协，或者将 initGL 声明为 const 并把内部变量设为 mutable
        // 这里最优雅的方式是将 _isUploaded 设为 mutable (已在 .h 中完成)
        const_cast<Model*>(this)->initGL();
    }

    if (_vao == 0) return; // 如果初始化失败，防止崩溃

    glBindVertexArray(_vao);
    glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(_indices.size()), GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}

void Model::drawBoundingBox()
{
    if (!_isUploaded) {
         const_cast<Model*>(this)->initGL();
    }

    if (_boxVao == 0) return;
    
    glBindVertexArray(_boxVao);
    glDrawElements(GL_LINES, 24, GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}

GLuint Model::getVao() const
{
    return _vao;
}

GLuint Model::getBoundingBoxVao() const
{
    return _boxVao;
}

size_t Model::getVertexCount() const
{
    return _vertices.size();
}

size_t Model::getFaceCount() const
{
    return _indices.size() / 3;
}

void Model::initGLResources()
{
    // create a vertex array object
    glGenVertexArrays(1, &_vao);
    // create a vertex buffer object
    glGenBuffers(1, &_vbo);
    // create a element array buffer
    glGenBuffers(1, &_ebo);

    glBindVertexArray(_vao);
    glBindBuffer(GL_ARRAY_BUFFER, _vbo);
    glBufferData(
        GL_ARRAY_BUFFER, sizeof(Vertex) * _vertices.size(), _vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ebo);
    glBufferData(
        GL_ELEMENT_ARRAY_BUFFER, _indices.size() * sizeof(uint32_t), _indices.data(),
        GL_STATIC_DRAW);

    // specify layout, size of a vertex, data type, normalize, sizeof vertex array, offset of the
    // attribute
    // location 0: position
    glVertexAttribPointer(
        0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, position));
    glEnableVertexAttribArray(0);
    // location 1: normal
    glVertexAttribPointer(
        1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);
    // location 2: texCoord
    glVertexAttribPointer(
        2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, texCoord));
    glEnableVertexAttribArray(2);
    // location 3: tangent
    glVertexAttribPointer(
        3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, tangent));
    glEnableVertexAttribArray(3);

    glBindVertexArray(0);
}

void Model::computeBoundingBox()
{
    float minX = std::numeric_limits<float>::max();
    float minY = std::numeric_limits<float>::max();
    float minZ = std::numeric_limits<float>::max();
    float maxX = -std::numeric_limits<float>::max();
    float maxY = -std::numeric_limits<float>::max();
    float maxZ = -std::numeric_limits<float>::max();

    for (const auto &v : _vertices)
    {
        minX = std::min(v.position.x, minX);
        minY = std::min(v.position.y, minY);
        minZ = std::min(v.position.z, minZ);
        maxX = std::max(v.position.x, maxX);
        maxY = std::max(v.position.y, maxY);
        maxZ = std::max(v.position.z, maxZ);
    }

    _boundingBox.min = glm::vec3(minX, minY, minZ);
    _boundingBox.max = glm::vec3(maxX, maxY, maxZ);

    // =========================================================
    // [修复] 防止零厚度导致的射线检测失败
    // 给极薄的物体（如 Plane, Quad）增加一个微小的厚度 (Epsilon)
    // =========================================================
    constexpr float EPSILON = 0.01f;

    if ((_boundingBox.max.x - _boundingBox.min.x) < EPSILON)
    {
        _boundingBox.max.x += EPSILON;
        _boundingBox.min.x -= EPSILON;
    }
    if ((_boundingBox.max.y - _boundingBox.min.y) < EPSILON)
    {
        _boundingBox.max.y += EPSILON;
        _boundingBox.min.y -= EPSILON; // 向下加厚一点
    }
    if ((_boundingBox.max.z - _boundingBox.min.z) < EPSILON)
    {
        _boundingBox.max.z += EPSILON;
        _boundingBox.min.z -= EPSILON;
    }
}

void Model::initBoxGLResources()
{
    std::vector<glm::vec3> boxVertices = {
        glm::vec3(_boundingBox.min.x, _boundingBox.min.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.min.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.max.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.max.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.min.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.min.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.max.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.max.y, _boundingBox.max.z),
    };

    std::vector<uint32_t> boxIndices = {0, 1, 0, 2, 0, 4, 3, 1, 3, 2, 3, 7,
                                        5, 4, 5, 1, 5, 7, 6, 4, 6, 7, 6, 2};

    glGenVertexArrays(1, &_boxVao);
    glGenBuffers(1, &_boxVbo);
    glGenBuffers(1, &_boxEbo);

    glBindVertexArray(_boxVao);
    glBindBuffer(GL_ARRAY_BUFFER, _boxVbo);
    glBufferData(
        GL_ARRAY_BUFFER, boxVertices.size() * sizeof(glm::vec3), boxVertices.data(),
        GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _boxEbo);
    glBufferData(
        GL_ELEMENT_ARRAY_BUFFER, boxIndices.size() * sizeof(uint32_t), boxIndices.data(),
        GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3), 0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(0);
}

void Model::cleanup()
{
    if (_boxEbo)
    {
        glDeleteBuffers(1, &_boxEbo);
        _boxEbo = 0;
    }

    if (_boxVbo)
    {
        glDeleteBuffers(1, &_boxVbo);
        _boxVbo = 0;
    }

    if (_boxVao)
    {
        glDeleteVertexArrays(1, &_boxVao);
        _boxVao = 0;
    }

    if (_ebo != 0)
    {
        glDeleteBuffers(1, &_ebo);
        _ebo = 0;
    }

    if (_vbo != 0)
    {
        glDeleteBuffers(1, &_vbo);
        _vbo = 0;
    }

    if (_vao != 0)
    {
        glDeleteVertexArrays(1, &_vao);
        _vao = 0;
    }
}
```

./engine/model.h:
```
#pragma once

#include <string>
#include <vector>

#include "base/bounding_box.h"
#include "base/gl_utility.h"
#include "base/transform.h"
#include "base/vertex.h"

class Model
{
public:
    Model(const std::string &filepath, bool useFlatShade);

    Model(const std::vector<Vertex> &vertices, const std::vector<uint32_t> &indices);

    Model(Model &&rhs) noexcept;

    Model(const Model &) = delete;
    Model &operator=(const Model &) = delete;

    virtual ~Model();

    GLuint getVao() const;
    GLuint getBoundingBoxVao() const;
    size_t getVertexCount() const;
    size_t getFaceCount() const;
    BoundingBox getBoundingBox() const;

    void initGL();

    virtual void draw();

    virtual void drawBoundingBox();

    const std::vector<uint32_t> &getIndices() const
    {
        return _indices;
    }
    const std::vector<Vertex> &getVertices() const
    {
        return _vertices;
    }
    const Vertex &getVertex(int i) const
    {
        return _vertices[i];
    }
    
    bool hasUVs() const { return _hasUVs; }

public:
    Transform transform;

protected:
    // vertices of the table represented in model's own coordinate
    std::vector<Vertex> _vertices;
    std::vector<uint32_t> _indices;
    bool _hasUVs = false;

    // bounding box
    BoundingBox _boundingBox;

    // opengl objects
    GLuint _vao = 0;
    GLuint _vbo = 0;
    GLuint _ebo = 0;

    GLuint _boxVao = 0;
    GLuint _boxVbo = 0;
    GLuint _boxEbo = 0;

    bool _isUploaded = false;

    void computeBoundingBox();

    void initGLResources();

    void initBoxGLResources();

    void cleanup();
};
```

./engine/obj_loader.cpp:
```
#include "obj_loader.h"
#include "geometry_factory.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <unordered_map>

// 辅助函数：安全地将 OBJ 索引转换为 vector 下标
// 1. 处理正数索引 (1-based -> 0-based)
// 2. 处理负数索引 (相对位置 -> 绝对位置)
// 3. 边界检查
static int fixIndex(int idx, size_t size) {
    if (idx > 0) return idx - 1;             // 正数：1 -> 0
    if (idx < 0) return (int)size + idx;     // 负数：-1 -> size-1
    return -1;                               // 0 是无效索引
}

// 辅助函数：将 "1/2/3" 这种字符串分割成索引
// 返回 {posIndex, texIndex, normIndex}，如果某项缺失返回 -1
static glm::ivec3 parseFaceIndex(const std::string& token, size_t vSize, size_t vtSize, size_t vnSize) {
    glm::ivec3 result(-1);
    std::string part;
    std::stringstream ss(token);
    
    // 1. Position Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.x = fixIndex(rawIdx, vSize);
            } catch (...) { result.x = -1; }
        }
    }
    
    // 2. TexCoord Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.y = fixIndex(rawIdx, vtSize);
            } catch (...) { result.y = -1; }
        }
    }

    // 3. Normal Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.z = fixIndex(rawIdx, vnSize);
            } catch (...) { result.z = -1; }
        }
    }

    return result;
}

MeshData OBJLoader::load(const std::string& filepath, bool useFlatShade, const std::string& targetSubMeshName) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        // 抛出异常供 Model 捕获，或者打印错误并返回空数据
        throw std::runtime_error("[OBJ Loader] Failed to open OBJ file: " + filepath);
    }

    // 临时存储原始数据
    std::vector<glm::vec3> temp_positions;
    std::vector<glm::vec3> temp_normals;
    std::vector<glm::vec2> temp_texCoords;

    MeshData meshData; // 最终返回的数据

    // 顶点去重 Map
    std::unordered_map<Vertex, uint32_t> uniqueVertices;

    std::string currentObjectName = "Object";
    std::string currentMaterialName = "Default";
    // 组合名称，用于匹配 importScene 时的命名逻辑
    // 逻辑：如果 targetSubMeshName 不为空，我们只在匹配时收集面
    bool capturesAll = targetSubMeshName.empty();
    bool isCapturing = capturesAll; // 默认状态

    std::string line;
    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '#') continue;

        std::stringstream ss(line);
        std::string type;
        ss >> type;

        if (type == "v") {
            glm::vec3 v;
            ss >> v.x >> v.y >> v.z;
            temp_positions.push_back(v);
        }
        else if (type == "vn") {
            glm::vec3 vn;
            ss >> vn.x >> vn.y >> vn.z;
            temp_normals.push_back(vn);
        }
        else if (type == "vt") {
            glm::vec2 vt;
            ss >> vt.x >> vt.y;
            meshData.hasUVs = true; // 注意：这里标记可能有误，如果只加载部分物体且该物体无UV，但全局有UV。不过通常无伤大雅。
            temp_texCoords.push_back(vt);
        }

        else if (type == "o" || type == "g") {
            if (!capturesAll) {
                std::string name;
                std::getline(ss, name);
                // Trim
                size_t first = name.find_first_not_of(" \t\r");
                size_t last = name.find_last_not_of(" \t\r");
                if (first != std::string::npos && last != std::string::npos) 
                    currentObjectName = name.substr(first, last - first + 1);
                else currentObjectName = "Object"; // Fallback

                currentMaterialName = "Default"; // 重置材质名

                // 检查是否匹配目标 (匹配 Object Name)
                if (currentObjectName == targetSubMeshName) isCapturing = true;
                else isCapturing = false;
            }
        }
        else if (type == "usemtl") {
            if (!capturesAll) {
                ss >> currentMaterialName;
                
                // 检查是否匹配目标 (匹配 组合名称 "Object_Mat")
                // 这必须和 importScene 里的命名逻辑完全一致
                std::string combinedName = currentObjectName + "_" + currentMaterialName;
                
                if (currentObjectName == targetSubMeshName || combinedName == targetSubMeshName) {
                    isCapturing = true;
                } else {
                    isCapturing = false;
                }
            }
        }

        else if (type == "f") {
            if (!isCapturing) continue;

            std::string token;
            std::vector<Vertex> faceVertices;

            // 读取面数据
            while (ss >> token) {
                glm::ivec3 indices = parseFaceIndex(token, temp_positions.size(), temp_texCoords.size(), temp_normals.size());
                Vertex currentVertex;
                
                // Position
                if (indices.x >= 0 && indices.x < temp_positions.size())
                    currentVertex.position = temp_positions[indices.x];
                else
                    continue;

                // TexCoord
                if (indices.y >= 0 && indices.y < temp_texCoords.size())
                    currentVertex.texCoord = temp_texCoords[indices.y];
                else
                    currentVertex.texCoord = glm::vec2(0.0f);

                // Normal
                if (indices.z >= 0 && indices.z < temp_normals.size())
                    currentVertex.normal = temp_normals[indices.z];
                else
                    currentVertex.normal = glm::vec3(0.0f);

                faceVertices.push_back(currentVertex);
            }

            // 三角化 (Triangle Fan)
            // 将多边形分解为三角形
            if (faceVertices.size() >= 3) {
                for (size_t i = 1; i < faceVertices.size() - 1; ++i) {
                    Vertex triVerts[3] = {faceVertices[0], faceVertices[i], faceVertices[i+1]};

                    if (useFlatShade)
                    {
                        // 1. 强制计算面法线 (忽略 OBJ 文件自带的法线)
                        glm::vec3 edge1 = triVerts[1].position - triVerts[0].position;
                        glm::vec3 edge2 = triVerts[2].position - triVerts[0].position;
                        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

                        // 2. 将三个顶点直接加入，不做去重
                        for (int k = 0; k < 3; ++k) {
                            triVerts[k].normal = faceNormal; // 覆盖法线
                            
                            // 直接 push，不查 map
                            meshData.indices.push_back(static_cast<uint32_t>(meshData.vertices.size()));
                            meshData.vertices.push_back(triVerts[k]);
                        }
                    }
                    else
                    {
                        for (int k = 0; k < 3; ++k) {
                            if (uniqueVertices.count(triVerts[k]) == 0) {
                                uniqueVertices[triVerts[k]] = static_cast<uint32_t>(meshData.vertices.size());
                                meshData.vertices.push_back(triVerts[k]);
                            }
                            meshData.indices.push_back(uniqueVertices[triVerts[k]]);
                        }
                    }
                }
            }
        }
    }

    // 自动计算法线（如果 OBJ 文件里完全没有法线信息）
    if (!useFlatShade && temp_normals.empty()) {
        for (size_t i = 0; i < meshData.indices.size(); i += 3) {
            Vertex& v0 = meshData.vertices[meshData.indices[i]];
            Vertex& v1 = meshData.vertices[meshData.indices[i+1]];
            Vertex& v2 = meshData.vertices[meshData.indices[i+2]];

            glm::vec3 edge1 = v1.position - v0.position;
            glm::vec3 edge2 = v2.position - v0.position;
            glm::vec3 normal = glm::normalize(glm::cross(edge1, edge2));

            v0.normal = normal;
            v1.normal = normal;
            v2.normal = normal;
        }
    }

    // 既然我们已经有了 meshData (vertices/indices)，直接借用 GeometryFactory 的算法
    // 需要 include "geometry_factory.h"
    GeometryFactory::computeTangents(meshData.vertices, meshData.indices);

    std::cout << "Loaded OBJ: " << filepath << "\n" 
              << "  Vertices: " << meshData.vertices.size() << "\n" 
              << "  Indices: " << meshData.indices.size() << std::endl;
    
    if (!capturesAll && meshData.vertices.empty()) {
        std::cerr << "[OBJ Loader] Warning: SubMesh '" << targetSubMeshName << "' not found in " << filepath << std::endl;
    }

    return meshData;
}

std::vector<SubMesh> OBJLoader::loadScene(const std::string& filepath, bool useFlatShade) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        throw std::runtime_error("[OBJ Loader] Failed to open OBJ file for scene: " + filepath);
    }

    std::vector<SubMesh> meshes;
    
    // 全局数据池 (v, vn, vt 是跨物体共享索引的)
    std::vector<glm::vec3> global_positions;
    std::vector<glm::vec3> global_normals;
    std::vector<glm::vec2> global_texCoords;

    // 当前正在构建的 SubMesh
    SubMesh currentMesh;
    currentMesh.name = "Default";
    currentMesh.hasUVs = false;

    // 当前 SubMesh 的顶点去重 Map
    std::unordered_map<Vertex, uint32_t> uniqueVertices;

    std::string currentObjectName = "Object";
    std::string currentMaterialName = "DefaultMat";

    // 辅助 lambda：用于在切换物体或结束时保存当前 Mesh
    auto flushCurrentMesh = [&]() {
        if (!currentMesh.indices.empty()) {
            
            // 如果需要自动计算法线 (Smooth 且源文件没法线)
            if (!useFlatShade && global_normals.empty()) {
                 for (size_t i = 0; i < currentMesh.indices.size(); i += 3) {
                    Vertex& v0 = currentMesh.vertices[currentMesh.indices[i]];
                    Vertex& v1 = currentMesh.vertices[currentMesh.indices[i+1]];
                    Vertex& v2 = currentMesh.vertices[currentMesh.indices[i+2]];
                    glm::vec3 edge1 = v1.position - v0.position;
                    glm::vec3 edge2 = v2.position - v0.position;
                    glm::vec3 normal = glm::normalize(glm::cross(edge1, edge2));
                    v0.normal = normal; v1.normal = normal; v2.normal = normal;
                }
            }
            meshes.push_back(currentMesh);
        }
        
        // 重置状态
        currentMesh = SubMesh();
        uniqueVertices.clear();
        currentMesh.hasUVs = false; 
    };

    std::string line;
    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '#') continue;

        std::stringstream ss(line);
        std::string type;
        ss >> type;

        // --- 读取全局数据 ---
        if (type == "v") {
            glm::vec3 v; ss >> v.x >> v.y >> v.z;
            global_positions.push_back(v);
        }
        else if (type == "vn") {
            glm::vec3 vn; ss >> vn.x >> vn.y >> vn.z;
            global_normals.push_back(vn);
        }
        else if (type == "vt") {
            glm::vec2 vt; ss >> vt.x >> vt.y;
            global_texCoords.push_back(vt);
        }

        // --- 切换物体 (o/g) 或 材质 (usemtl) ---
        else if (type == "o" || type == "g") {
            std::string name;
            std::getline(ss, name);
            // Trim
            size_t first = name.find_first_not_of(" \t\r");
            size_t last = name.find_last_not_of(" \t\r");
            if (first != std::string::npos && last != std::string::npos) 
                name = name.substr(first, last - first + 1);
            else name = "Object_" + std::to_string(meshes.size());

            // 只有当名字真的变了，才切分 (防止 o 和 g 连着写导致生成空 mesh)
            if (name != currentObjectName) {
                flushCurrentMesh();
                currentObjectName = name;
                // 重置材质名，因为新物体可能还没定义 usemtl
                currentMaterialName = "Default"; 
                currentMesh.name = currentObjectName;
            }
        }
        else if (type == "usemtl") {
            std::string matName;
            ss >> matName;
            
            // 如果材质变了，必须切分 Mesh！
            // 因为我们的 MeshComponent 只能承载一个材质
            if (matName != currentMaterialName) {
                flushCurrentMesh();
                currentMaterialName = matName;
                // 新 Mesh 的名字组合：物体名_材质名
                // 这样你在 Hierarchy 里能看到 "Chair_Wood" 和 "Chair_Fabric"
                currentMesh.name = currentObjectName + "_" + currentMaterialName;
            }
        }

        // --- 读取面 (f) ---
        else if (type == "f") {
            std::string token;
            std::vector<Vertex> faceVertices;

            while (ss >> token) {
                // 注意：这里传入的是当前全局池的大小
                glm::ivec3 indices = parseFaceIndex(token, global_positions.size(), global_texCoords.size(), global_normals.size());
                Vertex currentVertex;

                // 1. Position
                if (indices.x >= 0 && indices.x < global_positions.size())
                    currentVertex.position = global_positions[indices.x];
                else continue;

                // 2. TexCoord
                if (indices.y >= 0 && indices.y < global_texCoords.size()) {
                    currentVertex.texCoord = global_texCoords[indices.y];
                    currentMesh.hasUVs = true; // 只要用到了 UV 索引，就标记有 UV
                } else {
                    currentVertex.texCoord = glm::vec2(0.0f);
                }

                // 3. Normal
                if (indices.z >= 0 && indices.z < global_normals.size())
                    currentVertex.normal = global_normals[indices.z];
                else 
                    currentVertex.normal = glm::vec3(0.0f);

                faceVertices.push_back(currentVertex);
            }

            // 三角化
            if (faceVertices.size() >= 3) {
                for (size_t i = 1; i < faceVertices.size() - 1; ++i) {
                    Vertex triVerts[3] = {faceVertices[0], faceVertices[i], faceVertices[i+1]};

                    if (useFlatShade) {
                        // Flat Shading 逻辑：分裂顶点，重算法线
                        glm::vec3 edge1 = triVerts[1].position - triVerts[0].position;
                        glm::vec3 edge2 = triVerts[2].position - triVerts[0].position;
                        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

                        for (int k = 0; k < 3; ++k) {
                            triVerts[k].normal = faceNormal;
                            currentMesh.indices.push_back(static_cast<uint32_t>(currentMesh.vertices.size()));
                            currentMesh.vertices.push_back(triVerts[k]);
                        }
                    } 
                    else {
                        // Smooth Shading 逻辑：使用 Map 去重
                        for (int k = 0; k < 3; ++k) {
                            if (uniqueVertices.count(triVerts[k]) == 0) {
                                uniqueVertices[triVerts[k]] = static_cast<uint32_t>(currentMesh.vertices.size());
                                currentMesh.vertices.push_back(triVerts[k]);
                            }
                            currentMesh.indices.push_back(uniqueVertices[triVerts[k]]);
                        }
                    }
                }
            }
        }
    }

    // 循环结束，保存最后一个物体
    flushCurrentMesh();

    std::cout << "Loaded Scene OBJ: " << filepath << " containing " << meshes.size() << " meshes." << std::endl;
    return meshes;
}
```

./engine/obj_loader.h:
```
#pragma once

#include <string>
#include <vector>
#include "base/vertex.h"

// 定义一个中间结构体，用于在 Loader 和 Model 之间传递数据
struct MeshData {
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    bool hasUVs = false;
};

struct SubMesh {
    std::string name;
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    bool hasUVs = false;
};

class OBJLoader {
public:
    // 修改返回类型为 MeshData
    // 如果加载失败，选择抛出异常，或者返回空的 MeshData（根据你的错误处理策略）
    static MeshData load(const std::string& filepath, bool useFlatShade = false, const std::string& targetSubMeshName = "");

    // 场景加载 (返回多个子网格)
    static std::vector<SubMesh> loadScene(const std::string& filepath, bool useSplitVert = false);
};
```

./engine/outline_pass.cpp:
```
#include "outline_pass.h"
#include <vector>

OutlinePass::OutlinePass(int width, int height)
    : _screenWidth(width), _screenHeight(height)
{
    initShaders();
    initQuad();
    initFrameBuffer();
}

OutlinePass::~OutlinePass()
{
    if (_fbo)
        glDeleteFramebuffers(1, &_fbo);
    if (_maskTexture)
        glDeleteTextures(1, &_maskTexture);
    // if (_depthRenderBuffer)
    //     glDeleteRenderbuffers(1, &_depthRenderBuffer);
    // [新增] 释放 MSAA 资源
    if (_msaaFbo)
        glDeleteFramebuffers(1, &_msaaFbo);
    if (_msaaColorBuffer)
        glDeleteRenderbuffers(1, &_msaaColorBuffer);
    if (_msaaDepthBuffer)
        glDeleteRenderbuffers(1, &_msaaDepthBuffer);
    if (_quadVAO)
        glDeleteVertexArrays(1, &_quadVAO);
    if (_quadVBO)
        glDeleteBuffers(1, &_quadVBO);
}

void OutlinePass::onResize(int width, int height)
{
    _screenWidth = width;
    _screenHeight = height;
    // 重新生成 FBO (简单粗暴的方法是删了重建)
    if (_fbo)
        glDeleteFramebuffers(1, &_fbo);
    if (_maskTexture)
        glDeleteTextures(1, &_maskTexture);
    // if (_depthRenderBuffer)
    //     glDeleteRenderbuffers(1, &_depthRenderBuffer);
    // [新增]
    if (_msaaFbo)
        glDeleteFramebuffers(1, &_msaaFbo);
    if (_msaaColorBuffer)
        glDeleteRenderbuffers(1, &_msaaColorBuffer);
    if (_msaaDepthBuffer)
        glDeleteRenderbuffers(1, &_msaaDepthBuffer);
    
    initFrameBuffer();
}

void OutlinePass::initFrameBuffer()
{
    GLint maxSamples;
    glGetIntegerv(GL_MAX_SAMPLES, &maxSamples);
    int samples = std::min(4, maxSamples); // 尝试用 4，如果不支持则用最大值

    // ==========================================
    // 1. 创建 MSAA FBO (渲染目标)
    // ==========================================
    glGenFramebuffers(1, &_msaaFbo);
    glBindFramebuffer(GL_FRAMEBUFFER, _msaaFbo);

    // 创建多重采样颜色缓冲 (4 samples)
    glGenRenderbuffers(1, &_msaaColorBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _msaaColorBuffer);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, samples, GL_R8, _screenWidth, _screenHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _msaaColorBuffer);

    // 创建多重采样深度缓冲 (必须匹配)
    glGenRenderbuffers(1, &_msaaDepthBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _msaaDepthBuffer);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, samples, GL_DEPTH_COMPONENT24, _screenWidth, _screenHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _msaaDepthBuffer);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: MSAA Framebuffer is not complete!" << std::endl;

    // ==========================================
    // 2. 创建 Resolve FBO (读取目标 - 普通纹理)
    // ==========================================
    glGenFramebuffers(1, &_fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);

    // 创建普通单通道纹理 (GL_LINEAR 很重要)
    glGenTextures(1, &_maskTexture);
    glBindTexture(GL_TEXTURE_2D, _maskTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, _screenWidth, _screenHeight, 0, GL_RED, GL_FLOAT, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); // 线性过滤
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _maskTexture, 0);

    // 这个 FBO 不需要深度缓冲，因为我们只是要把 MSAA 的颜色 Blit 过来

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: Resolve Framebuffer is not complete!" << std::endl;

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void OutlinePass::initQuad()
{
    // 标准的覆盖全屏的 NDC 坐标
    float quadVertices[] = {
        // positions   // texCoords
        -1.0f, 1.0f, 0.0f, 1.0f,
        -1.0f, -1.0f, 0.0f, 0.0f,
        1.0f, -1.0f, 1.0f, 0.0f,

        -1.0f, 1.0f, 0.0f, 1.0f,
        1.0f, -1.0f, 1.0f, 0.0f,
        1.0f, 1.0f, 1.0f, 1.0f};
    glGenVertexArrays(1, &_quadVAO);
    glGenBuffers(1, &_quadVBO);
    glBindVertexArray(_quadVAO);
    glBindBuffer(GL_ARRAY_BUFFER, _quadVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *)(2 * sizeof(float)));
}

void OutlinePass::initShaders()
{
    // 1. Mask Shader: 将物体渲染为纯白色
    const char *maskVs = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;
        void main() {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    )";
    const char *maskFs = R"(
        #version 330 core
        out vec4 FragColor; // 只写 GL_RED
        void main() {
            FragColor = vec4(1.0, 0.0, 0.0, 1.0); // R=1
        }
    )";
    _maskShader.reset(new GLSLProgram);
    _maskShader->attachVertexShader(maskVs);
    _maskShader->attachFragmentShader(maskFs);
    _maskShader->link();

    // 2. Post Shader: 边缘检测
    const char *postVs = R"(
        #version 330 core
        layout (location = 0) in vec2 aPos;
        layout (location = 1) in vec2 aTexCoords;
        out vec2 TexCoords;
        void main() {
            gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            TexCoords = aTexCoords;
        }
    )";

    const char *postFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec2 TexCoords;

        uniform sampler2D maskTexture;
        uniform float outlineWidth; 
        uniform vec3 outlineColor; 

        void main() {
            vec2 texSize = textureSize(maskTexture, 0);
            vec2 px = 1.0 / texSize; 
            
            // 采样中心
            float center = texture(maskTexture, TexCoords).r;

            // [修复 1] 移除硬 Discard，改用透明度控制内边缘
            // 原代码: if (center > 0.8) discard; (导致内圈锯齿)
            // 新逻辑: 如果 center 很白(物体内部)，我们让 alpha 变 0；
            // 如果 center 是灰色(物体抗锯齿边缘)，我们让 alpha 慢慢变 0。
            // 这样轮廓线会平滑地“隐入”物体后面。
            float innerAlpha = 1.0 - smoothstep(0.5, 0.9, center);

            // 提前优化：如果完全在物体内部，就不需要做昂贵的搜索了
            if (innerAlpha <= 0.0) discard;

            // 2. 暴力搜索 + [修复 2] 亚像素精度补偿
            int radius = int(ceil(outlineWidth));
            float minDistance = 1000.0; 

            for (int x = -radius; x <= radius; x++) {
                for (int y = -radius; y <= radius; y++) {
                    
                    vec2 offset = vec2(x, y) * px;
                    float neighbor = texture(maskTexture, TexCoords + offset).r;

                    // 只要邻居不是全黑
                    if (neighbor > 0.01) {
                        float dist = length(vec2(x, y));

                        // [核心黑科技] 亚像素距离补偿
                        // 如果 neighbor 是 1.0 (全白)，说明边界在这个像素的更外侧，实际距离更近，减去 0.5
                        // 如果 neighbor 是 0.1 (很淡)，说明边界在这个像素的内侧，实际距离更远
                        // 公式：修正后的距离 = 像素中心距离 - (亮度 - 0.5)
                        // 这样生成的距离场会非常平滑，不再受像素网格限制
                        float subPixelCorrection = neighbor - 0.5;
                        dist -= subPixelCorrection;

                        minDistance = min(minDistance, dist);
                    }
                }
            }

            // 3. 渲染逻辑
            if (minDistance > outlineWidth) discard;

            // 4. 外边缘抗锯齿 (保持不变，这部分逻辑是对的)
            float outerAlpha = 1.0 - smoothstep(outlineWidth - 1.0, outlineWidth, minDistance);
            
            // 5. 最终 Alpha = 外边缘衰减 * 内边缘遮罩
            float finalAlpha = outerAlpha * innerAlpha;

            // 提升一点实心感 (Gamma校正)
            finalAlpha = pow(finalAlpha, 0.5);

            if (finalAlpha > 0.01) {
                FragColor = vec4(outlineColor, finalAlpha);
            } else {
                discard;
            }
        }
    )";
    _postShader.reset(new GLSLProgram);
    _postShader->attachVertexShader(postVs);
    _postShader->attachFragmentShader(postFs);
    _postShader->link();
}

void OutlinePass::render(GameObject *targetObj, Camera *camera, float contentScale, int width, int height)
{
    if (!targetObj)
        return;
    
    // [新增] 1. 保存进入函数时绑定的 FBO (即 _sceneFbo)
    GLint prevFbo;
    glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &prevFbo);

    if (width != _screenWidth || height != _screenHeight)
    {
        // 调用你现有的 onResize 函数重建 FBO
        onResize(width, height);
        
        // 注意：onResize 里已经更新了 _screenWidth 和 _screenHeight，
        // 所以下一帧不会重复进入这里。
    }

    GLint prevViewport[4];
    glGetIntegerv(GL_VIEWPORT, prevViewport);

    // ===========================================
    // Pass 1: 渲染到 MSAA FBO (生成高精度 Mask)
    // ===========================================
    glBindFramebuffer(GL_FRAMEBUFFER, _msaaFbo); // <--- 改为绑定 MSAA FBO
    glViewport(0, 0, _screenWidth, _screenHeight);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    _maskShader->use();
    _maskShader->setUniformMat4("view", camera->getViewMatrix());
    _maskShader->setUniformMat4("projection", camera->getProjectionMatrix());

    // 遍历该物体的所有 Mesh 组件进行渲染
    for (const auto &comp : targetObj->components)
    {
        if (comp->getType() == ComponentType::MeshRenderer)
        {
            auto mesh = static_cast<MeshComponent *>(comp.get());
            if (!mesh->enabled)
                continue;
            // Gizmo 通常不画外框，跳过
            // if (mesh->isGizmo)
            //     continue;

            // 计算矩阵
            glm::mat4 modelMatrix = targetObj->transform.getLocalMatrix();
            modelMatrix = modelMatrix * mesh->model->transform.getLocalMatrix();
            _maskShader->setUniformMat4("model", modelMatrix);

			if (mesh->doubleSided) {
                glDisable(GL_CULL_FACE); // 允许绘制背面到 Mask
            }
            mesh->model->draw();
            if (mesh->doubleSided) {
                glEnable(GL_CULL_FACE); // 恢复背面剔除
            }
        }
    }

    // ===========================================
    // Pass 1.5: 将 MSAA Resolve 到普通纹理
    // ===========================================
    glBindFramebuffer(GL_READ_FRAMEBUFFER, _msaaFbo); // 源：MSAA
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, _fbo);     // 目标：Texture
    
    // 执行 Blit：硬件会自动混合 4 个采样点，生成平滑的边缘 (抗锯齿)
    glBlitFramebuffer(0, 0, _screenWidth, _screenHeight, 
                      0, 0, _screenWidth, _screenHeight, 
                      GL_COLOR_BUFFER_BIT, GL_NEAREST);

    // ===========================================
    // Pass 2: 边缘检测并叠加 (渲染到屏幕)
    // ===========================================
    // [修改] 2. 恢复之前保存的 FBO，而不是绑定 0
    glBindFramebuffer(GL_FRAMEBUFFER, prevFbo);

    glViewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);

    // 重要：我们需要在现有的画面上“叠加”外框，而不是覆盖
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_DEPTH_TEST); // 后处理是一个 2D 贴图，不需要深度测试

    _postShader->use();
    _postShader->setUniformVec3("outlineColor", glm::vec3(1.0, 0.6, 0.0)); // 橙色
    _postShader->setUniformFloat("outlineWidth", 3.0f * contentScale);     // 线宽 3

    glBindVertexArray(_quadVAO);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, _maskTexture); // 绑定刚才生成的黑白图
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glBindVertexArray(0);

    // 恢复状态
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
}
```

./engine/outline_pass.h:
```
#pragma once

#include <glad/gl.h>
#include <vector>
#include <memory>
#include <iostream>

#include "base/glsl_program.h"
#include "base/camera.h"
#include "engine/model.h"
#include "scene_object.h" // 为了访问 GameObject

class OutlinePass
{
public:
    OutlinePass(int screenWidth, int screenHeight);
    ~OutlinePass();

    // 当窗口大小改变时调用
    void onResize(int width, int height);

    // 核心渲染函数
    // 1. targetObj: 当前选中的物体
    // 2. camera: 当前相机 (需要视图和投影矩阵)
    void render(GameObject *targetObj, Camera *camera, float contentScale, int width, int height);

private:
    int _screenWidth, _screenHeight;

    // FBO 相关
    GLuint _fbo = 0;
    GLuint _maskTexture = 0;       // 存储黑白遮罩
    // GLuint _depthRenderBuffer = 0; // 深度缓冲 (即使是遮罩也需要深度测试来保证遮挡关系正确吗？通常做Outline时，我们希望Outline被前面的物体遮挡，所以需要深度)

    // [新增] MSAA FBO (用于渲染 Mask)
    GLuint _msaaFbo = 0;
    GLuint _msaaColorBuffer = 0; // 使用 RenderBuffer 而不是 Texture，因为不需要采样
    GLuint _msaaDepthBuffer = 0; // MSAA 深度缓冲

    // 全屏矩形资源
    GLuint _quadVAO = 0;
    GLuint _quadVBO = 0;

    // Shaders
    std::unique_ptr<GLSLProgram> _maskShader; // 用于把物体画成纯白
    std::unique_ptr<GLSLProgram> _postShader; // 用于边缘检测和混合

    void initFrameBuffer();
    void initQuad();
    void initShaders();
};
```

./engine/physics_utils.h:
```
#pragma once

#include <glm/glm.hpp>
#include <algorithm>
#include <limits>
#include "base/vertex.h"
#include "base/bounding_box.h" // 你的 base 里应该有这个，如果没有请看 Model 类里的定义

struct Ray
{
    glm::vec3 origin;
    glm::vec3 direction;

    Ray(const glm::vec3 &o, const glm::vec3 &d) : origin(o), direction(d) {}
};

class PhysicsUtils
{
public:
    // 射线与 AABB (轴对齐包围盒) 的相交检测
    // 算法：Slab Method
    // 输入：射线 (ray)，包围盒 (box)
    // 输出：是否相交，如果相交，tMin 返回交点距离
    static bool intersectRayAABB(const Ray &ray, const BoundingBox &box, float &tMinResult)
    {
        // 防止射线方向为 0 导致的除零异常
        if (glm::length(ray.direction) < 1e-6f) return false;

        float tMin = 0.0f;
        float tMax = std::numeric_limits<float>::max();

        glm::vec3 boxMin = box.min;
        glm::vec3 boxMax = box.max;

        // 对 X, Y, Z 三个轴分别进行检测
        for (int i = 0; i < 3; i++)
        {
            float invD = 1.0f / ray.direction[i];
            float t0 = (boxMin[i] - ray.origin[i]) * invD;
            float t1 = (boxMax[i] - ray.origin[i]) * invD;

            if (invD < 0.0f)
                std::swap(t0, t1);

            tMin = std::max(tMin, t0);
            tMax = std::min(tMax, t1);

            if (tMax <= tMin)
                return false;
        }

        tMinResult = tMin;
        return true;
    }

    // Ray-Triangle (Möller–Trumbore) - 精测
    static bool intersectRayTriangle(const Ray& ray, const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2, float& outT)
    {
        const float EPSILON = 0.0000001f;
        glm::vec3 edge1 = v1 - v0;
        glm::vec3 edge2 = v2 - v0;
        glm::vec3 h = glm::cross(ray.direction, edge2);
        float a = glm::dot(edge1, h);

        // 如果 a 接近 0，说明射线平行于三角形
        if (a > -EPSILON && a < EPSILON)
            return false;

        float f = 1.0f / a;
        glm::vec3 s = ray.origin - v0;
        float u = f * glm::dot(s, h);

        if (u < 0.0f || u > 1.0f)
            return false;

        glm::vec3 q = glm::cross(s, edge1);
        float v = f * glm::dot(ray.direction, q);

        if (v < 0.0f || u + v > 1.0f)
            return false;

        // 计算 t
        float t = f * glm::dot(edge2, q);

        if (t > EPSILON) // 射线相交
        {
            outT = t;
            return true;
        }
        return false;
    }

    // ==========================================
    // 3. Ray-Mesh - 遍历所有三角形
    // ==========================================
    // 输入：局部空间的射线、顶点列表、索引列表
    // 输出：是否击中，tMin 返回最近的距离
    static bool intersectRayMesh(const Ray& localRay, 
                                 const std::vector<Vertex>& vertices, 
                                 const std::vector<uint32_t>& indices, 
                                 float& tMin)
    {
        bool hit = false;
        float closestT = std::numeric_limits<float>::max();

        // 遍历所有三角形 (每次步进 3)
        for (size_t i = 0; i < indices.size(); i += 3)
        {
            const glm::vec3& v0 = vertices[indices[i]].position;
            const glm::vec3& v1 = vertices[indices[i+1]].position;
            const glm::vec3& v2 = vertices[indices[i+2]].position;

            float t = 0.0f;
            if (intersectRayTriangle(localRay, v0, v1, v2, t))
            {
                if (t < closestT)
                {
                    closestT = t;
                    hit = true;
                }
            }
        }

        if (hit)
        {
            tMin = closestT;
            return true;
        }
        return false;
    }
};
```

./engine/point_shadow_pass.cpp:
```
#include "point_shadow_pass.h"
#include <iostream>
#include <glm/gtc/matrix_transform.hpp>

PointShadowPass::PointShadowPass(int resolution, int maxLights)
    : _resolution(resolution), _maxLights(maxLights)
{
    initShader();
    initResources();
}

PointShadowPass::~PointShadowPass()
{
    for (const auto& buf : _shadowBuffers) {
        if (buf.fbo) glDeleteFramebuffers(1, &buf.fbo);
        if (buf.texture) glDeleteTextures(1, &buf.texture);
    }
}

void PointShadowPass::initResources()
{
    _shadowBuffers.resize(_maxLights);

    for (int i = 0; i < _maxLights; ++i) {
        // 1. 创建 Cubemap
        glGenTextures(1, &_shadowBuffers[i].texture);
        glBindTexture(GL_TEXTURE_CUBE_MAP, _shadowBuffers[i].texture);

        for (unsigned int face = 0; face < 6; ++face) {
            // 使用 GL_FLOAT 存储线性深度
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, GL_DEPTH_COMPONENT24, 
                         _resolution, _resolution, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
        }

        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

        // 2. 创建 FBO
        glGenFramebuffers(1, &_shadowBuffers[i].fbo);
        glBindFramebuffer(GL_FRAMEBUFFER, _shadowBuffers[i].fbo);
        
        // 将 Cubemap 绑定为 Depth Attachment
        // 注意：如果是颜色纹理，通常需要用 Geometry Shader 动态分发
        // 但对于深度纹理，glFramebufferTexture 允许我们将整个 Cubemap 绑上去
        // 并在 Geometry Shader 中通过 gl_Layer 控制写入哪一面
        glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _shadowBuffers[i].texture, 0);
        
        // 不需要颜色缓冲
        glDrawBuffer(GL_NONE);
        glReadBuffer(GL_NONE);

        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
            std::cout << "ERROR::PointShadowFBO[" << i << "]:: Framebuffer is not complete!" << std::endl;
            
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
    }
}

void PointShadowPass::initShader()
{
    // Vertex Shader: 转到世界空间
    const char* vsCode = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        uniform mat4 model;
        void main() {
            gl_Position = model * vec4(aPos, 1.0);
        }
    )";

    // [核心] Geometry Shader: 一次生成 6 个面
    const char* gsCode = R"(
        #version 330 core
        layout (triangles) in;
        layout (triangle_strip, max_vertices=18) out;

        uniform mat4 shadowMatrices[6]; // 6个方向的 ViewProj 矩阵

        out vec4 FragPos; // 传递给 FS 计算距离

        void main() {
            for(int face = 0; face < 6; ++face) {
                gl_Layer = face; // 指定输出到 Cubemap 的哪个面
                for(int i = 0; i < 3; ++i) {
                    FragPos = gl_in[i].gl_Position;
                    gl_Position = shadowMatrices[face] * FragPos;
                    EmitVertex();
                }
                EndPrimitive();
            }
        }
    )";

    // Fragment Shader: 写入线性深度
    const char* fsCode = R"(
        #version 330 core
        in vec4 FragPos;

        uniform vec3 lightPos;
        uniform float farPlane;

        void main() {
            float lightDistance = length(FragPos.xyz - lightPos);
            
            // 映射到 [0, 1] 范围
            lightDistance = lightDistance / farPlane;
            
            // 手动写入深度 (修改 gl_FragDepth)
            gl_FragDepth = lightDistance;
        }
    )";

    _shader.reset(new GLSLProgram);
    _shader->attachVertexShader(vsCode);
    _shader->attachGeometryShader(gsCode); // 别忘了这个
    _shader->attachFragmentShader(fsCode);
    _shader->link();
}

void PointShadowPass::render(const Scene& scene, const std::vector<PointShadowInfo>& lightInfos)
{
    _shader->use();
    
    // 渲染尺寸
    glViewport(0, 0, _resolution, _resolution);
    
    // 遍历每一个需要投射阴影的光源
    for (const auto& info : lightInfos)
    {
        if (info.lightIndex >= _maxLights) continue;

        // 1. 绑定对应的 FBO
        glBindFramebuffer(GL_FRAMEBUFFER, _shadowBuffers[info.lightIndex].fbo);
        glClear(GL_DEPTH_BUFFER_BIT);

        // 2. 准备 6 个方向的矩阵
        // 投影矩阵：90度 FOV，宽高比 1.0
        glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, info.farPlane);
        
        std::vector<glm::mat4> shadowTransforms;
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3( 1.0,  0.0,  0.0), glm::vec3(0.0, -1.0,  0.0)));
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3(-1.0,  0.0,  0.0), glm::vec3(0.0, -1.0,  0.0)));
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3( 0.0,  1.0,  0.0), glm::vec3(0.0,  0.0,  1.0)));
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3( 0.0, -1.0,  0.0), glm::vec3(0.0,  0.0, -1.0)));
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3( 0.0,  0.0,  1.0), glm::vec3(0.0, -1.0,  0.0)));
        shadowTransforms.push_back(shadowProj * glm::lookAt(info.position, info.position + glm::vec3( 0.0,  0.0, -1.0), glm::vec3(0.0, -1.0,  0.0)));

        // 传递给 Shader
        for (int i = 0; i < 6; ++i) {
            _shader->setUniformMat4("shadowMatrices[" + std::to_string(i) + "]", shadowTransforms[i]);
        }
        _shader->setUniformFloat("farPlane", info.farPlane);
        _shader->setUniformVec3("lightPos", info.position);

        // 3. 绘制场景
        // 注意：这里我们简单地画所有物体。为了性能，可以做视锥剔除（但对于全向光源，剔除比较复杂）。
        for (const auto& go : scene.getGameObjects()) {
            auto meshComp = go->getComponent<MeshComponent>();
            if (!meshComp || !meshComp->enabled) continue;
            if (meshComp->isGizmo) continue; // Gizmo 不投射阴影

            // 这里不需要剔除背面，为了让阴影更准确（尤其是封闭物体），
            // 有时甚至可以剔除正面(GL_FRONT)来修复彼得潘现象，视具体效果而定。
            // 这里暂且不做特殊 Cull Face 设置，沿用默认或外部设置。
            
            glm::mat4 model = go->transform.getLocalMatrix();
            if (meshComp->model) {
                model = model * meshComp->model->transform.getLocalMatrix();
                _shader->setUniformMat4("model", model);
                meshComp->model->draw();
            }
        }
    }

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

GLuint PointShadowPass::getShadowMap(int index) const {
    if (index >= 0 && index < _shadowBuffers.size()) {
        return _shadowBuffers[index].texture;
    }
    return 0;
}
```

./engine/point_shadow_pass.h:
```
#pragma once

#include <glad/gl.h>
#include <memory>
#include <vector>
#include <glm/glm.hpp>

#include "base/glsl_program.h"
#include "scene.h"

// 用于传递单个点光源的渲染信息
struct PointShadowInfo {
    glm::vec3 position;
    float farPlane; // 点光源的视锥最远距离 (通常设为 25.0f 或更大)
    int lightIndex; // 对应 pointShadowMaps 数组的第几个槽位
};

class PointShadowPass
{
public:
    // resolution: Cubemap 的分辨率 (通常 1024)
    // maxLights: 最大支持的点光源阴影数量 (例如 4)
    PointShadowPass(int resolution = 1024, int maxLights = 4);
    ~PointShadowPass();

    // 核心渲染函数
    void render(const Scene& scene, const std::vector<PointShadowInfo>& lightInfos);

    // 获取某个槽位的 Cubemap ID
    GLuint getShadowMap(int index) const;
    
    // 获取最大支持数量
    int getMaxLights() const { return _maxLights; }

private:
    int _resolution;
    int _maxLights;

    // 每个光源对应一个 FBO 和一个 Cubemap
    struct ShadowFrameBuffer {
        GLuint fbo = 0;
        GLuint texture = 0; // Cubemap
    };
    std::vector<ShadowFrameBuffer> _shadowBuffers;

    std::unique_ptr<GLSLProgram> _shader;

    void initResources();
    void initShader();
};
```

./engine/renderer.cpp:
```
#include "renderer.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp>

Renderer::Renderer() {
    // 构造函数可以留空，把初始化放在 init() 里更安全
}

Renderer::~Renderer() {
    // unique_ptr 和 shared_ptr 会自动释放资源
}

void Renderer::init() {
    glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
    // 1. 初始化 Shader (从 SceneRoaming::initShader 搬运过来)
    // 请将 vsCode, fsCode, gridVs, gridFs, skyVs, skyFs 的定义和 link 逻辑放在这里
    // 例如：
    // _mainShader.reset(new GLSLProgram);
    // _mainShader->attachVertexShader(vsCode); ...
    
    // [注意] 这里你需要把 SceneRoaming.cpp 里那一大段 const char* shader code 复制过来
    // ... (省略几百行 Shader 代码) ...
    // 调用 initShader(); 
    // 顶点着色器 (Vertex Shader)
    const char *vsCode = R"(
        #version 330 core
        layout(location = 0) in vec3 aPosition;
        layout(location = 1) in vec3 aNormal;
        layout(location = 2) in vec2 aTexCoord;
        layout(location = 3) in vec3 aTangent;

        out vec3 FragPos;
        out vec3 Normal;
        out vec2 TexCoord;
        out mat3 TBN;

        out vec3 LocalPos;
        // 输出视空间深度 (或者直接用 gl_Position.w)
        out float ClipSpaceZ;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            vec4 worldPos = model * vec4(aPosition, 1.0);
            FragPos = vec3(worldPos);
            
            // 1. 计算 Normal Matrix (法线矩阵)
            // 它可以处理非均匀缩放，保证法线方向正确
            mat3 normalMatrix = mat3(transpose(inverse(model)));

            // 2. 计算世界空间法线 (N)
            vec3 N = normalize(normalMatrix * aNormal);
            Normal = N; // 将计算好的法线传给 FS (虽然 FS 可能有了 TBN 会重算，但保留它是个好习惯)
            
            // 3. 计算世界空间切线 (T)
            vec3 T = normalize(normalMatrix * aTangent);
            
            // 4. Gram-Schmidt 正交化
            // 这一步非常关键！它剔除 T 中包含的 N 分量，确保 T 绝对垂直于 N。
            // 这样可以防止因精度问题或模型数据不佳导致的 TBN 变形。
            T = normalize(T - dot(T, N) * N);
            
            // 5. 计算副切线 (Bitangent, B)
            // 利用叉乘生成第三个轴
            vec3 B = cross(N, T);
            
            // 6. 构建 TBN 矩阵
            TBN = mat3(T, B, N);

            TexCoord = aTexCoord;
            LocalPos = aPosition;
            
            gl_Position = projection * view * worldPos;
            
            // 保存 View Space 的深度
            ClipSpaceZ = gl_Position.w;
        }
    )";

    // 片元着色器 (Fragment Shader) - Blinn-Phong 多光源版本
    const char *fsCode = R"(
        #version 330 core
        #extension GL_ARB_shader_texture_lod : enable
        out vec4 FragColor;

        in vec3 FragPos;
        in vec3 Normal;
        in vec2 TexCoord;
        in vec3 LocalPos;
        in float ClipSpaceZ;
        in mat3 TBN;

        // 材质定义
        struct Material {
            vec3 albedo;
            float metallic;
            float roughness;
            float ao;

            float reflectivity;
            float refractionIndex;
            float transparency;
        };

        uniform Material material;

        // 纹理
        uniform sampler2D diffuseMap; 
        uniform bool hasDiffuseMap;
        uniform bool useTriplanar;
        uniform float triplanarScale;
        uniform vec3 triRotPos; // x,y,z 对应 +X,+Y,+Z 面的角度
        uniform vec3 triRotNeg; // x,y,z 对应 -X,-Y,-Z 面的角度
        uniform vec3 triFlipPos;
        uniform vec3 triFlipNeg;
        // 法线贴图
        uniform sampler2D normalMap;
        uniform bool hasNormalMap;
        uniform float normalStrength; // 默认 1.0
        uniform bool flipNormalY;     // 默认 false
        // ORM 贴图
        uniform sampler2D ormMap;
        uniform bool hasOrmMap;
        // 自发光贴图
        uniform sampler2D emissiveMap;
        uniform bool hasEmissiveMap;
        uniform vec3 emissiveColor;
        uniform float emissiveStrength;
        // 透明度贴图
        uniform sampler2D opacityMap;
        uniform bool hasOpacityMap;
        uniform float alphaCutoff;

        // 动态环境贴图 IBL
        uniform samplerCube envMap;
        uniform bool hasEnvMap;
        uniform float iblIntensity;

        // 视差校正
        uniform vec3 probePos;    // 探针拍摄时的中心位置 (世界坐标)
        uniform vec3 probeBoxMin; // 房间的最小边界 (世界坐标)
        uniform vec3 probeBoxMax; // 房间的最大边界 (世界坐标)

        // 用于在函数间传递 Triplanar 计算结果
        struct TriplanarData {
            vec2 uvX;
            vec2 uvY;
            vec2 uvZ;
            vec3 blend;
        };

        // 平行光定义
        struct DirLight {
            vec3 direction;
            vec3 color;
            float intensity;
            int shadowIndex; // -1 = 无阴影, >=0 = 纹理数组起始层级
        };

        // 点光源定义
        struct PointLight {
            vec3 position;
            float range;
            vec3 color;
            float intensity;
            int shadowIndex; // -1 = 无阴影, >=0 = 对应 pointShadowMaps 的下标
            float shadowStrength; // 阴影深浅
            float shadowRadius;   // 阴影软硬
            float shadowBias;
        };

        // 聚光灯定义
        struct SpotLight {
            vec3 position;
            vec3 direction;
            float cutOff;
            float outerCutOff;
            float range;
            vec3 color;
            float intensity;
        };

        // 定义最大光源数量常量
        #define NR_DIR_LIGHTS 4
        #define NR_POINT_LIGHTS 4
        #define NR_SPOT_LIGHTS 4
        
        // 最大支持的点光源阴影数
        #define NR_POINT_SHADOWS 4

        uniform bool isUnlit;
        uniform bool isDoubleSided;
        uniform bool isDebug;

        uniform vec3 viewPos;
        
        uniform DirLight dirLights[NR_DIR_LIGHTS];
        uniform int dirLightCount;

        uniform PointLight pointLights[NR_POINT_LIGHTS];
        uniform int pointLightCount;

        uniform SpotLight spotLights[NR_SPOT_LIGHTS];
        uniform int spotLightCount;

        // CSM (平行光) 阴影
        uniform sampler2DArrayShadow shadowMap; 
        // 假设最大 4 个灯 * 6 层级联 = 24 个矩阵
        // 为安全起见定义 32
        uniform mat4 lightSpaceMatrices[32];
        uniform float cascadePlaneDistances[16];
        uniform int cascadeCount;
        uniform float shadowBias;

        // 点光源阴影
        uniform samplerCube pointShadowMaps[NR_POINT_SHADOWS];
        uniform float pointShadowFarPlanes[NR_POINT_SHADOWS];

        const float PI = 3.14159265359;

        // 1. 法线分布函数 (NDF) - GGX Trowbridge-Reitz
        // 决定了高光的大小和形状 (Roughness 越小，光斑越集中)
        float DistributionGGX(vec3 N, vec3 H, float roughness)
        {
            float a = roughness * roughness;
            float a2 = a * a;
            float NdotH = max(dot(N, H), 0.0);
            float NdotH2 = NdotH * NdotH;

            float nom   = a2;
            float denom = (NdotH2 * (a2 - 1.0) + 1.0);
            denom = PI * denom * denom;

            return nom / max(denom, 0.0000001); // 防止除零
        }

        // 2. 几何遮蔽函数 (Geometry) - Schlick-GGX
        // 模拟粗糙表面的微观自遮挡 (Roughness 越大，越暗)
        float GeometrySchlickGGX(float NdotV, float roughness)
        {
            // 对于直接光照，k 取值如下：
            float r = (roughness + 1.0);
            float k = (r*r) / 8.0;

            float nom   = NdotV;
            float denom = NdotV * (1.0 - k) + k;

            return nom / max(denom, 0.0000001);
        }

        float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
        {
            float NdotV = max(dot(N, V), 0.0);
            float NdotL = max(dot(N, L), 0.0);
            float ggx2 = GeometrySchlickGGX(NdotV, roughness);
            float ggx1 = GeometrySchlickGGX(NdotL, roughness);

            return ggx1 * ggx2;
        }

        // 3. 菲涅尔方程 (Fresnel) - Schlick 近似
        // 决定了反射光和折射光(漫反射)的比例
        // F0: 基础反射率 (非金属0.04, 金属为 albedo)
        vec3 FresnelSchlick(float cosTheta, vec3 F0)
        {
            return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
        }

        // 4. 针对 IBL 的菲涅尔函数 (加入粗糙度影响)
        // 越粗糙的表面，边缘的菲涅尔反射越弱
        vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
        {
            return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
        }
        
        // 5. 统一的 PBR 计算核心
        // 输入：光方向L, 视线V, 法线N, 光照强度Radiance, 材质F0, 材质属性
        vec3 CalculatePBR_Lo(vec3 L, vec3 V, vec3 N, vec3 radiance, vec3 F0, vec3 albedo, float roughness, float metallic)
        {
            vec3 H = normalize(V + L); // 半程向量

            // Cook-Torrance BRDF
            float NDF = DistributionGGX(N, H, roughness);   
            float G   = GeometrySmith(N, V, L, roughness);      
            vec3 F    = FresnelSchlick(max(dot(H, V), 0.0), F0);
           
            vec3 numerator    = NDF * G * F; 
            float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001; // +0.0001 防止除零
            vec3 specular = numerator / denominator;
            
            // kS 是菲涅尔反射部分 (即 F)
            vec3 kS = F;
            // kD 是剩下的漫反射部分 (能量守恒: 入射光 - 反射光)
            vec3 kD = vec3(1.0) - kS;
            // 金属没有漫反射 (被自由电子吸收)，所以乘以 (1 - metallic)
            kD *= 1.0 - metallic;	  

            // 最终出射光 Lo = (漫反射 + 镜面反射) * 辐射率 * cosTheta
            float NdotL = max(dot(N, L), 0.0);
            
            return (kD * albedo / PI + specular) * radiance * NdotL;
        }

        // 6. 环境光 BRDF 近似计算 (替代 BRDF LUT 贴图)
        // 这是 Karis (Epic Games) 提出的拟合公式，极其经典
        vec3 EnvBRDFApprox(vec3 specularColor, float roughness, float NdotV)
        {
            const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
            const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
            vec4 r = roughness * c0 + c1;
            float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
            vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
            return specularColor * AB.x + AB.y;
        }

        // 函数声明
        vec4 getTriplanarSample(vec3 worldPos, vec3 normal);

        void CalcDirLight(DirLight light, vec3 N, vec3 V, vec3 albedo, vec3 F0, float roughness, float shadow, inout vec3 diffAccum, inout vec3 specAccum);
        void CalcPointLight(PointLight light, vec3 N, vec3 pos, vec3 V, vec3 albedo, vec3 F0, float roughness, float shadow, inout vec3 diffAccum, inout vec3 specAccum);
        void CalcSpotLight(SpotLight light, vec3 N, vec3 pos, vec3 V, vec3 albedo, vec3 F0, float roughness, inout vec3 diffAccum, inout vec3 specAccum);

        vec3 BoxProjectedCubemapDirection(vec3 worldPos, vec3 worldRefDir, vec3 pPos, vec3 boxMin, vec3 boxMax);

        float ShadowCalculation(vec3 fragPosWorld, vec3 normal, vec3 lightDir, float viewSpaceDepth, int baseLayerIndex);
        float CalcPointShadow(vec3 fragPos, vec3 lightPos, int shadowIndex, float range, float radius, float bias);

        float GetAttenuation(float distance, float range);

        TriplanarData CalcTriplanarData(vec3 position, vec3 normal);
        vec4 SampleTriplanar(sampler2D theMap, TriplanarData data);
        vec3 SampleTriplanarNormal(sampler2D normMap, TriplanarData data, vec3 worldNormal);

		// 获取法线辅助函数
		vec3 getNormal() {
            vec3 n = normalize(Normal);
            if (isDoubleSided && !gl_FrontFacing) n = -n; 
            return n;
        }

        // ACES Tone Mapping
        vec3 ACESFilm(vec3 x) {
            float a = 2.51f;
            float b = 0.03f;
            float c = 2.43f;
            float d = 0.59f;
            float e = 0.14f;
            return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
        }
        
        void main() {
            vec3 norm = getNormal();

            TriplanarData triData;
            if (useTriplanar) {
                // 使用 LocalPos 保证纹理随物体移动
                triData = CalcTriplanarData(LocalPos, norm); 
            }

            if (hasOpacityMap) {
                float opacity;
                if (useTriplanar) {
                    opacity = SampleTriplanar(opacityMap, triData).r; // 假设是灰度图，取 R 通道
                } else {
                    opacity = texture(opacityMap, TexCoord).r;
                }

                // 如果不透明度低于阈值，直接丢弃该像素
                if (opacity < alphaCutoff) {
                    discard;
                }
            }

            vec3 albedoColor = material.albedo;

            // 基础纹理采样
            if (hasDiffuseMap) {
                vec4 texColor;
                if (useTriplanar) {
                    texColor = SampleTriplanar(diffuseMap, triData);
                } else {
                    texColor = texture(diffuseMap, TexCoord);
                }
                // sRGB 矫正
                texColor.rgb = pow(texColor.rgb, vec3(2.2)); 
                albedoColor = texColor.rgb * material.albedo;
            }

            if (hasNormalMap) {
                if (useTriplanar) {
                    // 使用专门的 Triplanar 法线混合函数
                    // 注意：这里传入的是几何法线 Normal (大写的)，不是 TBN 计算出的
                    norm = SampleTriplanarNormal(normalMap, triData, normalize(Normal));
                } else {
                    // 标准 UV 法线 (使用 getNormal 里的逻辑，可以直接把代码搬过来或保持原样)
                    // ... 之前的 TBN 逻辑 ...
                    vec3 rawNormal = texture(normalMap, TexCoord).rgb;
                    if (flipNormalY) rawNormal.g = 1.0 - rawNormal.g;
                    vec3 tangentNormal = rawNormal * 2.0 - 1.0;
                    tangentNormal.xy *= normalStrength;
                    norm = normalize(TBN * normalize(tangentNormal));
                    if (isDoubleSided && !gl_FrontFacing) norm = -norm; 
                }
            } else {
                // 如果没有贴图，确保 norm 已经处理了双面渲染
                if (isDoubleSided && !gl_FrontFacing) norm = -norm; 
            }

            // Unlit 模式直接返回
            if (isUnlit) {
                FragColor = vec4(albedoColor, 1.0); 
                return;
            }
            
            vec3 viewDir = normalize(viewPos - FragPos);

            float roughness = material.roughness;
            float metallic  = material.metallic;
            float ao        = material.ao;

            if (hasOrmMap) {
                vec4 ormSample;
                if (useTriplanar) {
                    ormSample = SampleTriplanar(ormMap, triData);
                } else {
                    ormSample = texture(ormMap, TexCoord);
                }
                
                // glTF / Unreal 标准: 
                // R = Occlusion (AO)
                // G = Roughness
                // B = Metallic
                ao        = ormSample.r;
                roughness = ormSample.g;
                metallic  = ormSample.b;
            }
            
            // ================= PBR 参数准备 =================
            // F0: 基础反射率 (0度角的反射率)
            // 绝缘体(非金属) F0 约为 0.04
            // 导体(金属) F0 为自身的 albedo 颜色
            vec3 F0 = vec3(0.04); 
            F0 = mix(F0, albedoColor, metallic);
            // ==============================================

            // 分离 Diffuse 和 Specular 累加器
            vec3 directDiffuse = vec3(0.0);
            vec3 directSpecular = vec3(0.0);

            // 1. 计算所有直接光照
            for(int i = 0; i < dirLightCount; i++) {
                float shadow = 1.0;
                if (dirLights[i].shadowIndex >= 0) {
                    vec3 lightDir = normalize(-dirLights[i].direction);
                    shadow = ShadowCalculation(FragPos, norm, lightDir, ClipSpaceZ, dirLights[i].shadowIndex);
                }
                CalcDirLight(dirLights[i], norm, viewDir, albedoColor, F0, roughness, shadow, directDiffuse, directSpecular);
            }
            
            for(int i = 0; i < pointLightCount; i++) {
                float shadow = 1.0;
                if (pointLights[i].shadowIndex >= 0) {
                    float rawShadow = CalcPointShadow(FragPos, pointLights[i].position, pointLights[i].shadowIndex, pointLights[i].range, pointLights[i].shadowRadius, pointLights[i].shadowBias);
                    shadow = mix(1.0, rawShadow, pointLights[i].shadowStrength);
                }
                CalcPointLight(pointLights[i], norm, FragPos, viewDir, albedoColor, F0, roughness, shadow, directDiffuse, directSpecular);
            }
            
            for(int i = 0; i < spotLightCount; i++)
                CalcSpotLight(spotLights[i], norm, FragPos, viewDir, albedoColor, F0, roughness, directDiffuse, directSpecular);
            
            // 2. 环境光 (IBL)
            vec3 ambientDiffuse = vec3(0.0);
            vec3 ambientSpecular = vec3(0.0);
            
            if (hasEnvMap) {
                // Diffuse IBL
                vec3 irradiance = textureLod(envMap, norm, 8.0).rgb; 
                vec3 kS = FresnelSchlickRoughness(max(dot(norm, viewDir), 0.0), F0, roughness);
                vec3 kD = 1.0 - kS;
                kD *= 1.0 - metallic;
                
                ambientDiffuse = kD * irradiance * albedoColor * iblIntensity;

                // Specular IBL
                vec3 R = reflect(-viewDir, norm);
                vec3 correctedR = BoxProjectedCubemapDirection(FragPos, R, probePos, probeBoxMin, probeBoxMax);
                float MAX_LOD = 4.0;
                vec3 prefilteredColor = textureLod(envMap, correctedR, roughness * MAX_LOD).rgb;
                vec3 specularFactor = EnvBRDFApprox(F0, roughness, max(dot(norm, viewDir), 0.0));
                
                ambientSpecular = prefilteredColor * specularFactor * iblIntensity;
            } else {
                ambientDiffuse = vec3(0.03) * albedoColor * ao;
            }
            
            // 3. 组合 PBR 不透明部分
            vec3 opaqueColor = (ambientDiffuse + directDiffuse) * ao + (ambientSpecular + directSpecular);
            
            // 4. 玻璃/折射逻辑 (关键修改)
            vec3 finalColor = opaqueColor;

            if (material.transparency > 0.001) 
            {
                // 计算玻璃的 Fresnel (使用用户指定的 Reflectivity 微调 F0)
                float glassF0 = mix(0.0, 0.5, material.reflectivity); // 注意：这里范围改小了
                // 或者更物理一点，假设玻璃 F0 固定 0.04，Reflectivity 只控制额外增强
                vec3 F0_Glass = vec3(0.04); 
                
                float cosTheta = clamp(dot(norm, -normalize(FragPos - viewPos)), 0.0, 1.0);
                vec3 F = FresnelSchlick(cosTheta, F0_Glass);
                
                // 用户 reflectivity 额外增强 Fresnel 效果 (艺术控制)
                F += material.reflectivity * 0.5;
                F = clamp(F, 0.0, 1.0);

                // 折射与反射
                vec3 refractColor = vec3(0.0);
                vec3 reflectColor = vec3(0.0);

                if (hasEnvMap) {
                    // Refract
                    float k = max(material.refractionIndex, 1.0);
                    float ratio = 1.0 / k;
                    vec3 I = normalize(FragPos - viewPos);
                    
                    // 简化折射采样 (不做色散了，为了性能和清晰度)
                    vec3 R_refract = refract(I, norm, ratio);
                    vec3 corrR_refract = BoxProjectedCubemapDirection(FragPos, R_refract, probePos, probeBoxMin, probeBoxMax);
                    refractColor = textureLod(envMap, corrR_refract, 0.0).rgb * iblIntensity;

                    // Reflect
                    vec3 R_reflect = reflect(I, norm);
                    vec3 corrR_reflect = BoxProjectedCubemapDirection(FragPos, R_reflect, probePos, probeBoxMin, probeBoxMax);
                    reflectColor = textureLod(envMap, corrR_reflect, material.roughness * 4.0).rgb * iblIntensity;
                }

                vec3 glassBody = mix(refractColor, reflectColor, F);
                
                // [关键] 混合: 玻璃本体 + 直接光高光 (Sun Specular)
                // 即使玻璃是透明的，太阳照上去也应该有亮斑 (directSpecular)
                // 而 diffuse 部分被 transparency 替换掉了
                
                vec3 glassResult = glassBody + directSpecular;

                finalColor = mix(opaqueColor, glassResult, material.transparency);
            }

            // 自发光
            vec3 emission = emissiveColor * emissiveStrength;
            
            if (hasEmissiveMap) {
                vec3 emTex;
                if (useTriplanar) {
                    emTex = SampleTriplanar(emissiveMap, triData).rgb;
                } else {
                    emTex = texture(emissiveMap, TexCoord).rgb;
                }
                
                // 自发光贴图是颜色信息，通常是 sRGB 的，需要转到 Linear 空间
                emTex = pow(emTex, vec3(2.2));
                
                emission *= emTex;
            }
            
            finalColor += emission;

            // 5. Tone Mapping (ACES)
            finalColor = ACESFilm(finalColor);
            
            // 6. Gamma
            finalColor = pow(finalColor, vec3(1.0/2.2));

            FragColor = vec4(finalColor, 1.0);

            // Debug Cascade Layers (仅显示第一个开启阴影的光源的层级)
            if (isDebug) {
                int layer = -1;
                for (int i = 0; i < cascadeCount; ++i) {
                    if (ClipSpaceZ < cascadePlaneDistances[i]) {
                        layer = i;
                        break;
                    }
                }
                if (layer == -1) layer = cascadeCount;
                vec3 debugColor = vec3(0.0);
                if (layer == 0) debugColor = vec3(1.0, 0.0, 0.0);
                else if (layer == 1) debugColor = vec3(0.0, 1.0, 0.0);
                else if (layer == 2) debugColor = vec3(0.0, 0.0, 1.0);
                else if (layer == 3) debugColor = vec3(1.0, 1.0, 0.0);
                else debugColor = vec3(1.0, 0.0, 1.0);
                FragColor = vec4(mix(FragColor.rgb, debugColor, 0.2), 1.0);
            }
        }

        vec2 rotateUV(vec2 uv, float angleDeg) {
            vec2 center = vec2(0.5);
            uv -= center;
            float rad = radians(angleDeg);
            float s = sin(rad);
            float c = cos(rad);
            mat2 rotMat = mat2(c, -s, s, c);
            uv = rotMat * uv;
            uv += center;
            return uv;
        }

        TriplanarData CalcTriplanarData(vec3 position, vec3 normal) {
            TriplanarData data;
            
            // 1. 权重
            vec3 blending = abs(normal);
            blending = pow(blending, vec3(4.0)); 
            float b = (blending.x + blending.y + blending.z);
            data.blend = blending / vec3(b, b, b);

            // 2. 基础投影
            data.uvX = position.zy * triplanarScale + 0.5;
            data.uvY = position.xz * triplanarScale + 0.5;
            data.uvZ = position.xy * triplanarScale + 0.5;

            // 3. 旋转 (基于轴向)
            // X轴
            bool isPosX = normal.x > 0.0;
            float rotX = isPosX ? triRotPos.x : triRotNeg.x;
            if (rotX > 0.1) data.uvX = rotateUV(data.uvX, rotX);
            
            // Y轴
            bool isPosY = normal.y > 0.0;
            float rotY = isPosY ? triRotPos.y : triRotNeg.y;
            if (rotY > 0.1) data.uvY = rotateUV(data.uvY, rotY);

            // Z轴
            bool isPosZ = normal.z > 0.0;
            float rotZ = isPosZ ? triRotPos.z : triRotNeg.z;
            if (rotZ > 0.1) data.uvZ = rotateUV(data.uvZ, rotZ);

            // 4. 翻转 (基于轴向)
            bool flipX = isPosX ? (triFlipPos.x > 0.5) : (triFlipNeg.x > 0.5);
            if (flipX) data.uvX.x = -data.uvX.x;

            bool flipY = isPosY ? (triFlipPos.y > 0.5) : (triFlipNeg.y > 0.5);
            if (flipY) data.uvY.x = -data.uvY.x;

            bool flipZ = isPosZ ? (triFlipPos.z > 0.5) : (triFlipNeg.z > 0.5);
            if (flipZ) data.uvZ.x = -data.uvZ.x;

            return data;
        }

        // --- 函数实现 ---

        vec4 SampleTriplanar(sampler2D theMap, TriplanarData data) {
            vec4 colX = texture(theMap, data.uvX);
            vec4 colY = texture(theMap, data.uvY);
            vec4 colZ = texture(theMap, data.uvZ);
            return colX * data.blend.x + colY * data.blend.y + colZ * data.blend.z;
        }

        vec3 SampleTriplanarNormal(sampler2D normMap, TriplanarData data, vec3 worldNormal) {
            // 1. 采样
            vec3 nX = texture(normMap, data.uvX).xyz;
            vec3 nY = texture(normMap, data.uvY).xyz;
            vec3 nZ = texture(normMap, data.uvZ).xyz;

            // 2. 解包 (0~1 -> -1~1) 并处理翻转
            if (flipNormalY) {
                nX.g = 1.0 - nX.g; nY.g = 1.0 - nY.g; nZ.g = 1.0 - nZ.g;
            }
            nX = nX * 2.0 - 1.0;
            nY = nY * 2.0 - 1.0;
            nZ = nZ * 2.0 - 1.0;

            // 应用强度
            nX.xy *= normalStrength; nY.xy *= normalStrength; nZ.xy *= normalStrength;
            // 重新归一化是必要的，因为修改强度后长度变了
            nX = normalize(nX); nY = normalize(nY); nZ = normalize(nZ);

            // 3. 转换到世界空间 (修正部分)
            // 这里的逻辑是：
            // 切线空间的 Z (n.z) 对应 世界空间的 几何法线方向 (X, Y 或 Z)
            // 切线空间的 X (n.x) 对应 切线 (Tangent)
            // 切线空间的 Y (n.y) 对应 副切线 (Bitangent)
            
            // X面投影 (ZY平面 UV): U->Z(Tangent), V->Y(Bitangent), Face->X
            // 修正：将 nX.z 放入 X 分量
            vec3 worldNormalX = vec3(nX.z, nX.y, nX.x); 

            // Y面投影 (XZ平面 UV): U->X(Tangent), V->Z(Bitangent), Face->Y
            // 修正：将 nY.z 放入 Y 分量
            vec3 worldNormalY = vec3(nY.x, nY.z, nY.y); 

            // Z面投影 (XY平面 UV): U->X(Tangent), V->Y(Bitangent), Face->Z
            // 修正：将 nZ.z 放入 Z 分量
            vec3 worldNormalZ = vec3(nZ.x, nZ.y, nZ.z);

            // 4. 处理背面翻转
            // 如果几何法线指向负方向，我们需要翻转重构出的法线的主轴分量
            // 这样才能保证法线贴图的 Z 依然指向“表面外侧”
            if (worldNormal.x < 0.0) worldNormalX.x = -worldNormalX.x;
            if (worldNormal.y < 0.0) worldNormalY.y = -worldNormalY.y;
            if (worldNormal.z < 0.0) worldNormalZ.z = -worldNormalZ.z;

            // 5. 混合
            vec3 blendedNormal = worldNormalX * data.blend.x + 
                                worldNormalY * data.blend.y + 
                                worldNormalZ * data.blend.z;
            
            return normalize(blendedNormal);
        }

        void CalcDirLight(DirLight light, vec3 N, vec3 V, vec3 albedo, vec3 F0, float roughness, float shadow, inout vec3 diffAccum, inout vec3 specAccum) {
            vec3 L = normalize(-light.direction);
            vec3 H = normalize(V + L);
            float NdotL = max(dot(N, L), 0.0);
            
            // Radiance
            vec3 radiance = light.color * light.intensity * shadow;

            // Cook-Torrance
            float NDF = DistributionGGX(N, H, roughness);    
            float G   = GeometrySmith(N, V, L, roughness);       
            vec3 F    = FresnelSchlick(max(dot(H, V), 0.0), F0);
           
            vec3 numerator    = NDF * G * F; 
            float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.0001;
            vec3 specular = numerator / denominator;
            
            vec3 kS = F;
            vec3 kD = vec3(1.0) - kS;
            // 注意：metallic 我们在 main 函数里计算 F0 时已经处理了，这里只需要 roughness
            // 但 kD *= 1.0 - metallic 这个逻辑通常也是在 main 里通过 F0 隐式处理，
            // 或者我们可以保留 metallic 作为一个参数传进来。
            // 为了简化，标准 PBR 流程中 F0 已经蕴含了金属度信息，kD 的缩放可以在外面做，
            // 但为了保持和你现有代码一致，我们假设 metallic 仅影响 F0 的计算，
            // 这里的 kD 缩放其实应该用传入的 metallic。
            // 鉴于改动量，我们**暂时保留**读取 material.metallic，因为 metallic 通常不需要逐像素变化得那么剧烈，
            // 或者你可以把 metallic 也加进参数里。为了严谨，我们假设 metallic 还是全局的，
            // 因为 ORM 里的 M 通道通常是非 0 即 1。
            // *修正*：为了完全正确支持 ORM，metallic 也必须是局部的。
            // 让我们简单点：既然要改，就只改 roughness。Metallic 的影响主要在 F0 (已传入) 和 kD。
            // 在这里我们暂时不传 metallic，而是依赖 main 函数算好的 albedo 和 F0。
            // 唯一的问题是 kD *= 1.0 - metallic。
            // 如果你想完美，最好把 metallic 也传进来。
            // **为了代码最小化改动**：我们这里先不动 metallic (仍然读全局)，只动 roughness。
            // 如果你发现金属贴图的非金属部分太暗，我们再回来改这个。
            kD *= 1.0 - material.metallic;	  

            // 累加
            diffAccum += (kD * albedo / PI) * radiance * NdotL;
            specAccum += specular * radiance * NdotL;
        }

        void CalcPointLight(PointLight light, vec3 N, vec3 pos, vec3 V, vec3 albedo, vec3 F0, float roughness, float shadow, inout vec3 diffAccum, inout vec3 specAccum) {
            vec3 L = normalize(light.position - pos);
            vec3 H = normalize(V + L);
            float distance = length(light.position - pos);
            float attenuation = GetAttenuation(distance, light.range);
            float NdotL = max(dot(N, L), 0.0);

            vec3 radiance = light.color * light.intensity * attenuation * shadow;

            float NDF = DistributionGGX(N, H, roughness);
            float G   = GeometrySmith(N, V, L, roughness);
            vec3 F    = FresnelSchlick(max(dot(H, V), 0.0), F0);
           
            vec3 numerator    = NDF * G * F; 
            float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.0001;
            vec3 specular = numerator / denominator;
            
            vec3 kS = F;
            vec3 kD = vec3(1.0) - kS;
            kD *= 1.0 - material.metallic;	  

            diffAccum += (kD * albedo / PI) * radiance * NdotL;
            specAccum += specular * radiance * NdotL;
        }

        void CalcSpotLight(SpotLight light, vec3 N, vec3 pos, vec3 V, vec3 albedo, vec3 F0, float roughness, inout vec3 diffAccum, inout vec3 specAccum) {
            vec3 L = normalize(light.position - pos);
            vec3 H = normalize(V + L);
            float distance = length(light.position - pos);
            float attenuation = GetAttenuation(distance, light.range);
            float NdotL = max(dot(N, L), 0.0);

            float theta = dot(L, normalize(-light.direction)); 
            float epsilon = light.cutOff - light.outerCutOff;
            float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);

            vec3 radiance = light.color * light.intensity * attenuation * intensity;

            float NDF = DistributionGGX(N, H, roughness);
            float G   = GeometrySmith(N, V, L, roughness);
            vec3 F    = FresnelSchlick(max(dot(H, V), 0.0), F0);
           
            vec3 numerator    = NDF * G * F; 
            float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.0001;
            vec3 specular = numerator / denominator;
            
            vec3 kS = F;
            vec3 kD = vec3(1.0) - kS;
            kD *= 1.0 - material.metallic;	  

            diffAccum += (kD * albedo / PI) * radiance * NdotL;
            specAccum += specular * radiance * NdotL;
        }

        // Box Projection
        // worldPos: 当前片元的世界坐标
        // worldRefDir: 原始反射向量
        vec3 BoxProjectedCubemapDirection(vec3 worldPos, vec3 worldRefDir, vec3 pPos, vec3 boxMin, vec3 boxMax) {
            vec3 nrdir = normalize(worldRefDir);
            
            // 1. 计算射线与 Box 6个面的交点距离 (类似于 AABB 碰撞检测)
            vec3 rbmax = (boxMax - worldPos) / nrdir;
            vec3 rbmin = (boxMin - worldPos) / nrdir;

            // 2. 找出正向射线的交点 (只关心反射方向那一侧的墙)
            vec3 rbminmax;
            rbminmax.x = (nrdir.x > 0.0) ? rbmax.x : rbmin.x;
            rbminmax.y = (nrdir.y > 0.0) ? rbmax.y : rbmin.y;
            rbminmax.z = (nrdir.z > 0.0) ? rbmax.z : rbmin.z;

            // 3. 取最小的正距离 (最近的交点)
            float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);

            // 4. 计算交点位置
            vec3 posonbox = worldPos + nrdir * fa;

            // 5. 将交点转换为相对于探针中心的向量
            return posonbox - pPos;
        }

        // CSM (平行光) 辅助变量
        vec2 poissonDisk[16] = vec2[]( 
            vec2( -0.94201624, -0.39906216 ), vec2( 0.94558609, -0.76890725 ), vec2( -0.094184101, -0.92938870 ), vec2( 0.34495938, 0.29387760 ),
            vec2( -0.91588581, 0.45771432 ), vec2( -0.81544232, -0.87912464 ), vec2( -0.38277543, 0.27676845 ), vec2( 0.97484398, 0.75648379 ),
            vec2( 0.44323325, -0.97511554 ), vec2( 0.53742981, -0.47373420 ), vec2( -0.26496911, -0.41893023 ), vec2( 0.79197514, 0.19090188 ),
            vec2( -0.24188840, 0.99706507 ), vec2( -0.81409955, 0.91437590 ), vec2( 0.19984126, 0.78641367 ), vec2( 0.14383161, -0.14100790 )
        );

        float random(vec3 seed, int i){
            vec4 seed4 = vec4(seed, i);
            float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
            return fract(sin(dot_product) * 43758.5453);
        }

        // 平行光阴影计算函数 (PCF + Bias)
        // 返回 0.0 (全阴影) 到 1.0 (无阴影)
        float ShadowCalculation(vec3 fragPosWorld, vec3 normal, vec3 lightDir, float viewSpaceDepth, int baseLayerIndex)
        {
            // 1. 选择级联层级
            int layer = -1;
            for (int i = 0; i < cascadeCount; ++i) {
                if (viewSpaceDepth < cascadePlaneDistances[i]) {
                    layer = i;
                    break;
                }
            }
            if (layer == -1) layer = cascadeCount;
            
            // A. 计算 Z 轴混合权重 (基于视锥分割距离)
            float blendFactor = 0.0;
            int nextLayer = layer + 1;
            if (nextLayer > cascadeCount) nextLayer = cascadeCount;
            
            if (layer < cascadeCount) {
                float splitDist = cascadePlaneDistances[layer];
                float distToEdge = splitDist - viewSpaceDepth;
                float blendBand = 5.0; // Z轴混合带宽度
                
                if (distToEdge < blendBand) {
                    blendFactor = 1.0 - (distToEdge / blendBand);
                }
            }

            // 计算全局矩阵索引 = baseLayerIndex + 局部layer
            int currentMatrixIndex = baseLayerIndex + layer;
            int nextMatrixIndex    = baseLayerIndex + nextLayer;

            // B. 计算 UV 边缘混合权重 (防止侧面漏光/阴影截断)
            // 我们提前计算当前层在光空间的位置，看看是否快出界了
            vec4 fragPosLightSpace = lightSpaceMatrices[currentMatrixIndex] * vec4(fragPosWorld, 1.0);
            vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
            projCoords = projCoords * 0.5 + 0.5;

            // 计算当前点距离纹理中心的距离 (0~0.5)
            vec2 distFromCenter = abs(projCoords.xy - 0.5);
            // 找出最远的那个轴
            float maxDist = max(distFromCenter.x, distFromCenter.y);
            
            // 定义边缘阈值：从 0.4 (80%处) 开始混合，到 0.49 (98%处) 完全切换到下一层
            // 这样保证在出界(0.5)之前，我们已经完全切换到了下一层
            float uvBlendFactor = smoothstep(0.4, 0.49, maxDist);

            // [关键]：最终混合权重取 Z轴 和 UV边缘 的最大值
            // 这意味着：即使 Z 轴认为不需要混合，如果 UV 快出界了，也强制混合！
            blendFactor = max(blendFactor, uvBlendFactor);
            
            // 如果已经是最后一层了，就不能再往后混合了，避免采样越界
            if (layer == cascadeCount) {
                blendFactor = 0.0; 
            }

            // ------------------------------------------------------------------
            // 下面是通用的 PCF 采样逻辑
            // ------------------------------------------------------------------

            // 采样循环
            int layersToSample = (blendFactor > 0.001) ? 2 : 1;
            float layerShadows[2]; 
            layerShadows[0] = 1.0; layerShadows[1] = 1.0; // 默认为1.0(亮)
            
            // PCF 参数
            vec3 N = normalize(normal);
            vec3 L = normalize(lightDir);
            float cosTheta = clamp(dot(N, L), 0.0, 1.0);
            float baseBias = shadowBias * (1.0 - cosTheta);
            baseBias = max(baseBias, shadowBias * 0.1);
            float rotAngle = random(vec3(gl_FragCoord.xy, 1.0), 0) * 6.283185;
            float s = sin(rotAngle); float c = cos(rotAngle);
            mat2 rot = mat2(c, -s, s, c);

            for (int i = 0; i < layersToSample; ++i) 
            {
                int activeLocalLayer = (i == 0) ? layer : nextLayer;
                int activeGlobalIndex = baseLayerIndex + activeLocalLayer;
                
                // 计算当前层级的坐标
                vec4 fPosLight = lightSpaceMatrices[activeGlobalIndex] * vec4(fragPosWorld, 1.0);
                vec3 pCoords = fPosLight.xyz / fPosLight.w;
                pCoords = pCoords * 0.5 + 0.5;

                // 越界检查 (如果出界，直接返回无阴影，交由混合逻辑处理)
                if(pCoords.z > 1.0 || pCoords.x < 0.0 || pCoords.x > 1.0 || pCoords.y < 0.0 || pCoords.y > 1.0) {
                    layerShadows[i] = 1.0; 
                    continue; 
                }

                // 级联 Bias 调整
                float currentBias = baseBias;
                if (activeLocalLayer == 1) currentBias *= 0.5;
                else if (activeLocalLayer == 2) currentBias *= 0.25;
                else if (activeLocalLayer == 3) currentBias *= 0.125;

                float currentDepth = pCoords.z - currentBias;
                
                // 设置 PCF 半径
                float filterRadius = 1.0;
                if (activeLocalLayer == 0) filterRadius = 4.0;
                else if (activeLocalLayer == 1) filterRadius = 2.0;
                else if (activeLocalLayer == 2) filterRadius = 1.0;
                else filterRadius = 0.5;

                vec2 texSize = 1.0 / textureSize(shadowMap, 0).xy;
                
                float shadowSum = 0.0;
                for(int k = 0; k < 16; ++k)
                {
                    vec2 offset = rot * poissonDisk[k];
                    shadowSum += texture(shadowMap, vec4(pCoords.xy + offset * texSize * filterRadius, activeGlobalIndex, currentDepth));
                }
                layerShadows[i] = shadowSum / 16.0; 
            }

            // 最终混合
            float finalVisibility = layerShadows[0];
            if (layersToSample > 1) {
                finalVisibility = mix(layerShadows[0], layerShadows[1], blendFactor);
            }
            
            return finalVisibility; 
        }

        // 用于点光源 PCF 的采样偏移向量 (20个方向)
        vec3 gridSamplingDisk[20] = vec3[](
           vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1), 
           vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
           vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
           vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
           vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
        );

        // 点光源阴影计算函数
        float CalcPointShadow(vec3 fragPos, vec3 lightPos, int shadowIndex, float range, float radius, float bias)
        {
            // 注意：我们之前用 uniform 传了 pointShadowFarPlanes
            // 但其实对于现代物理光照，Range 本身就是 FarPlane (光照在 Range 处归零)
            // 所以我们可以直接用 light.range 作为远平面
            float farPlane = range; 
            
            vec3 fragToLight = fragPos - lightPos;
            float currentDepth = length(fragToLight);
            
            float shadow = 0.0;
            int samples = 20;
            float viewDistance = length(viewPos - fragPos);
            
            // 使用 radius 参数控制模糊程度
            // 公式：(1 + viewDist/range) * radius / divider
            // 用户输入的 radius 是 0.0 ~ 0.5
            float diskRadius = (1.0 + (viewDistance / farPlane)) * radius; 
            
            float rotX = random(vec3(gl_FragCoord.xy, 1.0), 1);
            float rotY = random(vec3(gl_FragCoord.xy, 1.0), 2);
            float rotZ = random(vec3(gl_FragCoord.xy, 1.0), 3);
            vec3 rotationDir = normalize(vec3(rotX, rotY, rotZ)); 
            
            for(int i = 0; i < samples; ++i)
            {
                float closestDepth = 0.0;
                vec3 sampleOffset = reflect(gridSamplingDisk[i], rotationDir);
                vec3 sampleDir = fragToLight + sampleOffset * diskRadius;

                if (shadowIndex == 0) closestDepth = texture(pointShadowMaps[0], sampleDir).r;
                else if (shadowIndex == 1) closestDepth = texture(pointShadowMaps[1], sampleDir).r;
                else if (shadowIndex == 2) closestDepth = texture(pointShadowMaps[2], sampleDir).r;
                else if (shadowIndex == 3) closestDepth = texture(pointShadowMaps[3], sampleDir).r;
                
                closestDepth *= farPlane;
                
                if(currentDepth - bias > closestDepth)
                    shadow += 1.0;
            }
            shadow /= float(samples);
            return 1.0 - shadow;
        }

        // 物理正确的窗口化反平方衰减
        // distance: 像素到光源距离
        // range: 光源设定的半径
        float GetAttenuation(float distance, float range) {
            // 1. 基础反平方 ( Inverse Square Law )
            // 加一个小数值防止除零 (0.01 或 1.0 取决于单位，这里假设 1 unit = 1 meter)
            float attenuation = 1.0 / (distance * distance + 1.0); 
            
            // 2. 窗口函数 (Windowing Function) - 让光在 range 处平滑归零
            // 来自 Unreal Engine / Frostbite 的公式
            float distDivRange = distance / range;
            float factor = distDivRange * distDivRange; // (d/r)^2
            factor = factor * factor;                   // (d/r)^4
            float window = clamp(1.0 - factor, 0.0, 1.0);
            
            return attenuation * window * window;
        }
    )";

    _mainShader.reset(new GLSLProgram);
    _mainShader->attachVertexShader(vsCode);
    _mainShader->attachFragmentShader(fsCode);
    _mainShader->link();

    // 预设纹理槽位，防止采样器冲突
    _mainShader->use();
    _mainShader->setUniformInt("diffuseMap", 0);  // Slot 0: Albedo
    _mainShader->setUniformInt("normalMap", 1);   // Slot 1: Normal
    _mainShader->setUniformInt("shadowMap", 2);   // Slot 2: CSM Array
    _mainShader->setUniformInt("envMap", 3);      // Slot 3: IBL Cubemap (改到3，避开NormalMap)
    _mainShader->setUniformInt("ormMap", 4);      // Slot 4: ORM
    _mainShader->setUniformInt("emissiveMap", 5); // Slot 5: Emissive
    _mainShader->setUniformInt("opacityMap", 6);  // Slot 6: Opacity


    // Slot 7,8,9,10 用于点光源阴影
    int pointShadowSamplers[4] = {7, 8, 9, 10};
    glUniform1iv(glGetUniformLocation(_mainShader->getHandle(), "pointShadowMaps"), 4, pointShadowSamplers);

    // =============================================================
    // 1. 无限网格 Shader (Unity 风格)
    // =============================================================
    const char* gridVs = R"(
        #version 330 core
        layout(location = 0) in vec3 aPos;
        uniform mat4 view;
        uniform mat4 projection;
        uniform vec3 viewPos;
        
        out vec3 WorldPos;
        out float Near;
        out float Far;

        void main() {
            // 我们把一个小的平面放大很多倍来模拟无限
            vec3 pos = aPos * 1000.0; // 放大平面
            pos.y = 0.0; // 强制在 XZ 平面
            WorldPos = pos;
            gl_Position = projection * view * vec4(pos, 1.0);
            
            // 传递裁剪面信息用于淡出计算
            Near = 0.1; 
            Far = 100.0; 
        }
    )";

    const char* gridFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec3 WorldPos;
        in float Near;
        in float Far;

        uniform vec3 viewPos;

        void main() {
            vec2 coord = WorldPos.xz;
            vec2 derivative = fwidth(coord);
            
            // --- 基础参数 ---
            // 亮白色线条，在深色背景下更清晰
            vec3 gridColor = vec3(0.7, 0.7, 0.7); 
            
            // 1. 绘制小格子 (1米)
            vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;
            float line = min(grid.x, grid.y);
            float minimumz = min(derivative.y, 1.0);
            float minimumx = min(derivative.x, 1.0);
            
            // 小格子透明度低一点 (0.3)
            vec4 color = vec4(gridColor, 0.3 * (1.0 - min(line, 1.0))); 

            // 2. 绘制大格子 (10米)
            vec2 coord2 = coord / 10.0;
            vec2 derivative2 = fwidth(coord2);
            vec2 grid2 = abs(fract(coord2 - 0.5) - 0.5) / derivative2;
            float line2 = min(grid2.x, grid2.y);
            
            // 如果是大格子线，透明度高一点 (0.8)，覆盖小格子
            if(1.0 - min(line2, 1.0) > 0.1) {
                color = vec4(gridColor, 0.8 * (1.0 - min(line2, 1.0)));
            }

            // 3. 轴线高亮 (X轴红色，Z轴蓝色) - 类似 Unity 编辑器
            // 当 z 接近 0 时是 X 轴
            // if(abs(WorldPos.z) < 0.05) color = vec4(1.0, 0.2, 0.2, 1.0); // Red X-Axis
            // 当 x 接近 0 时是 Z 轴
            // if(abs(WorldPos.x) < 0.05) color = vec4(0.2, 0.2, 1.0, 1.0); // Blue Z-Axis

            // 4. 距离淡出 (Fade out)
            float dist = distance(viewPos.xz, WorldPos.xz);
            float alpha = 1.0 - smoothstep(10.0, 400.0, dist);
            color.a *= alpha;

            if (color.a <= 0.0) discard;
            FragColor = color;
        }
    )";

    _gridShader.reset(new GLSLProgram);
    _gridShader->attachVertexShader(gridVs);
    _gridShader->attachFragmentShader(gridFs);
    _gridShader->link();

    // =============================================================
    // 2. 程序化天空盒 Shader (Unity 默认风格)
    // =============================================================
    const char* skyVs = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        out vec3 TexCoords;
        uniform mat4 projection;
        uniform mat4 view;

        void main() {
            TexCoords = aPos;
            // 移除平移分量，让天空盒永远跟着相机
            vec4 pos = projection * mat4(mat3(view)) * vec4(aPos, 1.0);
            
            // [技巧] 让天空盒永远在深度测试的最远处 (z = w, 透视除法后 z/w = 1.0)
            gl_Position = pos.xyww; 
        }
    )";

    const char* skyFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec3 TexCoords;

        void main() {
            vec3 dir = normalize(TexCoords);
            float y = dir.y;

            // =========================================================
            // [配色方案] 
            // =========================================================
            
            // 1. 地面颜色 (Deep Dark Gray)
            vec3 colGround = vec3(0.2, 0.2, 0.2); 

            // 2. 地平线颜色 (Horizon Fog)
            // [修改]: 稍微提亮一点，增加一点“厚重感”和不透明度
            vec3 colHorizon = vec3(0.7, 0.75, 0.82); 

            // 3. 天顶颜色 (Sky Zenith)
            vec3 colZenith  = vec3(0.2, 0.45, 0.8); 

            vec3 finalColor;

            // =========================================================
            // [混合逻辑] 
            // =========================================================
            
            if (y < 0.0) {
                // --- 地下部分 ---
                
                // [核心改进 1: 平滑过渡]
                // 原代码这里使用了 colHorizon * 0.5，导致和上半部分产生接缝。
                // 我们现在直接从 colHorizon 开始，确保 y=0 处无缝连接。

                // [核心改进 2: 加大雾气密度]
                // 我们不改变 -0.2 这个范围，而是改变混合曲线的"形状"。
                // 原始线性混合会让地面黑得太快。
                // 这里先算出线性因子 factorLinear (0.0 到 1.0)
                float factorLinear = smoothstep(0.0, -0.2, y);
                
                // 使用 pow 函数处理因子。
                // 0.4 的指数会让混合因子在接近 0 (地平线) 的地方停留更久，
                // 从而让雾气颜色"渗"入地面更多，看起来雾更浓，但并没有扩大实际渲染范围。
                float factorCurved = pow(factorLinear, 0.4); 

                finalColor = mix(colHorizon, colGround, factorCurved); 
            } 
            else {
                // --- 天空部分 ---
                
                // 同样为了增加雾气感，我们让天顶蓝色的出现稍微"迟"一点
                // 0.5 的指数比原来的 0.7 更小，意味着白色雾气会向上延伸得更有力
                float t = pow(y, 0.5); 
                finalColor = mix(colHorizon, colZenith, t);
            }

            // [色调映射] (可选) 
            // 加上轻微的 Gamma 矫正或 Tone Mapping 可以让雾气看起来更柔和
            // finalColor = pow(finalColor, vec3(1.0/2.2)); 

            FragColor = vec4(finalColor, 1.0);
        }
    )";

    _skyboxShader.reset(new GLSLProgram);
    _skyboxShader->attachVertexShader(skyVs);
    _skyboxShader->attachFragmentShader(skyFs);
    _skyboxShader->link();

    // 2. 初始化模型资源
    _gridPlane = GeometryFactory::createPlane(2.0f, 2.0f);
    _skyboxCube = GeometryFactory::createCube(1.0f);

    // 3. 初始化 OutlinePass (初始大小可以给 0 或窗口大小，后面 onResize 会修)
    _outlinePass = std::make_unique<OutlinePass>(1920, 1080);

    // 4. 初始化 ShadowMapPass
    _shadowPass = std::make_unique<ShadowMapPass>(4096);

    // 5. 初始化 PointShadowPass
    // 分辨率 1024，最大支持 4 个点光源
    _pointShadowPass = std::make_unique<PointShadowPass>(1024, 4);
}

void Renderer::onResize(int width, int height) {
    if (_outlinePass) {
        _outlinePass->onResize(width, height);
    }
}

void Renderer::render(const Scene& scene, Camera* camera, 
                      GLuint targetFBO, int width, int height, 
                      float contentScale,
                      GameObject* selectedObj)
{
    // Pass -1: 烘焙反射探针 (Bake Reflection Probes)
    // 在渲染主画面之前，先更新场景里的“镜子”所看到的景象
    updateReflectionProbes(scene);

    // ===============================================
    // Pass -0.5: 阴影准备与渲染
    // ===============================================
    
    // 1. 收集并分类光源
    std::vector<LightComponent*> dirLights;
    std::vector<LightComponent*> pointLights;
    std::vector<LightComponent*> spotLights;
    
    // 用于传递给 ShadowPass 的纯数据
    std::vector<ShadowCasterInfo> csmCasters; // 平行光
    std::vector<PointShadowInfo> pointShadowInfos; // 点光源
    
    // 记录光源组件对应的纹理层级索引 (LightComponent* -> LayerIndex)
    std::unordered_map<LightComponent*, int> lightToShadowIndex;

    int csmLayersPerLight = _shadowPass->getCascadeCount(); // 通常是 5 (4级联 + 1)
    
    // 遍历场景收集光源
    for (const auto& go : scene.getGameObjects()) {
        auto light = go->getComponent<LightComponent>();
        if (light && light->enabled) {
            if (light->type == LightType::Directional) {
                dirLights.push_back(light);
                
                // 判断是否投射阴影 (且未超过最大限制，假设 ShadowPass 支持 4 个)
                // 注意：这里 4 必须与 ShadowMapPass 构造时的 maxLights 一致
                if (light->castShadows && csmCasters.size() < 4) {
                    ShadowCasterInfo info;
                    // 计算光的方向 (物体的前方是 -Z，应用旋转)
                    info.direction = go->transform.rotation * glm::vec3(0, 0, -1);
                    info.shadowNormalBias = light->shadowNormalBias;
                    info.cullFaceMode = light->shadowCullFace;
                    
                    csmCasters.push_back(info);
                    
                    // 计算该光源在 TextureArray 中的起始层级
                    // 第 0 个光源用 0~4 层，第 1 个用 5~9 层...
                    int baseLayer = (int)(csmCasters.size() - 1) * csmLayersPerLight;
                    lightToShadowIndex[light] = baseLayer;
                } else {
                    lightToShadowIndex[light] = -1; // 不投射阴影
                }
            }
            else if (light->type == LightType::Point) {
                pointLights.push_back(light);

                // 检查是否开启阴影且未超限 (PointShadowPass 最大支持 4 个)
                if (light->castShadows && pointShadowInfos.size() < _pointShadowPass->getMaxLights()) {
                    PointShadowInfo info;
                    info.position = go->transform.position;
                    info.farPlane = light->range;
                    info.lightIndex = (int)pointShadowInfos.size(); // 0, 1, 2, 3...

                    pointShadowInfos.push_back(info);
                    lightToShadowIndex[light] = info.lightIndex;
                } else {
                    lightToShadowIndex[light] = -1;
                }
            }
            else if (light->type == LightType::Spot) {
                spotLights.push_back(light);
            }
        }
    }

    // 2. 执行 Shadow Passes
    // 渲染平行光 (CSM)
    _shadowPass->render(scene, csmCasters, camera);
    
    // 渲染点光源 (Omnidirectional)
    _pointShadowPass->render(scene, pointShadowInfos);

    // ===============================================
    // Pass 1: 主场景渲染
    // ===============================================

    // 1. 绑定目标 FBO
    glBindFramebuffer(GL_FRAMEBUFFER, targetFBO);
    glViewport(0, 0, width, height);

    // 2. 清屏
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);

    // 3. 准备矩阵
    glm::mat4 view = camera->getViewMatrix();
    glm::mat4 proj = camera->getProjectionMatrix();
    glm::vec3 viewPos = camera->transform.position;

    // 绑定阴影纹理数组到 Slot 2
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _shadowPass->getDepthMapArray());

    // 绑定 Point Shadow Cubemaps 到 Slot 7, 8, 9, 10
    for (int i = 0; i < pointShadowInfos.size(); ++i) {
        glActiveTexture(GL_TEXTURE7 + i);
        glBindTexture(GL_TEXTURE_CUBE_MAP, _pointShadowPass->getShadowMap(i));
    }

    // 绘制天空盒
    drawSkybox(view, proj);

    // 绘制场景物体 (传入收集好的光源数据)
    drawSceneObjects(scene, view, proj, viewPos, dirLights, pointLights, spotLights, lightToShadowIndex);

    // 绘制网格
    drawGrid(view, proj, viewPos);

    // 绘制描边
    if (selectedObj) {
        // OutlinePass 需要传入宽高用于重新生成纹理
        _outlinePass->render(selectedObj, camera, contentScale, width, height);
        
        // 恢复 FBO 绑定 (防止 OutlinePass 内部解绑)
        glBindFramebuffer(GL_FRAMEBUFFER, targetFBO);
    }

    // 解绑
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// === 下面是将 SceneRoaming::renderScene 中的逻辑拆分出来的私有函数 ===

void Renderer::drawSkybox(const glm::mat4& view, const glm::mat4& proj) {
    glDepthFunc(GL_LEQUAL);
    _skyboxShader->use();
    _skyboxShader->setUniformMat4("view", view);
    _skyboxShader->setUniformMat4("projection", proj);
    
    glDisable(GL_CULL_FACE);
    _skyboxCube->draw();
    glEnable(GL_CULL_FACE);
    
    glDepthFunc(GL_LESS);
}

void Renderer::drawGrid(const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos) {
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDepthMask(GL_FALSE);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(-1.0f, -1.0f);
    glDisable(GL_CULL_FACE);

    _gridShader->use();
    _gridShader->setUniformMat4("view", view);
    _gridShader->setUniformMat4("projection", proj);
    _gridShader->setUniformVec3("viewPos", viewPos);
    
    _gridPlane->draw();

    glEnable(GL_CULL_FACE);
    glDisable(GL_POLYGON_OFFSET_FILL);
    glDepthFunc(GL_LESS);
    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
}

void Renderer::drawSceneObjects(const Scene& scene, const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos, 
                                const std::vector<LightComponent*>& dirLights,
                                const std::vector<LightComponent*>& pointLights,
                                const std::vector<LightComponent*>& spotLights,
                                const std::unordered_map<LightComponent*, int>& shadowIndices,
                                const GameObject* excludeObject)
{
    _mainShader->use();
    _mainShader->setUniformMat4("projection", proj);
    _mainShader->setUniformMat4("view", view);
    _mainShader->setUniformVec3("viewPos", viewPos);

    _mainShader->setUniformBool("isDebug", false);

    // 1. 设置阴影相关 Uniforms
    _mainShader->setUniformInt("shadowMap", 2);

    // 传递矩阵数组
    const auto& matrices = _shadowPass->getLightSpaceMatrices();
    if (!matrices.empty()) {
        GLint loc = glGetUniformLocation(_mainShader->getHandle(), "lightSpaceMatrices");
        if (loc != -1) {
            glUniformMatrix4fv(loc, (GLsizei)matrices.size(), GL_FALSE, glm::value_ptr(matrices[0]));
        }
    }

    // 传递级联分割距离
    const auto& levels = _shadowPass->getCascadeLevels();
    if (!levels.empty()) {
        GLint loc = glGetUniformLocation(_mainShader->getHandle(), "cascadePlaneDistances");
        if (loc != -1) {
            glUniform1fv(loc, (GLsizei)levels.size(), levels.data());
        }
        _mainShader->setUniformInt("cascadeCount", (int)levels.size());
    }

    // 我们假设所有灯光共享同一个 shadowBias (或者取第一个开启阴影的灯的配置)
    // 如果想每个灯不同，需要在 shader struct 里加 bias 字段
    // 这里简单处理，取一个默认值或第一个灯的值
    float globalBias = 0.001f;
    for(auto l : dirLights) if(l->castShadows) { globalBias = l->shadowBias; break; }
    _mainShader->setUniformFloat("shadowBias", globalBias);

    // 2. Point Shadows -> Slot 7, 8, 9, 10
    int pointShadowSamplers[4] = {7, 8, 9, 10};
    GLint locPointMaps = glGetUniformLocation(_mainShader->getHandle(), "pointShadowMaps");
    if (locPointMaps != -1) {
        // 传递数组
        glUniform1iv(locPointMaps, 4, pointShadowSamplers);
    }

    // 传递 Far Planes (用于深度归一化)
    // 我们需要在 shadowIndices 中查找哪些灯开启了阴影，并收集它们的 FarPlane
    // 这里简单处理：我们在 render() 里硬编码了 50.0f，这里需要保持一致
    // 更好的做法是将 farPlane 存在 LightComponent 或者 render() 传进来
    float pointShadowFarPlanes[4] = {50.0f, 50.0f, 50.0f, 50.0f}; 
    GLint locFarPlanes = glGetUniformLocation(_mainShader->getHandle(), "pointShadowFarPlanes");
    if (locFarPlanes != -1) {
        glUniform1fv(locFarPlanes, 4, pointShadowFarPlanes);
    }

    // 2. 提交光源数据
    int maxDir = 4; // Shader 中定义的 NR_DIR_LIGHTS
    int countDir = 0;
    for (auto light : dirLights) {
        if (countDir >= maxDir) break;
        std::string base = "dirLights[" + std::to_string(countDir) + "]";
        
        glm::vec3 dir = light->owner->transform.rotation * glm::vec3(0, 0, -1);
        _mainShader->setUniformVec3(base + ".direction", dir);
        _mainShader->setUniformVec3(base + ".color", light->color);
        _mainShader->setUniformFloat(base + ".intensity", light->intensity);
        
        // 设置 Shadow Index
        int idx = -1;
        if (shadowIndices.count(light)) {
            idx = shadowIndices.at(light);
        }
        _mainShader->setUniformInt(base + ".shadowIndex", idx);
        
        countDir++;
    }
    _mainShader->setUniformInt("dirLightCount", countDir);

    int maxPoint = 4;
    int countPoint = 0;
    for (auto light : pointLights) {
        if (countPoint >= maxPoint) break;
        std::string base = "pointLights[" + std::to_string(countPoint) + "]";
        _mainShader->setUniformVec3(base + ".position", light->owner->transform.position);
        _mainShader->setUniformVec3(base + ".color", light->color);
        _mainShader->setUniformFloat(base + ".intensity", light->intensity);
        _mainShader->setUniformFloat(base + ".range", light->range);

        int idx = -1;
        if (shadowIndices.count(light)) idx = shadowIndices.at(light);
        _mainShader->setUniformInt(base + ".shadowIndex", idx);

        // 即使 idx == -1 (无阴影)，也可以传进去，反正 Shader 里有 if 判断
        _mainShader->setUniformFloat(base + ".shadowStrength", light->shadowStrength);
        _mainShader->setUniformFloat(base + ".shadowRadius", light->shadowRadius);
        _mainShader->setUniformFloat(base + ".shadowBias", light->shadowBias);
        
        // 顺便更新 Gizmo 颜色 (可选)
        if (auto mesh = light->owner->getComponent<MeshComponent>()) {
            if (mesh->isGizmo) mesh->material.albedo = light->color;
        }
        countPoint++;
    }
    _mainShader->setUniformInt("pointLightCount", countPoint);

    int maxSpot = 4;
    int countSpot = 0;
    for (auto light : spotLights) {
        if (countSpot >= maxSpot) break;
        std::string base = "spotLights[" + std::to_string(countSpot) + "]";
        glm::vec3 dir = light->owner->transform.rotation * glm::vec3(0, 0, -1);
        
        _mainShader->setUniformVec3(base + ".position", light->owner->transform.position);
        _mainShader->setUniformVec3(base + ".direction", dir);
        _mainShader->setUniformVec3(base + ".color", light->color);
        _mainShader->setUniformFloat(base + ".intensity", light->intensity);
        _mainShader->setUniformFloat(base + ".cutOff", light->cutOff);
        _mainShader->setUniformFloat(base + ".outerCutOff", light->outerCutOff);
        _mainShader->setUniformFloat(base + ".range", light->range);
        
        if (auto mesh = light->owner->getComponent<MeshComponent>()) {
            if (mesh->isGizmo) mesh->material.albedo = light->color;
        }
        countSpot++;
    }
    _mainShader->setUniformInt("spotLightCount", countSpot);

    _mainShader->setUniformInt("diffuseMap", 0);

    // 3. 绘制物体 Loop
    glFrontFace(GL_CCW);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    for (const auto& go : scene.getGameObjects()) {
        // 排除特定物体 (防止烘焙时自己遮挡自己)
        if (excludeObject && go.get() == excludeObject) continue;

        auto meshComp = go->getComponent<MeshComponent>();
        if (!meshComp || !meshComp->enabled) continue;
        
        auto lightComp = go->getComponent<LightComponent>();
        
        // 双面渲染处理
        if (meshComp->doubleSided) glDisable(GL_CULL_FACE);

        // 纹理绑定
        if (meshComp->diffuseMap) {
            meshComp->diffuseMap->bind(0); // Bind to Slot 0
            _mainShader->setUniformBool("hasDiffuseMap", true);
        } else {
            _mainShader->setUniformBool("hasDiffuseMap", false);
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, 0);
        }

        if (meshComp->normalMap) {
            meshComp->normalMap->bind(1); // Slot 1
            _mainShader->setUniformBool("hasNormalMap", true);
            _mainShader->setUniformFloat("normalStrength", meshComp->normalStrength);
            _mainShader->setUniformBool("flipNormalY", meshComp->flipNormalY);
        } else {
            _mainShader->setUniformBool("hasNormalMap", false);
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, 0);
        }

        if (meshComp->ormMap) {
            meshComp->ormMap->bind(4); // Slot 4
            _mainShader->setUniformBool("hasOrmMap", true);
        } else {
            _mainShader->setUniformBool("hasOrmMap", false);
            glActiveTexture(GL_TEXTURE8);
            glBindTexture(GL_TEXTURE_2D, 0);
        }

        if (meshComp->emissiveMap) {
            meshComp->emissiveMap->bind(5); // Slot 5
            _mainShader->setUniformBool("hasEmissiveMap", true);
        } else {
            _mainShader->setUniformBool("hasEmissiveMap", false);
            glActiveTexture(GL_TEXTURE5);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        _mainShader->setUniformVec3("emissiveColor", meshComp->emissiveColor);
        _mainShader->setUniformFloat("emissiveStrength", meshComp->emissiveStrength);

        if (meshComp->opacityMap) {
            meshComp->opacityMap->bind(6); // Slot 6
            _mainShader->setUniformBool("hasOpacityMap", true);
            _mainShader->setUniformFloat("alphaCutoff", meshComp->alphaCutoff);
        } else {
            _mainShader->setUniformBool("hasOpacityMap", false);
            glActiveTexture(GL_TEXTURE6);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        
        _mainShader->setUniformBool("isUnlit", meshComp->isGizmo);
        _mainShader->setUniformBool("isDoubleSided", meshComp->doubleSided);
        // _mainShader->setUniformVec3("material.ambient", meshComp->material.ambient);
        // _mainShader->setUniformVec3("material.diffuse", meshComp->material.diffuse);
        // _mainShader->setUniformVec3("material.specular", meshComp->material.specular);
        // _mainShader->setUniformFloat("material.shininess", meshComp->material.shininess);
        _mainShader->setUniformVec3("material.albedo", meshComp->material.albedo);
        _mainShader->setUniformFloat("material.metallic", meshComp->material.metallic);
        _mainShader->setUniformFloat("material.roughness", meshComp->material.roughness);
        _mainShader->setUniformFloat("material.ao", meshComp->material.ao);

        _mainShader->setUniformFloat("material.reflectivity", meshComp->material.reflectivity);
        _mainShader->setUniformFloat("material.refractionIndex", meshComp->material.refractionIndex);
        _mainShader->setUniformFloat("material.transparency", meshComp->material.transparency);

        _mainShader->setUniformBool("useTriplanar", meshComp->useTriplanar);
        _mainShader->setUniformFloat("triplanarScale", meshComp->triplanarScale);
        glm::vec3 flipPos(
            meshComp->triFlipPosX ? 1.0f : 0.0f,
            meshComp->triFlipPosY ? 1.0f : 0.0f,
            meshComp->triFlipPosZ ? 1.0f : 0.0f
        );
        _mainShader->setUniformVec3("triFlipPos", flipPos);
        glm::vec3 flipNeg(
            meshComp->triFlipNegX ? 1.0f : 0.0f,
            meshComp->triFlipNegY ? 1.0f : 0.0f,
            meshComp->triFlipNegZ ? 1.0f : 0.0f
        );
        _mainShader->setUniformVec3("triFlipNeg", flipNeg);
        glm::vec3 rotPos(meshComp->triRotPosX, meshComp->triRotPosY, meshComp->triRotPosZ);
        _mainShader->setUniformVec3("triRotPos", rotPos);
        glm::vec3 rotNeg(meshComp->triRotNegX, meshComp->triRotNegY, meshComp->triRotNegZ);
        _mainShader->setUniformVec3("triRotNeg", rotNeg);

        auto probe = go->getComponent<ReflectionProbeComponent>();
        if (probe && probe->textureID != 0) {
            // 如果这个物体本身就是一个反射探针，我们就使用它生成的 Environment Map
            glActiveTexture(GL_TEXTURE3);
            glBindTexture(GL_TEXTURE_CUBE_MAP, probe->textureID);
            
            _mainShader->setUniformBool("hasEnvMap", true);
            
            // 计算并传递 Box 参数
            // 假设探针中心就是物体中心
            glm::vec3 pPos = go->transform.position;
            // 计算世界坐标下的 AABB
            glm::vec3 bMin = pPos - probe->boxSize * 0.5f;
            glm::vec3 bMax = pPos + probe->boxSize * 0.5f;

            _mainShader->setUniformVec3("probePos", pPos);
            _mainShader->setUniformVec3("probeBoxMin", bMin);
            _mainShader->setUniformVec3("probeBoxMax", bMax);
        } else {
            _mainShader->setUniformBool("hasEnvMap", false);
        }

        // [新增] IBL 强度控制
        // 建议：如果你觉得场景太亮，这里可以传 0.5 或者 0.3
        // 暂时硬编码为 0.5 试试，或者后续在 Inspector 里加个 Scene Settings
        _mainShader->setUniformFloat("iblIntensity", 0.4f);

        // 计算 Model Matrix
        glm::mat4 modelMatrix = go->transform.getLocalMatrix();
        modelMatrix = modelMatrix * meshComp->model->transform.getLocalMatrix();

        _mainShader->setUniformMat4("model", modelMatrix);
        
        meshComp->model->draw();

        if (meshComp->doubleSided) glEnable(GL_CULL_FACE);
    }
}

void Renderer::updateReflectionProbes(const Scene& scene)
{
    // 获取当前视口，以便烘焙完后恢复
    GLint prevViewport[4];
    glGetIntegerv(GL_VIEWPORT, prevViewport);

    // 1. 预先收集光源 (为了简单起见，反射探针渲染时不开启阴影)
    std::vector<LightComponent*> dirLights, pointLights, spotLights;
    std::unordered_map<LightComponent*, int> emptyShadowIndices; // 空 map，表示无阴影

    for (const auto& go : scene.getGameObjects()) {
        auto light = go->getComponent<LightComponent>();
        if (light && light->enabled) {
            if (light->type == LightType::Directional) dirLights.push_back(light);
            else if (light->type == LightType::Point) pointLights.push_back(light);
            else if (light->type == LightType::Spot) spotLights.push_back(light);
        }
    }

    // 遍历所有物体，找带 ReflectionProbeComponent 的
    for (const auto& go : scene.getGameObjects())
    {
        auto probe = go->getComponent<ReflectionProbeComponent>();
        if (!probe) continue;

        // 1. 确保 GL 资源已创建
        probe->initGL();

        // 2. 准备烘焙参数
        glBindFramebuffer(GL_FRAMEBUFFER, probe->fboID);
        glViewport(0, 0, probe->resolution, probe->resolution);

        glm::vec3 probePos = go->transform.position;
        // 投影矩阵：90度 FOV, 1:1 比例, 近裁剪面 0.1, 远裁剪面 100
        glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, 100.0f);

        // 3. 朝 6 个方向渲染
        // OpenGL Cubemap 面顺序: +X, -X, +Y, -Y, +Z, -Z
        std::vector<glm::mat4> shadowViews;
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3(-1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  1.0f,  0.0f), glm::vec3(0.0f,  0.0f,  1.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f, -1.0f,  0.0f), glm::vec3(0.0f,  0.0f, -1.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  0.0f,  1.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  0.0f, -1.0f), glm::vec3(0.0f, -1.0f,  0.0f)));

        for (int i = 0; i < 6; ++i)
        {
            // 将 FBO 颜色附件绑定到 Cubemap 的当前面
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
                                   GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, probe->textureID, 0);
            
            // 清屏 (注意：这里不需要 glClearColor 设置太亮，否则缝隙会明显)
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            // A. 画天空盒
            // 注意：DrawSkybox 需要去平移的 View 矩阵
            glm::mat4 viewNoTrans = glm::mat4(glm::mat3(shadowViews[i])); 
            drawSkybox(viewNoTrans, shadowProj);

            // B. 画场景物体
            // 关键：传入 go.get() 作为 excludeObject，防止画自己
            drawSceneObjects(scene, shadowViews[i], shadowProj, probePos, 
                             dirLights, pointLights, spotLights, emptyShadowIndices, 
                             go.get());
        }

        // 6个面都画完了，生成 Mipmap
        glBindTexture(GL_TEXTURE_CUBE_MAP, probe->textureID);
        glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
    }

    // 恢复状态
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);
}
```

./engine/renderer.h:
```
#pragma once

#include <memory>
#include <vector>
#include <unordered_map>
#include <glad/gl.h>

#include "scene.h"
#include "base/camera.h"
#include "base/glsl_program.h"
#include "outline_pass.h"
#include "geometry_factory.h"
#include "shadow_map_pass.h"
#include "point_shadow_pass.h"

class Renderer
{
public:
    Renderer();
    ~Renderer();

    // 初始化 Shader、天空盒、网格等资源
    void init();

    // 调整大小 (通知 OutlinePass 等)
    void onResize(int width, int height);

    // 核心渲染函数
    // targetFBO: 传入 0 渲染到屏幕，传入 FBO ID 渲染到纹理
    // selectedObj: 如果非空，则绘制描边 (Editor 模式用)
    void render(const Scene& scene, Camera* camera, 
                GLuint targetFBO, int width, int height,
                float contentScale, 
                GameObject* selectedObj = nullptr);

private:
    // --- Shader 资源 ---
    std::unique_ptr<GLSLProgram> _mainShader;
    std::unique_ptr<GLSLProgram> _gridShader;
    std::unique_ptr<GLSLProgram> _skyboxShader;
    
    std::unique_ptr<ShadowMapPass> _shadowPass;
    std::unique_ptr<PointShadowPass> _pointShadowPass;

    // --- 全局模型 ---
    std::shared_ptr<Model> _gridPlane;
    std::shared_ptr<Model> _skyboxCube;

    // --- Render Pass ---
    std::unique_ptr<OutlinePass> _outlinePass;

    // --- 内部绘制函数 ---
    void drawSkybox(const glm::mat4& view, const glm::mat4& proj);
    void drawGrid(const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos);
    void drawSceneObjects(const Scene& scene, const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos, 
                          const std::vector<LightComponent*>& dirLights,
                          const std::vector<LightComponent*>& pointLights,
                          const std::vector<LightComponent*>& spotLights,
                          const std::unordered_map<LightComponent*, int>& shadowIndices,
                          const GameObject* excludeObject = nullptr);
    // 更新场景中的所有反射探针
    void updateReflectionProbes(const Scene& scene);
};
```

./engine/resource_manager.cpp:
```
#include "resource_manager.h"
#include "obj_loader.h"
#include <iostream>
#include <algorithm>

ResourceManager& ResourceManager::Get()
{
    static ResourceManager instance;
    return instance;
}

void ResourceManager::setProjectRoot(const std::string& rootPath)
{
    _projectRoot = rootPath;
    
    // 确保路径以分隔符结尾 (Windows '\' 或 Linux '/')
    if (!_projectRoot.empty() && _projectRoot.back() != '/' && _projectRoot.back() != '\\') {
        _projectRoot += "/";
    }

    // 设置完路径后，立即重新扫描
    scanDirectory(_projectRoot);
    
    // 清空旧缓存 (可选，切换项目时应该清空)
    _modelCache.clear();
}

std::string ResourceManager::getFullPath(const std::string& relativePath)
{
    // 如果已经是绝对路径，直接返回
    if (std::filesystem::path(relativePath).is_absolute()) {
        return relativePath;
    }
    return _projectRoot + relativePath;
}

// scanDirectory 里的逻辑稍微改一下，确保存储的是“相对路径”
void ResourceManager::scanDirectory(const std::string& rootDir)
{
    _fileList.clear();
    namespace fs = std::filesystem;
    if (rootDir.empty() || !fs::exists(rootDir) || !fs::is_directory(rootDir)) return;

    for (const auto& entry : fs::recursive_directory_iterator(rootDir))
    {
        if (entry.is_regular_file())
        {
            std::string ext = entry.path().extension().string();
            std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
            
            bool isModel = (ext == ".obj");
            bool isTexture = (ext == ".png" || ext == ".jpg" || ext == ".jpeg" || ext == ".bmp" || ext == ".tga");

            if (isModel || isTexture)
            {
                std::string filename = entry.path().filename().string();
                
                std::string storePath;
                try {
                    // 尝试计算相对路径
                    storePath = fs::relative(entry.path(), rootDir).string();
                } catch (const fs::filesystem_error& e) {
                    // 如果无法计算相对路径（比如跨盘符），则退化为存储绝对路径
                    storePath = entry.path().string();
                }
                std::replace(storePath.begin(), storePath.end(), '\\', '/');
                
                _fileList.push_back({filename, storePath});
            }
        }
    }
}

std::shared_ptr<Model> ResourceManager::getModel(const std::string& pathKey, bool useFlatShade, const std::string& subMeshName)
{
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    std::string cacheKey = cleanPath;
    if (useFlatShade) cacheKey += ":useFlatShade";
    if (!subMeshName.empty()) cacheKey += ":" + subMeshName;

    // 1. 检查缓存 (Key 是相对路径，比如 "assets/sphere.obj")
    auto it = _modelCache.find(cacheKey);
    if (it != _modelCache.end())
    {
        return it->second;
    }

    // 2. 缓存未命中，准备加载
    // [核心修复] 获取硬盘上的绝对路径
    std::string fullPath = getFullPath(cleanPath);

    if (!std::filesystem::exists(fullPath)) {
        std::cerr << "[ResourceManager] Error: File not found: " << fullPath << std::endl;
        return nullptr; // 或者返回一个紫黑格子的 "ErrorModel"
    }

    // [调试] 打印一下路径，确认拼对了吗
    // std::cout << "Loading Model: " << fullPath << std::endl;

    try {
        MeshData data = OBJLoader::load(fullPath, useFlatShade, subMeshName);
        if (data.vertices.empty()) return nullptr;

        std::shared_ptr<Model> newModel = std::make_shared<Model>(data.vertices, data.indices);
        
        _modelCache[cacheKey] = newModel;
        return newModel;
    }
    catch (std::exception& e) {
        std::cerr << "[ResourceManager] Failed to load model: " << e.what() << std::endl;
        return nullptr;
    }
}

std::shared_ptr<ImageTexture2D> ResourceManager::getTexture(const std::string& pathKey)
{
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    std::string cacheKey = cleanPath;

    // 1. 查缓存
    auto it = _textureCache.find(cleanPath);
    if (it != _textureCache.end()) {
        return it->second;
    }

    // 2. 加载
    std::string fullPath = getFullPath(cleanPath);
    if (!std::filesystem::exists(fullPath)) {
        std::cerr << "[ResourceManager] Error: Texture not found: " << fullPath << std::endl;
        return nullptr;
    }

    try {
        // ImageTexture2D 构造函数会抛出异常如果加载失败
        auto newTex = std::make_shared<ImageTexture2D>(fullPath);
        _textureCache[cacheKey] = newTex;
        return newTex;
    }
    catch (std::exception& e) {
        std::cerr << "[ResourceManager] Failed to load texture: " << e.what() << std::endl;
        return nullptr;
    }
}

void ResourceManager::injectCache(const std::string& pathKey, const std::string& subMeshName, bool useFlatShade, std::shared_ptr<Model> model)
{
    if (!model) return;

    // 1. 标准化路径
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    // 2. 生成 Cache Key
    std::string cacheKey = cleanPath;
    if (useFlatShade) cacheKey += ":useFlatShade";
    if (!subMeshName.empty()) cacheKey += ":" + subMeshName;

    // 3. 存入缓存
    _modelCache[cacheKey] = model;
    
    std::cout << "[ResourceManager] Injected cache: " << cacheKey << std::endl;
}

std::shared_ptr<Model> ResourceManager::findModel(const std::string& pathKey, bool useFlatShade, const std::string& subMeshName)
{
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    std::string cacheKey = cleanPath;
    if (useFlatShade) cacheKey += ":useFlatShade";
    if (!subMeshName.empty()) cacheKey += ":" + subMeshName;

    auto it = _modelCache.find(cacheKey);
    if (it != _modelCache.end()) {
        return it->second;
    }
    return nullptr;
}
```

./engine/resource_manager.h:
```
#pragma once

#include <string>
#include <unordered_map>
#include <memory>
#include <vector>
#include <filesystem>
#include "engine/model.h"
#include "base/texture2d.h"

class ResourceManager
{
public:
    // 单例访问
    static ResourceManager& Get();

    // 设置项目根目录 (比如 "D:/MyGraphicsProject/")
    void setProjectRoot(const std::string& rootPath);
    
    // 获取项目根目录
    std::string getProjectRoot() const { return _projectRoot; }

    // 获取完整路径 (用于加载)
    std::string getFullPath(const std::string& relativePath);

    // 加载或获取已缓存的模型
    // path: 相对路径，例如 "obj/bunny.obj"
    std::shared_ptr<Model> getModel(const std::string& pathKey, bool useFlatShade, const std::string& subMeshName = "");

    // 加载或获取已缓存的纹理
    std::shared_ptr<ImageTexture2D> getTexture(const std::string& pathKey);

    // 扫描资源目录下所有的 .obj 文件 (用于 UI 显示)
    // rootDir: 资源根目录，例如 "../../media/"
    void scanDirectory(const std::string& rootDir);

    // 获取扫描到的文件列表 (文件名, 相对路径)
    const std::vector<std::pair<std::string, std::string>>& getFileList() const { return _fileList; }

    // 手动将已加载的模型注入缓存
    void injectCache(const std::string& pathKey, const std::string& subMeshName, bool useFlatShade, std::shared_ptr<Model> model);

    // 仅检查缓存中是否存在，不触发加载
    std::shared_ptr<Model> findModel(const std::string& pathKey, bool useFlatShade, const std::string& subMeshName = "");

    void shutdown() {
        _modelCache.clear(); // 强制释放所有 Model shared_ptr
        _textureCache.clear();
    }

private:
    ResourceManager() = default;

    std::string _projectRoot = ""; // 默认为空

    // 模型缓存：key=相对路径, value=模型指针
    std::unordered_map<std::string, std::shared_ptr<Model>> _modelCache;

    // 纹理缓存
    std::unordered_map<std::string, std::shared_ptr<ImageTexture2D>> _textureCache;

    // 扫描到的文件列表
    std::vector<std::pair<std::string, std::string>> _fileList;
};
```

./engine/scene.cpp:
```
#include "scene.h"
#include "resource_manager.h" // 如果需要加载默认图标
#include "obj_loader.h"

#include <fstream>
#include <iomanip>
#include <iostream>

GameObject* Scene::createCube()
{
    auto go = new GameObject("Cube");
    // 使用 GeometryFactory 创建
    auto meshComp = go->addComponent<MeshComponent>(GeometryFactory::createCube());
    
    // 初始化默认参数
    meshComp->material.albedo = glm::vec3(0.8f); 
    meshComp->material.roughness = 0.5f;
    meshComp->material.metallic = 0.0f;
    meshComp->material.ao = 1.0f;

    // 存入容器
    _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    return go;
}

GameObject* Scene::createPointLight()
{
    auto go = new GameObject("Point Light");
    auto lightComp = go->addComponent<LightComponent>(LightType::Point);
    lightComp->color = glm::vec3(1.0f, 1.0f, 0.0f);
    lightComp->range = 10.0f;

    // 光源可视化 (Gizmo)
    auto meshComp = go->addComponent<MeshComponent>(GeometryFactory::createSphere(0.2f), true);
    meshComp->shapeType = MeshShapeType::Sphere;
    meshComp->params.radius = 0.2f;
    meshComp->material.albedo = lightComp->color;

    _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    return go;
}

void Scene::createDefaultScene()
{
    // 创建默认的平行光 (Sun)
    auto sun = new GameObject("Directional Light");
    auto lightComp = sun->addComponent<LightComponent>(LightType::Directional);
    
    sun->transform.rotationEuler = glm::vec3(-50.0f, -30.0f, 0.0f);
    sun->transform.setRotation(sun->transform.rotationEuler);

    // 尝试加载 Gizmo 图标
    try {
        std::string arrowPath = "media/obj/arrow.obj";
        auto arrowModel = ResourceManager::Get().getModel(arrowPath, false);
        if (arrowModel) {
            auto arrowMesh = sun->addComponent<MeshComponent>(arrowModel, true);
            arrowMesh->shapeType = MeshShapeType::CustomOBJ;
            strcpy(arrowMesh->params.objPath, arrowPath.c_str());
            sun->transform.scale = glm::vec3(0.5f);
        }
    } catch (...) {}

    _gameObjects.push_back(std::unique_ptr<GameObject>(sun));
}

void Scene::markForDestruction(GameObject* go)
{
    // 检查是否已经在队列中，防止重复添加
    if (std::find(_killQueue.begin(), _killQueue.end(), go) == _killQueue.end()) {
        _killQueue.push_back(go);
    }
}

void Scene::destroyMarkedObjects()
{
    if (_killQueue.empty()) return;

    for (GameObject* go : _killQueue)
    {
        // 执行真正的物理删除
        _gameObjects.erase(
            std::remove_if(_gameObjects.begin(), _gameObjects.end(),
                [go](const std::unique_ptr<GameObject>& p) { 
                    return p.get() == go; 
                }),
            _gameObjects.end());
    }
    _killQueue.clear();
}

void Scene::exportToOBJ(const std::string& filename)
{
    std::ofstream out(filename);
    if (!out.is_open())
    {
        std::cerr << "Failed to open file for export: " << filename << std::endl;
        return;
    }

    out << "# Exported Scene\n";
    
    // 全局顶点偏移量 (OBJ 索引从 1 开始)
    uint32_t globalVertexOffset = 1; 

    for (const auto& go : _gameObjects)
    {
        // 1. 获取网格组件
        auto meshComp = go->getComponent<MeshComponent>();
        if (!meshComp || !meshComp->enabled || !meshComp->model) continue;

        const auto& vertices = meshComp->model->getVertices();
        const auto& indices = meshComp->model->getIndices();

        if (vertices.empty() || indices.empty()) continue;

        // 写入对象名称
        out << "o " << go->name << "_" << go->getInstanceID() << "\n";

        // 2. 计算变换矩阵
        glm::mat4 modelMat = go->transform.getLocalMatrix();
        // 还要叠加上 Model 自身的变换 (如果有的话，通常 Model 自带变换是单位矩阵，但也可能不是)
        modelMat = modelMat * meshComp->model->transform.getLocalMatrix();

        // 法线矩阵 (用于正确变换法线，处理非均匀缩放)
        glm::mat3 normalMat = glm::mat3(glm::transpose(glm::inverse(modelMat)));

        // 3. 写入顶点数据 (v, vt, vn)
        for (const auto& v : vertices)
        {
            // --- 顶点位置 (转换到世界空间) ---
            glm::vec4 worldPos = modelMat * glm::vec4(v.position, 1.0f);
            out << "v " << std::fixed << std::setprecision(6) 
                << worldPos.x << " " << worldPos.y << " " << worldPos.z << "\n";

            // --- 纹理坐标 (直接输出) ---
            out << "vt " << v.texCoord.x << " " << v.texCoord.y << "\n";

            // --- 法线 (转换到世界空间并归一化) ---
            glm::vec3 worldNorm = glm::normalize(normalMat * v.normal);
            out << "vn " << worldNorm.x << " " << worldNorm.y << " " << worldNorm.z << "\n";
        }

        // 4. 写入面数据 (f v/vt/vn)
        // 注意：OBJ 索引是从 1 开始的全局索引
        for (size_t i = 0; i < indices.size(); i += 3)
        {
            uint32_t idx0 = indices[i]     + globalVertexOffset;
            uint32_t idx1 = indices[i + 1] + globalVertexOffset;
            uint32_t idx2 = indices[i + 2] + globalVertexOffset;

            // 格式: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
            // 这里我们假设 v, vt, vn 的索引是相同的 (因为我们的 Mesh 结构体就是这样存的)
            out << "f " 
                << idx0 << "/" << idx0 << "/" << idx0 << " "
                << idx1 << "/" << idx1 << "/" << idx1 << " "
                << idx2 << "/" << idx2 << "/" << idx2 << "\n";
        }

        // 更新偏移量
        globalVertexOffset += (uint32_t)vertices.size();
    }

    out.close();
    std::cout << "Scene exported successfully to " << filename << std::endl;
}

void Scene::importSceneFromOBJ(const std::string& filepath)
{
    auto cachedSingleModel = ResourceManager::Get().findModel(filepath, false, "");

    if (cachedSingleModel)
    {
        std::string name = std::filesystem::path(filepath).stem().string();
        
        auto go = new GameObject(name);
        
        // 直接复用指针
        auto meshComp = go->addComponent<MeshComponent>(cachedSingleModel);
        meshComp->shapeType = MeshShapeType::CustomOBJ;

        // 填充参数
        strncpy(meshComp->params.objPath, filepath.c_str(), sizeof(meshComp->params.objPath) - 1);
        meshComp->params.objPath[sizeof(meshComp->params.objPath) - 1] = '\0';
        
        // 因为是复用 Single Mesh，我们无法获知文件内部原本的 Group Name，只能用文件名代替
        strncpy(meshComp->params.subMeshName, name.c_str(), sizeof(meshComp->params.subMeshName) - 1);
        meshComp->params.subMeshName[sizeof(meshComp->params.subMeshName) - 1] = '\0';

        // 智能 UV 检测 (查询模型本身)
        if (!cachedSingleModel->hasUVs()) {
            meshComp->useTriplanar = true;
            meshComp->triplanarScale = 0.2f;
        } else {
            meshComp->useTriplanar = false;
        }

        _gameObjects.push_back(std::unique_ptr<GameObject>(go));

        // [重要] 注册别名缓存
        // 这样下次如果你尝试获取 "filepath:filename"，也能命中这个缓存
        ResourceManager::Get().injectCache(filepath, name, false, cachedSingleModel);

        std::cout << "[Scene] Fast-Import (Cache Hit): " << name << " (0ms)" << std::endl;
        return; // <--- 直接结束，不再执行下面的解析
    }

    // 1. 调用多网格加载器
    // 这里的 false 表示不强制 Split Vertices (Smooth Shading)，保留 OBJ 原貌
    // 如果你希望导入的模型默认都是 Low-Poly 风格，可以传 true
    std::vector<SubMesh> meshes;
    try {
        meshes = OBJLoader::loadScene(filepath, false);
    }
    catch (const std::exception& e) {
        std::cerr << "[Scene] Import failed: " << e.what() << std::endl;
        return;
    }

    if (meshes.empty()) {
        std::cout << "[Scene] No meshes found in " << filepath << std::endl;
        return;
    }

    // 如果场景里只有一个物体，说明它和 Import Single Mesh 的结果在几何上是完全等价的。
    // 我们应该让它们共享内存。
    bool isSingleObjectScene = (meshes.size() == 1);
    
    // 如果只有 1 个物体，先尝试去 ResourceManager 找 "单体 Key" (无 subMeshName 后缀的 Key)
    std::shared_ptr<Model> existingSingleModel = nullptr;
    if (isSingleObjectScene) {
        // 这里的第三个参数传 ""，即查找 "filepath" 对应的缓存
        existingSingleModel = ResourceManager::Get().findModel(filepath, false, "");
    }

    // 2. 为每个 SubMesh 创建 GameObject
    for (const auto& subMesh : meshes)
    {
        auto go = new GameObject(subMesh.name);
        
        // 创建新模型
        auto model = std::make_shared<Model>(subMesh.vertices, subMesh.indices);
        
        // 1. 注册标准 SubMesh 缓存
        ResourceManager::Get().injectCache(filepath, subMesh.name, false, model);

        // 2. 如果这是唯一的物体，顺便注册 "Single Mesh" 缓存
        if (isSingleObjectScene) {
            ResourceManager::Get().injectCache(filepath, "", false, model);
        }

        auto meshComp = go->addComponent<MeshComponent>(model);
        meshComp->shapeType = MeshShapeType::CustomOBJ;
        
        strncpy(meshComp->params.objPath, filepath.c_str(), sizeof(meshComp->params.objPath) - 1);
        meshComp->params.objPath[sizeof(meshComp->params.objPath) - 1] = '\0';

        strncpy(meshComp->params.subMeshName, subMesh.name.c_str(), sizeof(meshComp->params.subMeshName) - 1);
        meshComp->params.subMeshName[sizeof(meshComp->params.subMeshName) - 1] = '\0';
        
        if (!subMesh.hasUVs) {
            meshComp->useTriplanar = true;
            meshComp->triplanarScale = 0.2f; 
        } else {
            meshComp->useTriplanar = false;
        }

        _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    }
    
    std::cout << "[Scene] Imported and Parsed " << meshes.size() << " objects from " << filepath << std::endl;
}

void Scene::importSingleMeshFromOBJ(const std::string& filepath)
{
    // 1. 从路径提取文件名作为物体名称 (例如 "C:/Assets/Chair.obj" -> "Chair")
    std::string name = std::filesystem::path(filepath).stem().string();
    if (name.empty()) name = "Imported Mesh";

    // 通过 ResourceManager 获取模型
    // 这里的第三个参数传 "" (空字符串)，表示我们要获取“整个文件”对应的模型
    // ResourceManager 会先查缓存，如果 importScene 之前注入过 "" 对应的 Key，这里直接命中，耗时 0ms
    std::shared_ptr<Model> model = ResourceManager::Get().getModel(filepath, false, "");

    if (!model) {
        // 如果 ResourceManager 返回空，说明文件不存在或解析失败（它内部已经打印了错误日志）
        return;
    }

    // 3. 创建 GameObject
    auto go = new GameObject(name);

    // 直接使用获取到的 model
    auto meshComp = go->addComponent<MeshComponent>(model);
    
    // 设置类型为 CustomOBJ，这样 Inspector 会显示文件路径槽
    meshComp->shapeType = MeshShapeType::CustomOBJ;

    // 5. 记录文件路径
    strncpy(meshComp->params.objPath, filepath.c_str(), sizeof(meshComp->params.objPath) - 1);
    meshComp->params.objPath[sizeof(meshComp->params.objPath) - 1] = '\0';

    // Single Mesh 模式下，subMeshName 应该为空
    // 这样下次点击 Flat Shade 时，Inspector 传给 ResourceManager 的也是空名，依然能命中缓存
    memset(meshComp->params.subMeshName, 0, sizeof(meshComp->params.subMeshName));

    // 7. [智能 UV 检测]
    // 如果加载的数据里没有 UV，自动开启 Triplanar Mapping
    if (!model->hasUVs()) {
        meshComp->useTriplanar = true;
        meshComp->triplanarScale = 0.2f; 
    } else {
        meshComp->useTriplanar = false;
    }

    // 8. 加入场景列表
    _gameObjects.push_back(std::unique_ptr<GameObject>(go));

    std::cout << "[Scene] Imported single mesh: " << name << " (Cached: " << (model ? "Yes" : "No") << ")" << std::endl;
}
```

./engine/scene.h:
```
#pragma once

#include <vector>
#include <memory>
#include <algorithm>
#include "scene_object.h" // 根据你的实际路径调整
#include "geometry_factory.h"

class Scene
{
public:
    Scene() = default;
    ~Scene() = default;

    // --- 对象管理 ---
    
    // 获取所有对象 (供 Renderer 遍历)
    const std::vector<std::unique_ptr<GameObject>>& getGameObjects() const { return _gameObjects; }

    // 添加一个已经创建好的对象
    void addGameObject(std::unique_ptr<GameObject> go) {
        _gameObjects.push_back(std::move(go));
    }

    // 删除指定对象
    void removeGameObject(GameObject* go) {
        _gameObjects.erase(
            std::remove_if(_gameObjects.begin(), _gameObjects.end(),
                [go](const std::unique_ptr<GameObject>& p) { return p.get() == go; }),
            _gameObjects.end());
    }

    // 清空场景
    void clear() { _gameObjects.clear(); }

    // --- 工厂方法 (从 SceneRoaming 迁移过来的逻辑) ---
    
    // 创建默认立方体
    GameObject* createCube();
    
    // 创建点光源
    GameObject* createPointLight();

    // 创建默认场景 (比如初始化一个太阳)
    void createDefaultScene();

    void markForDestruction(GameObject* go);

    bool isMarkedForDestruction(GameObject* go) const {
        if (!go) return false;
        // 检查指针是否存在于 _killQueue 中
        return std::find(_killQueue.begin(), _killQueue.end(), go) != _killQueue.end();
    }

    void destroyMarkedObjects();

    // 导出当前场景为 OBJ
    void exportToOBJ(const std::string& filename);

    // 从 OBJ 导入场景（多个物体）
    void importSceneFromOBJ(const std::string& filepath);
    // 从 OBJ 导入单体
    void importSingleMeshFromOBJ(const std::string& filepath);

private:
    std::vector<std::unique_ptr<GameObject>> _gameObjects;

    std::vector<GameObject*> _killQueue;
};
```

./engine/scene_object.cpp:
```
#include "scene_object.h"
#include <glad/gl.h> // 只有这里需要包含 OpenGL 头文件，净化了头文件
#include <iostream>

// ==========================================
// IDGenerator
// ==========================================
int IDGenerator::generate() {
    static std::atomic<int> counter{ 1 };
    return counter.fetch_add(1);
}

// ==========================================
// Component
// ==========================================
Component::Component() : _instanceId(IDGenerator::generate()) {}

// ==========================================
// MeshComponent
// ==========================================
MeshComponent::MeshComponent(std::shared_ptr<Model> m, bool gizmo)
    : model(m), isGizmo(gizmo) {}

void MeshComponent::setMesh(std::shared_ptr<Model> newModel) {
    if (newModel) model = newModel;
}

// ==========================================
// LightComponent
// ==========================================
LightComponent::LightComponent(LightType t) : type(t) {}

// ==========================================
// ReflectionProbeComponent
// ==========================================
ReflectionProbeComponent::~ReflectionProbeComponent() {
    if (textureID) glDeleteTextures(1, &textureID);
    if (fboID) glDeleteFramebuffers(1, &fboID);
    if (rboID) glDeleteRenderbuffers(1, &rboID);
}

void ReflectionProbeComponent::initGL() {
    if (textureID != 0) return; // 已初始化

    // 1. 创建 Cubemap 纹理
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);
    for (unsigned int i = 0; i < 6; ++i) {
        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, 
                     resolution, resolution, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    // 2. 创建 FBO
    glGenFramebuffers(1, &fboID);
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);

    // 3. 创建深度缓冲 (RBO)
    glGenRenderbuffers(1, &rboID);
    glBindRenderbuffer(GL_RENDERBUFFER, rboID);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, resolution, resolution);
    
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboID);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::ReflectionProbe:: Framebuffer is not complete!" << std::endl;

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// ==========================================
// GameObject
// ==========================================
GameObject::GameObject(const std::string &n) : name(n), _instanceId(IDGenerator::generate()) {}

void GameObject::removeComponent(Component *comp)
{
    components.erase(
        std::remove_if(components.begin(), components.end(),
                        [comp](const std::unique_ptr<Component> &p)
                        { return p.get() == comp; }),
        components.end());
}
```

./engine/scene_object.h:
```
#pragma once

#include <vector>
#include <memory>
#include <string>
#include <algorithm>
#include <iostream>
#include <atomic>

#include "base/transform.h"
#include "base/texture2d.h"
#include "engine/model.h"
#include "light_structs.h"

// 前置声明
class GameObject;

enum class MeshShapeType
{
    Cube,
    Sphere,
    Cylinder,
    Cone,
    Prism,   // 多面棱柱
    Frustum, // 多面棱台
    Plane,
    CustomOBJ // 自定义 OBJ 文件
};

// ==========================================
// 组件类型枚举 (用于运行时识别，替代复杂的 dynamic_cast)
// ==========================================
enum class ComponentType
{
    MeshRenderer,
    Light,
    ReflectionProbe
};

enum class LightType
{
    Directional,
    Point,
    Spot
};

// 定义一个结构体来保存生成参数，防止每次切换丢失
struct MeshParams
{
    // 通用
    float size = 1.0f;
    float radius = 0.5f;
    float height = 1.0f;

    // 平面
    float width = 10.0f;
    float depth = 10.0f;

    // 圆柱/球/圆锥
    int slices = 32;
    int stacks = 16;

    // 棱柱/棱台
    float topRadius = 0.5f;
    float bottomRadius = 1.0f;
    int sides = 6; // 默认六棱柱

    // OBJ
    char objPath[256] = "";

    // 子网格名称过滤器
    // 如果为空，加载整个文件；如果不为空，只加载匹配该名称的 group/object/material
    char subMeshName[128] = "";
};

// ==========================================
// 0. 辅助：ID 生成器
// ==========================================
class IDGenerator {
public:
    static int generate();
};

// ==========================================
// 1. 组件基类
// ==========================================
class Component
{
public:
    GameObject *owner = nullptr;
    bool enabled = true;

    Component();

    virtual ~Component() = default;

    int getInstanceID() const { return _instanceId; }

    // 纯虚函数：获取类型
    virtual ComponentType getType() const = 0;

protected:
    int _instanceId;
};

// ==========================================
// 2. 网格渲染组件
// ==========================================
class MeshComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::MeshRenderer;

    std::shared_ptr<Model> model;
    std::shared_ptr<ImageTexture2D> diffuseMap; // 漫反射贴图
    std::shared_ptr<ImageTexture2D> normalMap; // 法线贴图
    std::shared_ptr<ImageTexture2D> ormMap; // ORM 贴图 (R=AO, G=Roughness, B=Metallic)
    std::shared_ptr<ImageTexture2D> emissiveMap; // 自发光贴图
    std::shared_ptr<ImageTexture2D> opacityMap; // 透明度贴图
    Material material;

    // 是否是Gizmo (编辑器辅助物体，如灯泡图标)，渲染时不受光照影响
    bool isGizmo = false;
    
    // 是否双面渲染 (默认 false，Plane 需要设为 true)
    bool doubleSided = false;

    // 是否使用硬棱角
    bool useFlatShade = false;

    // Texture设置
    bool useTriplanar = false; // 是否开启三向映射
    float triplanarScale = 1.0f; // 纹理平铺缩放大小
    bool triFlipPosX = false; 
    bool triFlipNegX = false;
    bool triFlipPosY = false;
    bool triFlipNegY = false;
    bool triFlipPosZ = false;
    bool triFlipNegZ = false;
    float triRotPosX = 0.0f;
    float triRotPosY = 0.0f;
    float triRotPosZ = 0.0f;
    float triRotNegX = 0.0f;
    float triRotNegY = 0.0f;
    float triRotNegZ = 0.0f;

    // 法线贴图设置
    float normalStrength = 1.0f;
    bool flipNormalY = false;

    // 自发光贴图设置
    glm::vec3 emissiveColor = glm::vec3(0.0f); // 默认为黑色(不发光)
    float emissiveStrength = 1.0f;             // 发光强度

    // 透明的贴图设置
    float alphaCutoff = 0.5f; // 低于此值的像素将被丢弃

    MeshShapeType shapeType = MeshShapeType::Cube;
    MeshParams params;

    MeshComponent(std::shared_ptr<Model> m, bool gizmo = false);

    ComponentType getType() const override { return Type; }

    void setMesh(std::shared_ptr<Model> newModel);
};

// ==========================================
// 3. 光照组件
// ==========================================


class LightComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::Light;

    LightType type;
    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;

    // 阴影开关
    // 默认为 true，方便起见，但通常只有 Directional 会用到
    bool castShadows = true;

    // 衰减
    // float constant = 1.0f;
    // float linear = 0.09f;
    // float quadratic = 0.032f;
    float range = 10.0f; // 光照有效半径 (米)

    // 聚光
    float cutOff = glm::cos(glm::radians(12.5f));
    float outerCutOff = glm::cos(glm::radians(17.5f));

    // 阴影投射时的剔除面
    // GL_BACK (0x0405): 剔除背面 (默认，适合闭合物体，解决漏光)
    // GL_FRONT (0x0404): 剔除正面 (适合解决 Shadow Acne，Unity/UE常用技巧)
    unsigned int shadowCullFace = GL_BACK;

    // Unity 风格的阴影参数
    // Depth Bias: 对应 Unity 的 "Bias"，通常很小 (0.001 ~ 0.05)
    float shadowBias = 0.0010f; 
    
    // Normal Bias: 对应 Unity 的 "Normal Bias"，收缩模型的程度 (0.0 ~ 3.0)
    // 我们的单位是世界坐标单位，所以默认值设小一点，比如 0.02
    float shadowNormalBias = 0.00f;

    // 阴影艺术控制
    float shadowStrength = 1.0f; // 0=无阴影, 1=全黑
    float shadowRadius = 0.05f;  // 控制 PCF 采样范围 (软阴影程度)

    LightComponent(LightType t);

    ComponentType getType() const override { return Type; }
};

// ==========================================
// 4. 反射探针组件
// ==========================================
class ReflectionProbeComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::ReflectionProbe;

    int resolution = 2048;
    unsigned int textureID = 0;
    unsigned int fboID = 0;
    unsigned int rboID = 0;
    bool isDirty = true;
    // 影响范围/房间大小 (默认 10x10x10 的房间)
    glm::vec3 boxSize = glm::vec3(10.0f, 10.0f, 10.0f);

    ReflectionProbeComponent() = default;
    ~ReflectionProbeComponent(); // 析构移到 cpp (因为它包含 glDelete)

    void initGL(); // 核心逻辑移到 cpp
    ComponentType getType() const override { return Type; }
};

// ==========================================
// 5. 游戏对象
// ==========================================
class GameObject
{
public:
    std::string name;
    Transform transform;
    std::vector<std::unique_ptr<Component>> components;

    GameObject(const std::string &n);

    int getInstanceID() const { return _instanceId; }

    template <typename T, typename... Args>
    T *addComponent(Args &&...args)
    {
        auto comp = std::make_unique<T>(std::forward<Args>(args)...);
        comp->owner = this;
        T *ptr = comp.get();
        components.push_back(std::move(comp));
        return ptr;
    }

    template <typename T>
    T *getComponent()
    {
        for (auto &comp : components)
        {
            if (comp->getType() == T::Type)
            {
                // 安全的向下转型 (因为我们已经确认了类型)
                return static_cast<T *>(comp.get());
            }
        }
        return nullptr;
    }

    void removeComponent(Component *comp);

private:
    int _instanceId;
};
```

./engine/shadow_map_pass.cpp:
```
#include "shadow_map_pass.h"
#include <iostream>

ShadowMapPass::ShadowMapPass(int resolution, int maxLights) 
    : _resolution(resolution), _maxLights(maxLights)
{
    // 定义级联层级 (分割距离)
    // 实际层级数 = _cascadeLevels.size() + 1
    // 例如: [10, 50, 200, 800, 2000] -> 5个分割点 -> 6层级联
    _cascadeLevels = { 10.0f, 50.0f, 200.0f, 800.0f, 2000.0f };
    
    _layerCountPerLight = (int)_cascadeLevels.size() + 1;

    // 预分配矩阵空间: 灯光数 * 每灯层数
    _lightSpaceMatrices.resize(_maxLights * _layerCountPerLight);

    initShader();
    initFBO();
}

ShadowMapPass::~ShadowMapPass()
{
    if (_fbo) glDeleteFramebuffers(1, &_fbo);
    if (_depthMap) glDeleteTextures(1, &_depthMap);
}

void ShadowMapPass::initFBO()
{
    glGenFramebuffers(1, &_fbo);
    
    glGenTextures(1, &_depthMap);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _depthMap); // 绑定为数组纹理

    // 分配 3D 内存
    // 总层数 = 最大灯光数 * 每个灯光的级联数
    int totalLayers = _maxLights * _layerCountPerLight;

    glTexImage3D(
        GL_TEXTURE_2D_ARRAY, 0, GL_DEPTH_COMPONENT32F, 
        _resolution, _resolution, totalLayers, 
        0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL
    );
    
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

    // 边界颜色设为 1.0 (最大深度，即无阴影)
    constexpr float borderColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    glTexParameterfv(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, borderColor);

    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);
    
    // 将 Texture Array 的第 0 层附加到 FBO，但这只是暂时的
    // 在渲染循环中，我们会动态改变 attachment
    glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _depthMap, 0, 0);
    
    // 我们不需要颜色缓冲，只记录深度
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
    
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::ShadowMapFBO:: Framebuffer is not complete!" << std::endl;
        
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void ShadowMapPass::initShader()
{
    // 极简 Vertex Shader：把顶点变换到光空间
    const char* vsCode = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;

        uniform mat4 lightSpaceMatrix;
        uniform mat4 model;
        uniform float normalBias;

        void main() {
            // 1. 计算世界空间位置
            vec3 posWS = vec3(model * vec4(aPos, 1.0));
            
            // 2. 计算世界空间法线 (简化计算，假设没有非均匀缩放，或者在CPU传NormalMatrix)
            // 为了性能，且在ShadowPass，我们简单用 model 旋转部分
            vec3 normWS = normalize(mat3(model) * aNormal);

            // 3. [核心] 应用 Normal Bias
            // 沿着法线反方向向内收缩顶点
            // 加上光线方向的修正：只有当表面朝向光源时才需要收缩 (可选，Unity的做法比较复杂，这里用最简单的收缩)
            posWS -= normWS * normalBias;

            gl_Position = lightSpaceMatrix * vec4(posWS, 1.0);
        }
    )";

    // Empty Fragment Shader：不需要做任何事，深度写入是自动的
    const char* fsCode = R"(
        #version 330 core
        void main() {
            // gl_FragDepth = gl_FragCoord.z;
        }
    )";

    _depthShader.reset(new GLSLProgram);
    _depthShader->attachVertexShader(vsCode);
    _depthShader->attachFragmentShader(fsCode);
    _depthShader->link();
}

void ShadowMapPass::render(const Scene& scene, const std::vector<ShadowCasterInfo>& casters, Camera* camera)
{
    // 1. 重置矩阵列表
    // 注意：我们不 clear() 而是 resize，或者直接覆盖，保持大小一致
    // 如果实际灯光数少于 maxLights，后面的矩阵可以是单位矩阵或无效值
    int requiredSize = _maxLights * _layerCountPerLight;
    if (_lightSpaceMatrices.size() != requiredSize) {
        _lightSpaceMatrices.resize(requiredSize);
    }
    
    // 获取相机参数
    float camNear = 0.1f;
    float camFar = 1000.0f;
    if (auto pCam = dynamic_cast<PerspectiveCamera*>(camera)) {
        camNear = pCam->znear;
        camFar = pCam->zfar;
    } else if (auto oCam = dynamic_cast<OrthographicCamera*>(camera)) {
        camNear = oCam->znear;
        camFar = oCam->zfar;
    }

    // 2. 准备渲染
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);
    glViewport(0, 0, _resolution, _resolution);
    _depthShader->use();

    // 为了安全，先清除所有层（或者只清除用到的层）
    // 为了性能，我们可以在下面的循环中 glClear，但需要注意 GL 状态
    // 这里最简单的方式是清除整个 FBO，但 FBO 绑定的是 Layer，所以无法一次性清除 Array
    // 必须在循环里 Clear

    int lightCount = std::min((int)casters.size(), _maxLights);

    // --- 双重循环：遍历所有光源 ---
    for (int lightIdx = 0; lightIdx < lightCount; ++lightIdx)
    {
        const auto& caster = casters[lightIdx];

        // 设置当前光源的参数
        _depthShader->setUniformFloat("normalBias", caster.shadowNormalBias);
        glEnable(GL_CULL_FACE);
        glCullFace(caster.cullFaceMode);

        // --- 遍历级联 ---
        for (int cascadeIdx = 0; cascadeIdx < _layerCountPerLight; ++cascadeIdx)
        {
            float prevSplit = (cascadeIdx == 0) ? camNear : _cascadeLevels[cascadeIdx - 1];
            float currSplit = (cascadeIdx < _cascadeLevels.size()) ? _cascadeLevels[cascadeIdx] : camFar;

            // 1. 计算矩阵
            glm::mat4 matrix = getLightSpaceMatrix(prevSplit, currSplit, caster.direction, camera);
            
            // 2. 存储矩阵到扁平数组
            // 索引 = 光源Index * 每光层数 + 当前层
            int globalLayerIdx = lightIdx * _layerCountPerLight + cascadeIdx;
            _lightSpaceMatrices[globalLayerIdx] = matrix;

            // 3. 绑定 FBO 到对应的 Texture Layer
            glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _depthMap, 0, globalLayerIdx);
            
            // 4. 清除当前层的深度缓冲
            glClear(GL_DEPTH_BUFFER_BIT);

            // 5. 提交矩阵并绘制
            _depthShader->setUniformMat4("lightSpaceMatrix", matrix);

            // 绘制场景
            for (const auto& go : scene.getGameObjects()) {
                auto meshComp = go->getComponent<MeshComponent>();
                if (!meshComp || !meshComp->enabled) continue;
                if (meshComp->isGizmo) continue;

                glm::mat4 model = go->transform.getLocalMatrix();
                // 叠加 model 自身的 local matrix (如果有)
                if (meshComp->model) {
                     model = model * meshComp->model->transform.getLocalMatrix();
                     _depthShader->setUniformMat4("model", model);
                     meshComp->model->draw();
                }
            }
        }
    }

    // 恢复状态
    glCullFace(GL_BACK);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

std::vector<glm::vec4> ShadowMapPass::getFrustumCornersWorldSpace(const glm::mat4& proj, const glm::mat4& view)
{
    const auto inv = glm::inverse(proj * view);
    
    std::vector<glm::vec4> frustumCorners;
    for (unsigned int x = 0; x < 2; ++x) {
        for (unsigned int y = 0; y < 2; ++y) {
            for (unsigned int z = 0; z < 2; ++z) {
                const glm::vec4 pt = inv * glm::vec4(
                    2.0f * x - 1.0f,
                    2.0f * y - 1.0f,
                    2.0f * z - 1.0f,
                    1.0f);
                frustumCorners.push_back(pt / pt.w);
            }
        }
    }
    return frustumCorners;
}

glm::mat4 ShadowMapPass::getLightSpaceMatrix(const float nearPlane, const float farPlane, const glm::vec3& lightDir, Camera* camera)
{
    // 1. 根据相机类型计算当前切片的投影矩阵
    glm::mat4 proj;
    if (auto pCam = dynamic_cast<PerspectiveCamera*>(camera)) {
        proj = glm::perspective(pCam->fovy, pCam->aspect, nearPlane, farPlane);
    } 
    else if (auto oCam = dynamic_cast<OrthographicCamera*>(camera)) {
        proj = glm::ortho(oCam->left, oCam->right, oCam->bottom, oCam->top, nearPlane, farPlane);
    }
    else {
        return glm::mat4(1.0f);
    }
    
    // 2. 获取该切片的世界空间 8 个角点
    auto corners = getFrustumCornersWorldSpace(proj, camera->getViewMatrix());

    // 3. 计算几何中心
    glm::vec3 center = glm::vec3(0, 0, 0);
    for (const auto& v : corners) {
        center += glm::vec3(v);
    }
    center /= corners.size();

    // 4. 构建光照视图矩阵
    // 注意：这里的位置其实不重要，重要的是方向。我们将位置定在中心逆光方向远处
    const auto lightView = glm::lookAt(center - lightDir, center, glm::vec3(0.0f, 1.0f, 0.0f));

    // 5. 计算 AABB
    float minX = std::numeric_limits<float>::max();
    float maxX = std::numeric_limits<float>::lowest();
    float minY = std::numeric_limits<float>::max();
    float maxY = std::numeric_limits<float>::lowest();
    float minZ = std::numeric_limits<float>::max();
    float maxZ = std::numeric_limits<float>::lowest();

    for (const auto& v : corners)
    {
        const auto trf = lightView * v;
        minX = std::min(minX, trf.x);
        maxX = std::max(maxX, trf.x);
        minY = std::min(minY, trf.y);
        maxY = std::max(maxY, trf.y);
        minZ = std::min(minZ, trf.z);
        maxZ = std::max(maxZ, trf.z);
    }

    // [修复] 扩展 Z 轴范围
    // 在 View Space 中，物体通常在 -Z 方向。
    // maxZ 是"最近"的点（数值最大，例如 -10），minZ 是"最远"的点（数值最小，例如 -100）。
    // glm::ortho 的 near/far 通常是正数距离。
    // 所以 distance_near = -maxZ, distance_far = -minZ。

    // 为了捕捉位于切片前方（light 和切片之间）的遮挡物（如树干投射阴影到地面），
    // 我们需要把 Near Plane 大幅向光源方向拉伸。
    // 我们也把 Far Plane 稍微推远一点以防万一。
    float zMult = 10.0f;
if (nearPlane > 50.0f) {
    // 如果是远处的层级 (黄色/蓝色)，不要扩展那么多，甚至不扩展
    zMult = 1.0f; 
}
    if (minZ < 0) minZ *= zMult; else minZ /= zMult;
    if (maxZ < 0) maxZ /= zMult; else maxZ *= zMult;
    
    // [修正逻辑]
    // 上面原来的代码逻辑有问题。让我们用更稳健的方式：
    // 我们把 Near/Far 设置得非常大，覆盖整个场景可能范围。
    // 因为是正交投影，Z 范围大不会导致精度严重下降（不像透视投影）。
    
    // 简单的方案：以 Slice 边界为基础，向前后各扩展 200 米
    float zNear = -maxZ; 
    float zFar  = -minZ;

    // 6. 纹素对齐 (Texel Snapping) - 解决闪烁
    float unitPerPixel = (maxX - minX) / _resolution;
    float offsetX = fmod(minX, unitPerPixel);
    float offsetY = fmod(minY, unitPerPixel);
    minX -= offsetX;
    maxX -= offsetX;
    minY -= offsetY;
    maxY -= offsetY;

    float padding = 5.0f; 
    minX -= padding; maxX += padding;
    minY -= padding; maxY += padding;
    
    // 7. 构建正交投影
    // 注意：glm::ortho(l, r, b, t, zNear, zFar)
    const auto lightProjection = glm::ortho(minX, maxX, minY, maxY, zNear, zFar);

    return lightProjection * lightView;
}
```

./engine/shadow_map_pass.h:
```
#pragma once

#include <glad/gl.h>
#include <memory>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "base/glsl_program.h"
#include "scene.h"
#include "base/camera.h"

struct ShadowCasterInfo {
    glm::vec3 direction;
    float shadowNormalBias;
    unsigned int cullFaceMode;
};

class ShadowMapPass
{
public:
    // resolution: 单张贴图分辨率
    // maxLights: 最大支持的平行光数量
    ShadowMapPass(int resolution = 4096, int maxLights = 4);
    ~ShadowMapPass();

    // 核心渲染函数：接收光源列表
    void render(const Scene& scene, const std::vector<ShadowCasterInfo>& casters, Camera* camera);

    GLuint getDepthMapArray() const { return _depthMap; }

    // 返回所有光源的所有级联矩阵 (展平的一维数组)
    // 布局: [Light0_Casc0, Light0_Casc1..., Light1_Casc0...]
    const std::vector<glm::mat4>& getLightSpaceMatrices() const { return _lightSpaceMatrices; }

    const std::vector<float>& getCascadeLevels() const { return _cascadeLevels; }
    int getCascadeCount() const { return (int)_cascadeLevels.size() + 1; } // +1 因为最后一层是 zFar

private:
    int _resolution;
    int _maxLights;
    int _layerCountPerLight; // cascadeLevels.size() + 1

    GLuint _fbo = 0;
    GLuint _depthMap = 0;
    
    // 存储所有光源的矩阵
    std::vector<glm::mat4> _lightSpaceMatrices;
    std::vector<float> _cascadeLevels; 
    
    std::unique_ptr<GLSLProgram> _depthShader;

    void initFBO();
    void initShader();

    std::vector<glm::vec4> getFrustumCornersWorldSpace(const glm::mat4& proj, const glm::mat4& view);
    
    glm::mat4 getLightSpaceMatrix(const float nearPlane, const float farPlane, const glm::vec3& lightDir, Camera* camera);
};
```

./engine/utils/image_utils.cpp:
```
#include "image_utils.h"
#include <vector>
#include <iostream>
#include <algorithm> // for std::reverse (optional) or manual loop

// 这是一个单头文件库，必须在一个 CPP 文件中定义 IMPLEMENTATION 宏
#include <stb_image_write.h>
#include <glad/gl.h> // 需要包含 OpenGL 头文件以使用 glReadPixels

void ImageUtils::saveScreenshot(const std::string& filename, int width, int height)
{
    if (width <= 0 || height <= 0) return;

    // 1. 分配内存 (RGBA)
    std::vector<unsigned char> pixels(width * height * 4);

    // 2. 读取像素
    // 确保字节对齐
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    // 3. 上下翻转 (OpenGL 左下角 vs 图片 左上角)
    // 这一步是必须的，否则保存出来的图片是倒着的
    int rowSize = width * 4;
    std::vector<unsigned char> flippedPixels(width * height * 4);

    for (int y = 0; y < height; ++y)
    {
        unsigned char* srcRow = pixels.data() + y * rowSize;
        unsigned char* dstRow = flippedPixels.data() + (height - 1 - y) * rowSize;
        memcpy(dstRow, srcRow, rowSize);
    }

    // 4. 判断格式并保存
    bool success = false;
    std::string ext = filename.substr(filename.find_last_of(".") + 1);
    
    if (ext == "png") {
        success = stbi_write_png(filename.c_str(), width, height, 4, flippedPixels.data(), rowSize);
    } else if (ext == "jpg" || ext == "jpeg") {
        success = stbi_write_jpg(filename.c_str(), width, height, 4, flippedPixels.data(), 90); // 90 quality
    } else {
        // 默认存 PNG
        success = stbi_write_png((filename + ".png").c_str(), width, height, 4, flippedPixels.data(), rowSize);
    }

    if (success) {
        std::cout << "[ImageUtils] Screenshot saved to " << filename << std::endl;
    } else {
        std::cerr << "[ImageUtils] Failed to save screenshot: " << filename << std::endl;
    }
}
```

./engine/utils/image_utils.h:
```
#pragma once

#include <string>

class ImageUtils
{
public:
    // 截取当前 OpenGL 绑定的 Framebuffer 到文件
    // width, height: 图像大小
    // filename: 保存路径 (支持 .png, .jpg)
    static void saveScreenshot(const std::string& filename, int width, int height);
};
```

