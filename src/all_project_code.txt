./light_structs.h:
```
#pragma once
#include <glm/glm.hpp>

// 材质属性
struct Material
{
    glm::vec3 ambient = glm::vec3(0.1f);
    glm::vec3 diffuse = glm::vec3(0.7f);
    glm::vec3 specular = glm::vec3(0.5f);
    float shininess = 32.0f;

    float reflectivity = 0.0f;    // 反射强度 (0.0 = 无反射, 1.0 = 全镜面)
    float refractionIndex = 1.0f; // 折射率 (1.0 = 空气, 1.33 = 水, 1.52 = 玻璃, 2.42 = 钻石)
    float transparency = 0.0f;    // 透明度/折射强度 (0.0 = 不透明, 1.0 = 全透明)
};

// 平行光 (太阳光)
struct DirLight
{
    glm::vec3 direction = glm::vec3(-0.2f, -1.0f, -0.3f);
    glm::vec3 color = glm::vec3(1.0f); // 包含强度
    float intensity = 1.0f;
};

// 点光源 (灯泡)
struct PointLight
{
    glm::vec3 position = glm::vec3(0.0f);

    float constant = 1.0f;
    float linear = 0.09f;
    float quadratic = 0.032f;

    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;
};

// 聚光灯 (手电筒)
struct SpotLight
{
    glm::vec3 position = glm::vec3(0.0f);
    glm::vec3 direction = glm::vec3(0.0f, -1.0f, 0.0f);
    float cutOff = glm::cos(glm::radians(12.5f));
    float outerCutOff = glm::cos(glm::radians(17.5f));

    float constant = 1.0f;
    float linear = 0.09f;
    float quadratic = 0.032f;

    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;
};
```

./main.cpp:
```
#include <cstdlib>
#include <iostream>
#include <filesystem>

#include "scene_roaming.h"

std::string getExecutableDir() {
    return std::filesystem::current_path().string(); 
}

Options getOptions(int argc, char* argv[]) {
    Options options;
    options.windowTitle = "Scene Roaming";
    options.windowWidth = 1920;
    options.windowHeight = 1080;
    options.windowResizable = true;
    options.vSync = true;
    options.msaa = true;
    options.glVersion = {3, 3};
    options.backgroundColor = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);

    std::string exeDir = getExecutableDir();
    options.assetRootDir = exeDir + "/";

    std::cout << "[Info] Asset Root: " << options.assetRootDir << std::endl;

    return options;
}

int main(int argc, char* argv[]) {
    Options options = getOptions(argc, argv);

    try {
        SceneRoaming app(options);
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        exit(EXIT_FAILURE);
    } catch (...) {
        std::cerr << "Unknown exception" << std::endl;
        exit(EXIT_FAILURE);
    }

    return 0;
}
```

./scene_roaming.cpp:
```
#include "imgui.h"
#include "imgui_internal.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"
#include "scene_roaming.h"
#include "ImGuiFileDialog.h"
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/easing.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <filesystem>
#include <algorithm> // for std::sort

#include "engine/utils/image_utils.h"

// 辅助结构：用于排序轴的绘制顺序
struct GizmoAxisData {
    glm::vec3 dir;       // 原始方向
    ImU32 mainColor;     // 主颜色 (外圈或实心)
    ImU32 fillColor;     // 填充颜色 (仅负轴使用，稍淡)
    char label;          // 标签文字 ('X', 'Y', 'Z' 或 0)
    bool isNegative;     // 是否是负轴
    float zDepth;        // 变换后的深度 (用于排序)
    ImVec2 screenPos;    // 变换后的屏幕位置
};

void SceneRoaming::updateContentScale()
{
    float x, y;
    glfwGetWindowContentScale(_window, &x, &y);
    // 取较大的那个作为主缩放比例
    _contentScale = (x > y) ? x : y;
}

SceneRoaming::SceneRoaming(const Options &options) : Application(options)
{
    glfwSetInputMode(_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

    // 在初始化 ImGui 之前，必须先获取当前显示器的缩放比例！
    // 否则 initImGui 里的字体加载逻辑会一直使用默认的 1.0f
    updateContentScale();

    // 标记项目未打开
    _isProjectOpen = false;

    // 1. 在做任何场景加载之前，先设置资源根目录！
    // 这样 ResourceManager 才知道去哪里找文件
    ResourceManager::Get().setProjectRoot(options.assetRootDir);

    // =================================================
    // [新逻辑] 初始化子系统
    // =================================================
    _scene = std::make_unique<Scene>();
    _renderer = std::make_unique<Renderer>();

    // 1. 初始化渲染资源 (Shader, Skybox 等)
    _renderer->init();

    // 2. 初始化场景数据 (创建默认灯光等)
    _scene->createDefaultScene();

    // 初始化面板
    _sceneViewPanel = std::make_unique<SceneViewPanel>();
    _hierarchyPanel = std::make_unique<HierarchyPanel>();
    _inspectorPanel = std::make_unique<InspectorPanel>();
    _projectPanel = std::make_unique<ProjectPanel>();

    initImGui();
    // initSceneFBO 不需要在这里调，第一次 renderUI 时会根据窗口大小自动调
}

SceneRoaming::~SceneRoaming()
{
    // 在 OpenGL 上下文销毁前，清空资源缓存
    ResourceManager::Get().shutdown();
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
}

void SceneRoaming::initImGui()
{
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO &io = ImGui::GetIO();
    (void)io;

    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

    ImGui::StyleColorsDark(); // 使用暗色主题

    ImGui_ImplGlfw_InitForOpenGL(_window, true);
    ImGui_ImplOpenGL3_Init("#version 330");

    // --- High DPI 适配逻辑 ---

    // 1. 缩放 UI 样式 (按钮大小、间距等)
    if (_contentScale > 1.0f)
    {
        ImGuiStyle& style = ImGui::GetStyle();
        style.ScaleAllSizes(_contentScale);
    }

    // 2. 缩放字体
    // ImGui 默认字体是位图字体，直接缩放会模糊。
    // 强烈建议加载一个 TTF 字体并指定像素大小。
    // Windows 路径示例 (你可以换成你的项目内的字体路径 "media/fonts/arial.ttf")
    std::string fontPath = getAssetFullPath("media/fonts/Roboto-Regular.ttf");
    // 如果没有字体文件，可以用 Windows 自带的，或者暂时忽略字体清晰度
    // fontPath = "C:\\Windows\\Fonts\\segoeui.ttf"; 
    std::cout << "[Info] Attempting to load font from: " << fontPath << std::endl;
    
    float fontSize = 16.0f * _contentScale; // 基础字号 16

    if (std::filesystem::exists(fontPath)) 
    {
        io.Fonts->AddFontFromFileTTF(fontPath.c_str(), fontSize);
    }
    else
    {
        // 如果找不到字体，使用默认字体并缩放 (可能会模糊)
        io.FontGlobalScale = _contentScale;
    }
}

void SceneRoaming::renderFrame()
{
    int currentW, currentH;
    glfwGetFramebufferSize(_window, &currentW, &currentH);

    // 如果长或宽为0（最小化状态），什么都不做，直接返回
    if (currentW == 0 || currentH == 0) {
        // 稍微休眠一下，避免空转占用 CPU 100%
        // (在 Windows 上可以使用 std::this_thread::sleep_for，或者简单的 return)
        return;
    }

    static bool isFullscreen = false;
    static int lastWindowX, lastWindowY, lastWindowW, lastWindowH;
    if (glfwGetKey(_window, GLFW_KEY_F11) == GLFW_PRESS)
    {
        // 简单的去抖动 (Debounce)，防止一帧多次触发
        static double lastTime = 0.0;
        double now = glfwGetTime();
        if (now - lastTime > 0.2) 
        {
            lastTime = now;
            isFullscreen = !isFullscreen;

            if (isFullscreen)
            {
                // 保存当前窗口位置和大小
                glfwGetWindowPos(_window, &lastWindowX, &lastWindowY);
                glfwGetWindowSize(_window, &lastWindowW, &lastWindowH);

                // 获取主显示器
                GLFWmonitor* monitor = glfwGetPrimaryMonitor();
                const GLFWvidmode* mode = glfwGetVideoMode(monitor);
                
                // 切换到全屏
                glfwSetWindowMonitor(_window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
            }
            else
            {
                // 恢复窗口模式
                glfwSetWindowMonitor(_window, nullptr, lastWindowX, lastWindowY, lastWindowW, lastWindowH, 0);
            }
        }
    }

    updateContentScale();

    // =========================================================
    // 2. 开启 ImGui 新帧 (必须在所有逻辑之前)
    // =========================================================
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    if (ImGui::IsKeyPressed(ImGuiKey_F12, false)) 
    {
        // 直接设置延迟，无需自己写 static bool 防抖
        _screenshotDelay = 1; 
    }

    // 1. 处理输入 (委托给 SceneViewPanel)
    // 它内部会调用 _cameraController->update() 和 handleInput()
    // 需要传入 Scene 指针用于射线检测
    _sceneViewPanel->onInputUpdate(ImGui::GetIO().DeltaTime, _scene.get(), _selectedObject);

    // =========================================================
    // 3. 清理主屏幕 (Back Buffer)
    // =========================================================
    // 注意：这里的 Viewport 是整个窗口的大小，不是 FBO 的大小
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(0, 0, currentW, currentH);
    // 清除为黑色 (ImGui 窗口背后的颜色)
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // =========================================================
    // 4. 执行 UI 逻辑 (并在内部触发 3D 渲染)
    // =========================================================
    // renderUI 会计算布局 -> 调整 FBO -> renderScene -> 提交 ImGui::Image
    renderUI();

    // =========================================================
    // 5. 提交 ImGui 绘制数据
    // =========================================================
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    // 在物理删除之前，检查选中物体是否即将死亡
    if (_scene && _selectedObject)
    {
        // 如果当前选中的物体在删除队列里，说明它将在下面这行代码中变为野指针
        if (_scene->isMarkedForDestruction(_selectedObject))
        {
            _selectedObject = nullptr; // 强制取消选中，保护指针安全
            // 可选：打印一条日志
            std::cout << "[System] Auto-deselected object pending destruction." << std::endl;
        }
    }

    if (_scene) {
        _scene->destroyMarkedObjects();
    }

    if (_screenshotDelay > 0)
    {
        // 倒计时减一
        _screenshotDelay--;
    }
    else if (_screenshotDelay == 0) // 倒计时结束，执行截屏
    {
        int w, h;
        glfwGetFramebufferSize(_window, &w, &h);
        std::string path = ResourceManager::Get().getProjectRoot() + "/screenshot.png";
        
        // 此时这一帧已经是“没有菜单”的全新一帧了
        ImageUtils::saveScreenshot(path, w, h);
        
        // 重置为 -1，停止截屏
        _screenshotDelay = -1;
    }
}

void SceneRoaming::renderUI()
{
    if (!_isProjectOpen)
    {
        renderProjectSelector(); // 阻塞式界面
        ImVec2 maxSize = ImGui::GetIO().DisplaySize;
        ImVec2 minSize = ImVec2(maxSize.x * 0.5f, maxSize.y * 0.5f);

        if (ImGuiFileDialog::Instance()->Display("ChooseDirDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
        {
            if (ImGuiFileDialog::Instance()->IsOk())
            {
                std::string filePathName = ImGuiFileDialog::Instance()->GetCurrentPath();
                if (filePathName.length() < sizeof(_projectPathBuf)) {
                    strcpy(_projectPathBuf, filePathName.c_str());
                }
            }
            ImGuiFileDialog::Instance()->Close();
        }
    } else {
        setupDockspace();

        _sceneViewPanel->onImGuiRender(_scene.get(), _renderer.get(), _selectedObject, _contentScale);

        // 1. Hierarchy
        _hierarchyPanel->onImGuiRender(_scene, _selectedObject); // 传入引用，允许面板修改选中项

        // 2. Inspector
        // 注意：我们需要检测 Inspector 是否删除了物体
        // 如果它删除了，selectedObject 可能会悬空，这里需要一种机制处理
        // 在 InspectorPanel 里我们直接调用了 removeGameObject。
        // 为了安全，我们可以在每帧开始时检查 _selectedObject 是否还在 _scene 里（可选但推荐）
        // 或者简单的：相信用户操作流
        _inspectorPanel->onImGuiRender(_selectedObject, _scene.get());

        // 如果 Inspector 刚刚把物体删了，我们需要把 _selectedObject 置空
        // 我们可以通过检查 Scene 是否还包含它来判断，或者让 Inspector 返回状态
        // 简单的 Hack：如果 _selectedObject 变成了野指针会崩溃。
        // [修正] InspectorPanel 内部做删除时，我们无法立即把这里的指针置空。
        // 建议修改 HierarchyPanel/InspectorPanel 的逻辑，或者：
        // 在 Scene 里加一个 isValid(GameObject*) 函数进行校验。
        // 鉴于目前架构，如果 Inspector 点击删除，下一帧这个指针就失效了。
        // 最简单的修复：给 Inspector 传 _selectedObject 的**引用**，让它在删除后置空！
        
        // 3. Project
        _projectPanel->onImGuiRender();
    }

    // 6. 渲染结束 (保持不变)
    ImGui::Render();
}

void SceneRoaming::setupDockspace()
{
    // =======================================================
    // [核心] 真正的布局重置逻辑 (DockBuilder)
    // =======================================================
    
    // 获取主视口 ID
    ImGuiID dockspace_id = ImGui::GetID("MyDockSpace");

    // 如果需要重置，或者第一次运行且没有 ini 记录
    // (ImGui::DockBuilderGetNode 判断该 ID 是否已存在)
    if (!_isLayoutInitialized || (ImGui::DockBuilderGetNode(dockspace_id) == NULL))
    {
        // 1. 清除当前所有布局
        ImGui::DockBuilderRemoveNode(dockspace_id); 
        
        // 2. 添加一个空的根节点，覆盖整个视口
        ImGui::DockBuilderAddNode(dockspace_id, ImGuiDockNodeFlags_DockSpace);
        ImGui::DockBuilderSetNodeSize(dockspace_id, ImGui::GetMainViewport()->Size);

        // 3. [关键] 切分节点 (Split)
        // 类似于切蛋糕：先切一刀，再在剩下的部分切一刀
        
        ImGuiID dock_main_id = dockspace_id; // 初始 ID
        ImGuiID dock_right_id = 0;
        ImGuiID dock_left_id = 0;
        ImGuiID dock_bottom_id = 0;

        // 第一刀：把右边切出来 (占 20%) -> 放 Inspector
        dock_right_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Right, 0.2f, nullptr, &dock_main_id);
        
        // 第二刀：把左边切出来 (占 20%) -> 放 Hierarchy
        dock_left_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Left, 0.2f, nullptr, &dock_main_id);
        
        // 第三刀：把下面切出来 (占 25%) -> 放 Project
        dock_bottom_id = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Down, 0.25f, nullptr, &dock_main_id);
        
        // 剩下的 dock_main_id 就是中间的部分 -> 放 3D Viewport

        // 4. 将窗口绑定到对应的 ID
        // 注意：这里的字符串必须和你 Begin() 里的名字完全一致！
        ImGui::DockBuilderDockWindow("3D Viewport", dock_main_id);
        ImGui::DockBuilderDockWindow("Scene Hierarchy", dock_left_id);
        ImGui::DockBuilderDockWindow("Inspector", dock_right_id);
        ImGui::DockBuilderDockWindow("Project / Assets", dock_bottom_id);

        // 5. 完成构建
        ImGui::DockBuilderFinish(dockspace_id);

        _isLayoutInitialized = true;
    }

    // =======================================================
    // 正常渲染
    // =======================================================

    // 绑定到我们刚才构建的 ID
    ImGui::DockSpaceOverViewport(dockspace_id, ImGui::GetMainViewport());

    // =======================================================
    // 2. 顶部菜单栏 (可选，模仿 Blender)
    // =======================================================
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            // 导入场景按钮
            if (ImGui::MenuItem("Import as Single Mesh (.obj)"))
            {
                IGFD::FileDialogConfig config;
                config.path = ResourceManager::Get().getProjectRoot();
                ImGuiFileDialog::Instance()->OpenDialog("ImportMeshKey", "Import Single Mesh", ".obj", config);
            }

            if (ImGui::MenuItem("Import as Scene (.obj)"))
            {
                IGFD::FileDialogConfig config;
                config.path = ResourceManager::Get().getProjectRoot();
                
                ImGuiFileDialog::Instance()->OpenDialog("ImportSceneKey", "Import Scene and Split Objects", ".obj", config);
            }

            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Splits the OBJ file into multiple objects based on 'o' or 'g' tags.");
            }

            // 导出场景按钮
            if (ImGui::MenuItem("Export Scene (.obj)"))
            {
                // 1. 构造保存路径 (默认保存到项目根目录)
                // 如果你想做得更高级，可以像 Open Project 那样弹出一个 ImGuiFileDialog
                std::string exportPath = ResourceManager::Get().getProjectRoot() + "/scene_export.obj";
                
                // 2. 执行导出
                if (_scene) {
                    _scene->exportToOBJ(exportPath);
                }
            }

            ImGui::Separator();

            if (ImGui::MenuItem("Save Screenshot (.png)"))
            {
                // 1. 立即关闭当前的 Popup 菜单 (让下一帧不渲染它)
                ImGui::CloseCurrentPopup();

                // 2. 设置延迟帧数
                // 为什么是 2？
                // Frame 0 (当前帧): 菜单还在，逻辑处理完。
                // Frame 1 (下一帧): ImGui 生成了没有菜单的画面，渲染完成 -> 截屏！
                _screenshotDelay = 2; 
            }

            ImGui::Separator();

            if (ImGui::MenuItem("Exit")) glfwSetWindowShouldClose(_window, true);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("View"))
        {
            if (ImGui::MenuItem("Reset Layout")) _isLayoutInitialized = false;
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }

    // 检查并渲染文件对话框
    if (ImGuiFileDialog::Instance()->Display("ImportMeshKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            std::string path = ImGuiFileDialog::Instance()->GetFilePathName();
            // 调用单体加载逻辑 (你现有的 CustomOBJ 逻辑)
            // 这里可以直接调用 Scene 里的辅助函数，或者在这里写逻辑
            // 建议在 Scene 里加一个 importSingleMesh(path)
            if (_scene) {
                _scene->importSingleMeshFromOBJ(path);
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }

    // 这里的 Key "ImportSceneKey" 必须和上面 OpenDialog 里的 Key 一致
    if (ImGuiFileDialog::Instance()->Display("ImportSceneKey"))
    {
        // 如果用户点击了 OK
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            // 获取完整文件路径
            std::string path = ImGuiFileDialog::Instance()->GetFilePathName();
            
            // 调用我们刚刚写好的 Import 逻辑
            if (_scene) {
                _scene->importSceneFromOBJ(path);
            }
        }
        
        // 关闭对话框
        ImGuiFileDialog::Instance()->Close();
    }
}

void SceneRoaming::renderProjectSelector()
{
    // 获取视口中心
    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImVec2 center = viewport->GetCenter();

    // 设定窗口大小
    ImVec2 windowSize(600, 300); // 稍微宽一点，高一点
    ImGui::SetNextWindowPos(center, ImGuiCond_Always, ImVec2(0.5f, 0.5f)); // 真正的屏幕居中
    ImGui::SetNextWindowSize(windowSize);

    ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
    
    // [UI美化] 稍微加点圆角和阴影 (如果支持)
    ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 10.0f);
    ImGui::Begin("Project Setup", nullptr, flags);

    // 垂直居中内容
    float contentHeight = 120.0f; // 估算内容高度
    ImGui::SetCursorPosY((windowSize.y - contentHeight) * 0.5f);

    // 大标题
    ImGui::PushFont(ImGui::GetIO().Fonts->Fonts[0]); // 假设默认字体
    // 如果你有大字体，这里 Push 大字体
    float textWidth = ImGui::CalcTextSize("Select or Create Project Folder").x;
    ImGui::SetCursorPosX((windowSize.x - textWidth) * 0.5f);
    ImGui::Text("Select or Create Project Folder");
    ImGui::PopFont();
    
    ImGui::Dummy(ImVec2(0, 20)); // 间距

    // --- 路径输入行 ---
    // 动态计算宽度：总宽 - 按钮宽 - 间距 - 左右padding
    float padding = 40.0f; // 左右留白
    float btnWidth = 100.0f;
    float spacing = ImGui::GetStyle().ItemSpacing.x;
    float inputWidth = windowSize.x - (padding * 2) - btnWidth - spacing;

    ImGui::SetCursorPosX(padding); // 左对齐开始
    
    // 输入框
    ImGui::PushItemWidth(inputWidth);
    ImGui::InputText("##Path", _projectPathBuf, sizeof(_projectPathBuf));
    ImGui::PopItemWidth();

    ImGui::SameLine();

    // 浏览按钮
    if (ImGui::Button("Browse...", ImVec2(btnWidth, 0)))
    {
        IGFD::FileDialogConfig config;
        config.path = ".";
        ImGuiFileDialog::Instance()->OpenDialog("ChooseDirDlgKey", "Choose Project Directory", nullptr, config);
    }

    ImGui::Dummy(ImVec2(0, 20)); // 间距

    // --- 确认按钮 (居中) ---
    float confirmBtnWidth = 200.0f;
    ImGui::SetCursorPosX((windowSize.x - confirmBtnWidth) * 0.5f);
    
    // [UX] 如果路径为空，禁用按钮
    bool hasPath = strlen(_projectPathBuf) > 0;
    if (!hasPath) ImGui::BeginDisabled();
    
    if (ImGui::Button("Open / Create Project", ImVec2(confirmBtnWidth, 40)))
    {
        std::string path(_projectPathBuf);
        if (!std::filesystem::exists(path)) {
            std::filesystem::create_directories(path);
        }
        ResourceManager::Get().setProjectRoot(path);
        _isProjectOpen = true;
    }
    
    if (!hasPath) ImGui::EndDisabled();

    ImGui::End();
    ImGui::PopStyleVar(); // Pop WindowRounding
}
```

./scene_roaming.h:
```
#pragma once

#include <memory>
#include <vector>
#include <imgui.h>
#include "base/application.h"
#include "base/glsl_program.h"
#include "engine/scene.h"
#include "engine/renderer.h"
#include "editor/editor_camera.h"
#include "editor/panels/hierarchy_panel.h"
#include "editor/panels/inspector_panel.h"
#include "editor/panels/project_panel.h"
#include "editor/panels/scene_view_panel.h"
#include "engine/scene_object.h"
#include "engine/outline_pass.h"
#include "engine/resource_manager.h"

class SceneRoaming : public Application
{
public:
    SceneRoaming(const Options &options);
    ~SceneRoaming();

    void handleInput() override {};
    void renderFrame() override;

private:
    std::unique_ptr<Scene> _scene;       // 负责数据
    std::unique_ptr<Renderer> _renderer; // 负责画画

    std::unique_ptr<SceneViewPanel> _sceneViewPanel;
    std::unique_ptr<HierarchyPanel> _hierarchyPanel;
    std::unique_ptr<InspectorPanel> _inspectorPanel;
    std::unique_ptr<ProjectPanel> _projectPanel;

    // 编辑器状态变量
    bool _isLayoutInitialized = false; // 用于只在第一次运行时设置窗口位置
    bool _isProjectOpen = false;
    char _projectPathBuf[256] = "";
    float _contentScale = 1.0f;

    // 选中状态
    GameObject *_selectedObject = nullptr;

    // UI 相关
    void initImGui();
    void renderUI();
    void renderProjectSelector();
    void setupDockspace();
    void updateContentScale();

    // -1 表示不截屏，>0 表示倒计时
    int _screenshotDelay = -1;
};
```

./editor/editor_camera.cpp:
```
#include "editor_camera.h"
#include "base/camera.h"
#include "engine/scene_object.h" // 为了访问 GameObject 的 Transform
#include <imgui.h>
#include <imgui_internal.h>
#include <GLFW/glfw3.h>
#include <glm/gtx/vector_angle.hpp>
#include <algorithm> // for std::sort

// 那个 GizmoAxisData 结构体也可以搬到这里来
struct GizmoAxisData {
    glm::vec3 dir;       // 原始方向
    ImU32 mainColor;     // 主颜色 (外圈或实心)
    ImU32 fillColor;     // 填充颜色 (仅负轴使用，稍淡)
    char label;          // 标签文字 ('X', 'Y', 'Z' 或 0)
    bool isNegative;     // 是否是负轴
    float zDepth;        // 变换后的深度 (用于排序)
    ImVec2 screenPos;    // 变换后的屏幕位置
};

#include "editor_camera.h"
#include <glm/gtc/matrix_transform.hpp> // for glm::lookAt
#include <glm/gtc/quaternion.hpp>     // for glm::quat_cast

EditorCamera::EditorCamera(int width, int height)
{
    // 1. 计算宽高比 (使用传入的参数)
    float aspect = (float)width / (float)height;
    
    // 2. 初始化相机容器
    _cameras.resize(2);

    constexpr float znear = 0.1f;
    constexpr float zfar = 10000.0f;

    // =============================================
    // Setup Perspective Camera (Index 0)
    // =============================================
    _cameras[0] = std::make_unique<PerspectiveCamera>(glm::radians(60.0f), aspect, znear, zfar);

    // [搬运] 初始状态：看着原点，距离 15 米
    _pivot = glm::vec3(0.0f, 0.5f, 0.0f); // 原 _cameraPivot
    
    // [搬运] 稍微抬高一点角度
    glm::vec3 startPos = glm::vec3(0.0f, 5.0f, 15.0f);
    
    // [搬运] 初始化平滑缩放变量
    _currentOrbitDist = glm::length(startPos - _pivot);
    _targetOrbitDist = _currentOrbitDist;
    
    // [搬运] 设置相机位置
    _cameras[0]->transform.position = startPos;

    // [搬运] 计算初始旋转 (LookAt)
    // 注意：这里需要 include <glm/gtc/matrix_transform.hpp>
    glm::mat4 view = glm::lookAt(_cameras[0]->transform.position, _pivot, glm::vec3(0, 1, 0));
    _cameras[0]->transform.rotation = glm::quat_cast(glm::inverse(view));

    // =============================================
    // Setup Orthographic Camera (Index 1)
    // =============================================
    _cameras[1] = std::make_unique<OrthographicCamera>(-4.0f * aspect, 4.0f * aspect, -4.0f, 4.0f, znear, zfar);
    _cameras[1]->transform.position = glm::vec3(0.0f, 0.0f, 15.0f);
    
    // 默认激活透视相机
    _activeCameraIndex = 0;
}

void EditorCamera::update(float deltaTime)
{
    updateSmoothZoom(deltaTime);
    updateAnimation(deltaTime);
}

// [搬运来源] SceneRoaming::renderUI 中处理窗口大小变化的逻辑
void EditorCamera::onResize(int width, int height)
{
    float aspect = (float)width / (float)height;
    if (auto pCam = dynamic_cast<PerspectiveCamera *>(_cameras[_activeCameraIndex].get())) {
        pCam->aspect = aspect;
    }
    // 如果有正交相机也需要更新
    if (auto oCam = dynamic_cast<OrthographicCamera *>(_cameras[1].get())) {
        oCam->left = -4.0f * aspect;
        oCam->right = 4.0f * aspect;
    }
}

void EditorCamera::handleInput(const glm::vec3& scenePivot)
{
    // 1. [互斥锁] 如果正在拖拽 Gizmo，绝对不要处理相机旋转/平移
    if (_isGizmoDragging) return;

    ImGuiIO& io = ImGui::GetIO();
    
    // 2. 如果 ImGui 想要捕获键盘（例如在输入框打字），不处理快捷键
    if (io.WantCaptureKeyboard) return;

    Camera* cam = getActiveCamera();
    float dt = io.DeltaTime;
    const float friction = 30.0f;

    // =========================================================
    // 输入获取
    // =========================================================
    float dx = io.MouseDelta.x;
    float dy = io.MouseDelta.y;
    float scrollX = io.MouseWheelH;
    float scrollY = io.MouseWheel;

    bool isShift = io.KeyShift;
    bool isCtrl = io.KeyCtrl;
    bool isLMB = io.MouseDown[0];
    bool isRMB = io.MouseDown[1];
    bool isMMB = io.MouseDown[2];

    // =========================================================
    // [Blender 风格] 设备推断逻辑
    // =========================================================
    bool isFractional = (scrollY != 0.0f) && (std::abs(scrollY - std::round(scrollY)) > 0.02f);
    bool hasHorizontal = (scrollX != 0.0f);
    bool isMouseStep = (std::abs(scrollY) >= 0.9f);
    
    // 判定是否为物理鼠标滚轮
    bool isPhysicalMouse = isMouseStep && !hasHorizontal && !isFractional;

    // =========================================================
    // 意图定义
    // =========================================================
    bool intentZoom = false;
    bool intentOrbit = false;
    bool intentPan = false;

    // 缩放：Ctrl + 滚轮/触摸板，或者 物理滚轮直接滚动
    if (isCtrl || (isPhysicalMouse && !isShift)) {
        intentZoom = true;
    }
    // 平移：Shift + 中键/触摸板
    else if (isShift) {
        intentPan = true;
    }
    // 旋转：中键，或者 触摸板双指滑动
    else if (isMMB || (scrollX != 0 || scrollY != 0)) {
        intentOrbit = true;
    }

    // =========================================================
    // 状态更新 (用于控制 Gizmo 显示等)
    // =========================================================
    if (intentPan || intentZoom || intentOrbit)
    {
        _isControlling = true;
    }
    else
    {
        // 如果没有按键，且不是在惯性滑动中（这里简单用按键判断），则标记结束
        if (!isLMB && !isMMB && !isRMB && scrollX == 0 && scrollY == 0) 
        {
            _isControlling = false;
        }
    }

    // =========================================================
    // 执行逻辑
    // =========================================================

    // --- 1. 平移 (Pan) ---
    if (intentPan)
    {
        float sens = 0.002f * _currentOrbitDist;
        glm::vec3 delta(0.0f);
        glm::vec3 right = cam->transform.getRight();
        glm::vec3 up = cam->transform.getUp();

        if (isMMB) { 
            // 鼠标中键拖拽
            delta = (right * -dx * sens) + (up * dy * sens);
        } else {     
            // 触摸板滑动
            float trackpadSens = 5.0f * sens; 
            delta = (right * -scrollX * trackpadSens) + (up * scrollY * trackpadSens);
        }
        
        // 应用平移：相机位置和 Pivot 都要动
        cam->transform.position += delta;
        _pivot += delta; 
    }
    
    // --- 2. 缩放 (Zoom) ---
    else if (intentZoom)
    {
        float zoomFactor = 1.0f;
        float inputVal = scrollY != 0 ? scrollY : scrollX;

        if (isPhysicalMouse) {
            // 物理滚轮：固定步进 (10%)
            zoomFactor = (inputVal > 0) ? 0.9f : 1.1f;
        } else {
            // 触控板捏合：线性平滑缩放
            float safeInput = glm::clamp(inputVal, -2.0f, 2.0f);
            zoomFactor = 1.0f - (safeInput * 0.3f); 
        }

        // 修改目标距离，updateSmoothZoom 会负责插值
        _targetOrbitDist *= zoomFactor;
        if (_targetOrbitDist < 0.1f) _targetOrbitDist = 0.1f;
    }

    // --- 3. 旋转 (Orbit) ---
    else if (intentOrbit)
    {
        float targetDeltaX = 0.0f;
        float targetDeltaY = 0.0f;

        if (isMMB) {
            // 鼠标中键：直接映射
            float mouseSens = 0.0015f; // 可以微调灵敏度
            targetDeltaX = -dx * mouseSens;
            targetDeltaY = -dy * mouseSens;
            
            // 鼠标模式下，直接应用，不使用惯性变量干扰
            // (或者你可以选择让鼠标也有惯性，看手感喜好)
        } else {
            // 触控板：需要惯性平滑
            float trackpadScaleX = 0.15f;
            float trackpadScaleY = 0.12f;
            targetDeltaX = -scrollX * trackpadScaleX;
            targetDeltaY = -scrollY * trackpadScaleY;
            
            // 更新惯性变量
            _smoothOrbitDelta.x = glm::mix(_smoothOrbitDelta.x, targetDeltaX, dt * friction);
            _smoothOrbitDelta.y = glm::mix(_smoothOrbitDelta.y, targetDeltaY, dt * friction);
        }

        // 决定最终的旋转量
        float activeDx = isMMB ? targetDeltaX : _smoothOrbitDelta.x;
        float activeDy = isMMB ? targetDeltaY : _smoothOrbitDelta.y;

        rotateCamera(activeDx, activeDy);
    }
    
    // --- 4. 惯性衰减 ---
    // 即使没有输入，惯性也需要慢慢停下来
    else {
        _smoothOrbitDelta = glm::mix(_smoothOrbitDelta, glm::vec2(0.0f), dt * 30.0f);
        
        // 如果还有残余惯性，继续旋转一点点
        if (glm::length(_smoothOrbitDelta) > 0.001f) {
             rotateCamera(_smoothOrbitDelta.x, _smoothOrbitDelta.y);
             _isControlling = true; // 只要还在转，就算 controlling
        }
    }
}

// ... 依次搬运 rotateCamera, frameObject, updateAnimation 等函数 ...
Ray EditorCamera::screenPointToRay(float mouseX, float mouseY, float viewportX, float viewportY, float viewportW, float viewportH)
{
    // 1. 安全检查
    if (viewportW <= 0 || viewportH <= 0) 
        return Ray(glm::vec3(0), glm::vec3(0,0,1));

    // 2. [新增] 计算局部坐标 (Local Space)
    // 鼠标在整个窗口的坐标 - 视口图片左上角的坐标 = 鼠标在视口内的坐标
    float localX = mouseX - viewportX;
    float localY = mouseY - viewportY;

    // 3. 归一化设备坐标 (NDC: -1 ~ 1)
    float x = (2.0f * localX) / viewportW - 1.0f;
    float y = 1.0f - (2.0f * localY) / viewportH; // OpenGL Y轴向上，屏幕坐标向下，需要翻转

    // 4. 获取当前相机矩阵
    // 注意：这里访问的是 EditorCamera 自己的成员 _cameras
    Camera* cam = _cameras[_activeCameraIndex].get();
    glm::mat4 proj = cam->getProjectionMatrix();
    glm::mat4 view = cam->getViewMatrix();
    
    // 5. 反投影 (Unproject)
    glm::mat4 invVP = glm::inverse(proj * view);
    glm::vec4 screenPos = glm::vec4(x, y, 1.0f, 1.0f);
    glm::vec4 worldPos = invVP * screenPos;

    if (worldPos.w != 0.0f) worldPos /= worldPos.w;

    // 6. 计算方向
    glm::vec3 dir = glm::normalize(glm::vec3(worldPos) - cam->transform.position);

    return Ray(cam->transform.position, dir);
}

// =======================================================================================
// 动画与平滑逻辑
// =======================================================================================

// [搬运来源] SceneRoaming::updateSmoothZoom
// [改动] 参数改为传入 deltaTime，不再依赖 ImGui::GetIO()
void EditorCamera::updateSmoothZoom(float dt)
{
    if (_isAnimating) return;

    float smoothFactor = 10.0f * dt;
    
    if (std::abs(_targetOrbitDist - _currentOrbitDist) < 0.01f) {
        _currentOrbitDist = _targetOrbitDist;
    } else {
        _currentOrbitDist = glm::mix(_currentOrbitDist, _targetOrbitDist, smoothFactor);
    }

    // 根据新的距离更新相机位置
    glm::vec3 dir = glm::normalize(_cameras[_activeCameraIndex]->transform.position - _pivot);
    _cameras[_activeCameraIndex]->transform.position = _pivot + dir * _currentOrbitDist;
}

// [搬运来源] SceneRoaming::startCameraAnimation
// [改动] 变量名 _cameraPivot -> _pivot, activeCameraIndex -> _activeCameraIndex
void EditorCamera::startAnimation(const glm::vec3& targetPos, const glm::quat& targetRot, const glm::vec3& targetPivot)
{
    _animStartPos = _cameras[_activeCameraIndex]->transform.position;
    _animStartPivot = _pivot;
    _animStartRot = _cameras[_activeCameraIndex]->transform.rotation;

    _animTargetPos = targetPos;
    _animTargetPivot = targetPivot;
    _animTargetRot = targetRot;

    // 最短路径检查
    if (glm::dot(_animStartRot, _animTargetRot) < 0.0f)
    {
        _animTargetRot = -_animTargetRot;
    }

    _targetOrbitDist = glm::length(targetPos - targetPivot);

    _animTime = 0.0f;
    _isAnimating = true;
}

// [搬运来源] SceneRoaming::updateCameraAnimation
void EditorCamera::updateAnimation(float dt)
{
    if (!_isAnimating) return;

    _animTime += dt;
    float t = _animTime / _animDuration;
    
    if (t >= 1.0f) {
        t = 1.0f;
        _isAnimating = false;
        // 强制吸附
        _pivot = _animTargetPivot;
        _currentOrbitDist = _targetOrbitDist;
        _cameras[_activeCameraIndex]->transform.position = _animTargetPos;
        _cameras[_activeCameraIndex]->transform.rotation = _animTargetRot;
        return;
    }

    float smoothT = 1.0f - pow(1.0f - t, 4.0f);

    // 插值逻辑
    glm::vec3 currentPivot = glm::mix(_animStartPivot, _animTargetPivot, smoothT);
    _pivot = currentPivot; 

    float startDist = glm::length(_animStartPos - _animStartPivot);
    float targetDist = glm::length(_animTargetPos - _animTargetPivot);
    float currentDist = glm::mix(startDist, targetDist, smoothT);
    _currentOrbitDist = currentDist; 

    glm::quat currentRot = glm::slerp(_animStartRot, _animTargetRot, smoothT);

    glm::vec3 offset = currentRot * glm::vec3(0.0f, 0.0f, 1.0f) * currentDist;
    glm::vec3 currentPos = currentPivot + offset;

    _cameras[_activeCameraIndex]->transform.rotation = currentRot;
    _cameras[_activeCameraIndex]->transform.position = currentPos;
}

// =======================================================================================
// 控制逻辑
// =======================================================================================

// [搬运来源] SceneRoaming::rotateCamera
void EditorCamera::rotateCamera(float dx, float dy)
{
    if (glm::length(glm::vec2(dx, dy)) < 0.00001f) return;

    Camera* cam = _cameras[_activeCameraIndex].get();

    glm::vec3 worldUp = glm::vec3(0, 1, 0);
    glm::vec3 camRight = cam->transform.getRight();

    glm::quat qYaw = glm::angleAxis(dx, worldUp);
    glm::quat qPitch = glm::angleAxis(dy, camRight);
    glm::quat qRotation = qYaw * qPitch;

    glm::vec3 pivotToCam = cam->transform.position - _pivot;
    pivotToCam = qRotation * pivotToCam; 
    cam->transform.position = _pivot + pivotToCam;

    cam->transform.rotation = qRotation * cam->transform.rotation;
    cam->transform.rotation = glm::normalize(cam->transform.rotation);
}

// [搬运来源] SceneRoaming::switchToView
void EditorCamera::switchToView(const glm::vec3& dir)
{
    glm::vec3 targetPos = _pivot + glm::normalize(dir) * _targetOrbitDist; 
    
    glm::vec3 up = glm::vec3(0, 1, 0);
    if (std::abs(dir.y) > 0.9f) {
        up = glm::vec3(0, 0, -1);
    }

    glm::mat4 targetViewMat = glm::lookAt(targetPos, _pivot, up);
    glm::quat targetRot = glm::quat_cast(glm::inverse(targetViewMat));

    startAnimation(targetPos, targetRot, _pivot);
}

// [搬运来源] SceneRoaming::frameSelectedObject
// [改动] 参数改为 GameObject* obj
void EditorCamera::frameObject(GameObject* obj)
{
    if (!obj) return;

    BoundingBox bounds;
    // bool hasBounds = false; // 未使用
    glm::vec3 centerOffset(0.0f); 
    float objectRadius = 1.0f;    

    if (auto mesh = obj->getComponent<MeshComponent>()) {
        bounds = mesh->model->getBoundingBox();
        // hasBounds = true;

        glm::vec3 localCenter = (bounds.min + bounds.max) * 0.5f;
        centerOffset = obj->transform.rotation * (localCenter * obj->transform.scale);

        glm::vec3 size = (bounds.max - bounds.min) * obj->transform.scale;
        objectRadius = glm::length(size) * 0.5f; 
    }

    glm::vec3 targetPivot = obj->transform.position + centerOffset;

    if (objectRadius < 0.5f) objectRadius = 0.5f;
    
    float halfFov = glm::radians(30.0f);
    float dist = objectRadius / glm::sin(halfFov);
    dist *= 1.3f; 

    _targetOrbitDist = dist; 

    glm::vec3 fixedDir = glm::normalize(glm::vec3(0.0f, 1.0f, 1.0f));
    glm::vec3 targetPos = targetPivot + fixedDir * dist;

    glm::vec3 targetUp = glm::vec3(0, 1, 0);
    glm::mat4 targetView = glm::lookAt(targetPos, targetPivot, targetUp);
    glm::quat targetRot = glm::quat_cast(glm::inverse(targetView));

    startAnimation(targetPos, targetRot, targetPivot);
}

// =======================================================================================
// Gizmo 绘制与交互
// =======================================================================================

// [搬运来源] SceneRoaming::renderUI 中 "{ // [新增] 绘制 View Gizmo ... }" 代码块
// [改动] 封装了原本在 renderUI 里的交互逻辑
bool EditorCamera::drawViewGizmo(const glm::vec2& viewportPos, const glm::vec2& viewportSize)
{
    float gizmoSize = 65.0f; 
    float safePadding = gizmoSize + 15.0f + 30.0f;

    ImVec2 gizmoCenter = ImVec2(
        viewportPos.x + viewportSize.x - safePadding,
        viewportPos.y + safePadding
    );

    glm::mat4 view = _cameras[_activeCameraIndex]->getViewMatrix();
    bool isGizmoHovered = false;

    // 调用内部绘制函数 (对应旧的 drawViewGizmo)
    glm::vec3 clickedDir = drawGizmoInternal(
        ImGui::GetWindowDrawList(), 
        glm::vec2(gizmoCenter.x, gizmoCenter.y), 
        gizmoSize,
        isGizmoHovered
    );

    // --- 拖拽逻辑 ---
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) && isGizmoHovered && glm::length(clickedDir) < 0.1f)
    {
        _isGizmoDragging = true;
    }

    if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
    {
        _isGizmoDragging = false;
    }

    if (_isGizmoDragging)
    {
        ImVec2 delta = ImGui::GetIO().MouseDelta;
        float sens = 0.005f; 
        rotateCamera(-delta.x * sens, -delta.y * sens);
    }

    // --- 点击吸附逻辑 (Snap View) ---
    if (!_isGizmoDragging && glm::length(clickedDir) > 0.1f)
    {
        float dist = glm::length(_cameras[_activeCameraIndex]->transform.position - _pivot);
        if (dist < 1.0f) dist = 5.0f;

        glm::vec3 targetPos = _pivot + clickedDir * dist;
        glm::vec3 up = glm::vec3(0, 1, 0); 
        glm::vec3 currentDir = glm::normalize(_cameras[_activeCameraIndex]->transform.position - _pivot);
        glm::vec3 currentUp = _cameras[_activeCameraIndex]->transform.getUp();

        // 逻辑完全搬运自 SceneRoaming
        if (abs(clickedDir.y) > 0.9f) {
            float invert = (currentUp.y < -0.1f) ? -1.0f : 1.0f;
            if (abs(currentDir.z) > abs(currentDir.x)) {
                float sign = (currentDir.z >= 0.0f) ? 1.0f : -1.0f;
                if (clickedDir.y > 0) up = glm::vec3(0, 0, -1.0f * sign * invert);
                else                  up = glm::vec3(0, 0, 1.0f * sign * invert);
            } else {
                float sign = (currentDir.x >= 0.0f) ? 1.0f : -1.0f;
                if (clickedDir.y > 0) up = glm::vec3(-1.0f * sign * invert, 0, 0);
                else                  up = glm::vec3(1.0f * sign * invert, 0, 0);
            }
        }
        else {
            float dot = glm::dot(clickedDir, currentUp);
            bool isBackFlip  = dot > 0.5f;   
            bool isFrontFlip = dot < -0.5f;  
            bool isTopHemi    = currentDir.y > 0.1f;  
            bool isAlreadyUpsideDown = currentUp.y < -0.1f;

            if (isBackFlip) {
                if (isTopHemi) up = glm::vec3(0, -1, 0); 
                else           up = glm::vec3(0, 1, 0);  
            }
            else if (isFrontFlip) {
                if (isTopHemi) up = glm::vec3(0, 1, 0);
                else           up = glm::vec3(0, -1, 0); 
            }
            else {
                if (isAlreadyUpsideDown) up = glm::vec3(0, -1, 0); 
                else                     up = glm::vec3(0, 1, 0);
            }
        }

        glm::mat4 targetViewMat = glm::lookAt(targetPos, _pivot, up); 
        glm::quat targetRot = glm::quat_cast(glm::inverse(targetViewMat));
        startAnimation(targetPos, targetRot, _pivot);
    }

    return isGizmoHovered;
}

// [搬运来源] SceneRoaming::drawViewGizmo (最原始的那个绘制函数)
// [改动] 参数简化，不再传入 cameraPos 等，因为类成员里有
glm::vec3 EditorCamera::drawGizmoInternal(ImDrawList* drawList, const glm::vec2& centerPos, float axisLength, bool& outGizmoHovered)
{
    ImVec2 center(centerPos.x, centerPos.y);

    float circleRadius = 15.0f;    
    float lineThickness = 4.0f;   
    float outlineThickness = 3.0f; 
    float fontSize = 23.0f;
    float bgRadius = axisLength + circleRadius * 2.0f;

    ImU32 colR = IM_COL32(240, 55, 82, 255);
    ImU32 colG = IM_COL32(110, 159, 29, 255);
    ImU32 colB = IM_COL32(47, 132, 229, 255);
    ImU32 colR_Trans = IM_COL32(240, 55, 82, 100);
    ImU32 colG_Trans = IM_COL32(110, 159, 29, 100);
    ImU32 colB_Trans = IM_COL32(47, 132, 229, 100);
    ImU32 colText = IM_COL32(0, 0, 0, 255);
    ImU32 colBgHover = IM_COL32(255, 255, 255, 30); 

    ImVec2 mousePos = ImGui::GetMousePos();
    float distFromCenter = sqrtf(powf(mousePos.x - center.x, 2) + powf(mousePos.y - center.y, 2));
    outGizmoHovered = (distFromCenter < bgRadius);

    if (outGizmoHovered || _isGizmoDragging) {
        drawList->AddCircleFilled(center, bgRadius, colBgHover);
    }

    std::vector<GizmoAxisData> axes = {
        { {1,0,0},  colR, 0,          'X', false },
        { {0,1,0},  colG, 0,          'Y', false },
        { {0,0,1},  colB, 0,          'Z', false },
        { {-1,0,0}, colR, colR_Trans, 0,   true },
        { {0,-1,0}, colG, colG_Trans, 0,   true },
        { {0,0,-1}, colB, colB_Trans, 0,   true }
    };

    glm::mat4 viewMatrix = _cameras[_activeCameraIndex]->getViewMatrix();
    glm::mat3 viewRot = glm::mat3(viewMatrix);
    
    for (auto& axis : axes) {
        glm::vec3 localDir = viewRot * axis.dir;
        axis.zDepth = localDir.z;
        axis.screenPos = ImVec2(
            center.x + localDir.x * axisLength,
            center.y - localDir.y * axisLength
        );
    }

    std::sort(axes.begin(), axes.end(), [](const GizmoAxisData& a, const GizmoAxisData& b) {
        return a.zDepth < b.zDepth;
    });

    bool isMouseClicked = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
    const GizmoAxisData* hoveredAxis = nullptr;

    ImFont* font = ImGui::GetFont();
    for (const auto& axis : axes)
    {
        float dist = sqrtf(powf(mousePos.x - axis.screenPos.x, 2) + powf(mousePos.y - axis.screenPos.y, 2));
        if (dist <= circleRadius + 2.0f) hoveredAxis = &axis;
        bool isHovered = (hoveredAxis == &axis);
        if (_isGizmoDragging) isHovered = false;

        if (!axis.isNegative)
        {
            if (isHovered) drawList->AddCircle(axis.screenPos, circleRadius + 2.0f, IM_COL32(255,255,255,150), 0, 2.0f);
            glm::vec2 dir2D = glm::vec2(axis.screenPos.x - center.x, axis.screenPos.y - center.y);
            float len = glm::length(dir2D);
            if (len > circleRadius) 
            {
                dir2D /= len;
                ImVec2 lineEndPos = ImVec2(
                    axis.screenPos.x - dir2D.x * (circleRadius - 1.5f), 
                    axis.screenPos.y - dir2D.y * (circleRadius - 1.5f)
                );
                drawList->AddLine(center, lineEndPos, axis.mainColor, lineThickness);
            }
            drawList->AddCircleFilled(axis.screenPos, circleRadius - 1.0f, axis.mainColor);
            drawList->AddCircle(axis.screenPos, circleRadius, axis.mainColor, 0, outlineThickness);

            char text[2] = { axis.label, '\0' };
            ImVec2 textSize = font->CalcTextSizeA(fontSize, FLT_MAX, 0.0f, text);
            ImVec2 opticalOffset = ImVec2(0.4f, 0.4f); 
            ImVec2 textPos = ImVec2(
                axis.screenPos.x - textSize.x * 0.5f + opticalOffset.x,
                axis.screenPos.y - textSize.y * 0.5f + opticalOffset.y
            );
            drawList->AddText(font, fontSize, textPos, colText, text);
        }
        else
        {
            if (isHovered) drawList->AddCircle(axis.screenPos, circleRadius + 2.0f, IM_COL32(255,255,255,150), 0, 2.0f);
            drawList->AddCircleFilled(axis.screenPos, circleRadius - 1.0f, axis.fillColor);
            drawList->AddCircle(axis.screenPos, circleRadius, axis.mainColor, 0, outlineThickness);
        }
    }

    if (_isGizmoDragging) return glm::vec3(0,0,0);
    if (isMouseClicked && hoveredAxis) return hoveredAxis->dir;

    return glm::vec3(0, 0, 0); 
}
```

./editor/editor_camera.h:
```
#pragma once

#include <memory>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>
#include "base/camera.h"
#include "engine/physics_utils.h"

// 前置声明
class GameObject; 
class Scene;
struct ImDrawList;

class EditorCamera
{
public:
    EditorCamera(int width, int height);
    ~EditorCamera() = default;

    // --- 核心更新 ---
    // 每帧调用，处理输入和平滑插值
    void update(float deltaTime);
    
    // 当窗口大小改变时调用
    void onResize(int width, int height);

    // --- 输入处理 ---
    // 接管 ImGui 的输入
    void handleInput(const glm::vec3& scenePivot = glm::vec3(0.0f));

    // --- 功能接口 ---
    Camera* getActiveCamera() const { return _cameras[_activeCameraIndex].get(); }
    
    // 获取当前的 Pivot (注视点)
    glm::vec3 getPivot() const { return _pivot; }

    // 聚焦物体 (对应原来的 frameSelectedObject)
    void frameObject(GameObject* obj);

    // 切换视角 (对应原来的 switchToView)
    void switchToView(const glm::vec3& dir);

    // 屏幕射线 (对应原来的 screenPointToRay)
    // 需要传入视口的位置和大小 (ImGui Image 的 Rect)
    Ray screenPointToRay(float mouseX, float mouseY, float viewportX, float viewportY, float viewportW, float viewportH);

    // 绘制右上角的 View Gizmo (返回是否被 Hover)
    bool drawViewGizmo(const glm::vec2& viewportPos, const glm::vec2& viewportSize);

    // 用于外部查询是否正在操作相机 (SceneRoaming 可以用它来决定是否绘制选择框等)
    bool isControlling() const { return _isControlling; }

private:
    // --- 内部状态 (从 SceneRoaming 搬过来的) ---
    std::vector<std::unique_ptr<Camera>> _cameras;
    int _activeCameraIndex = 0;

    glm::vec3 _pivot = glm::vec3(0.0f);
    glm::vec2 _smoothOrbitDelta = glm::vec2(0.0f);
    
    // 平滑缩放变量
    float _currentOrbitDist = 15.0f;
    float _targetOrbitDist = 15.0f;

    // 动画变量
    bool _isAnimating = false;
    float _animTime = 0.0f;
    float _animDuration = 0.3f;
    glm::vec3 _animStartPos, _animTargetPos;
    glm::vec3 _animStartPivot, _animTargetPivot;
    glm::quat _animStartRot, _animTargetRot;

    // Gizmo 拖拽状态
    bool _isGizmoDragging = false;
    bool _isControlling = false;

    // --- 内部辅助函数 ---
    void rotateCamera(float dx, float dy);
    void startAnimation(const glm::vec3& targetPos, const glm::quat& targetRot, const glm::vec3& targetPivot);
    void updateAnimation(float dt);
    void updateSmoothZoom(float dt);
    
    // 那个很长的绘制 Gizmo 的函数
    glm::vec3 drawGizmoInternal(ImDrawList* drawList, const glm::vec2& center, float size, bool& outHovered);
};
```

./editor/panels/hierarchy_panel.cpp:
```
#include "hierarchy_panel.h"
#include <imgui.h>

HierarchyPanel::HierarchyPanel() : Panel("Scene Hierarchy") {}

void HierarchyPanel::onImGuiRender(const std::unique_ptr<Scene>& scene, GameObject*& selectedObject)
{
    if (!_isOpen) return;

    // 注意：ImGui::Begin 需要传入指针来控制关闭按钮
    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    // 1. 添加物体按钮
    if (ImGui::Button("+ Add Object"))
        ImGui::OpenPopup("AddObjPopup");
    
    if (ImGui::BeginPopup("AddObjPopup"))
    {
        if (ImGui::MenuItem("Cube")) {
            scene->createCube(); 
        }
        if (ImGui::MenuItem("Point Light")) {
            scene->createPointLight();
        }
        ImGui::EndPopup();
    }

    ImGui::Separator();

    // 2. 遍历物体列表
    const auto& objects = scene->getGameObjects();
    
    for (int i = 0; i < objects.size(); ++i)
    {
        auto &go = objects[i];
        
        // 使用 Selectable 模拟列表项
        ImGui::PushID(go->getInstanceID());
        if (ImGui::Selectable(go->name.c_str(), selectedObject == go.get()))
        {
            selectedObject = go.get();
        }
        ImGui::PopID();
    }

    // 3. 点击空白处取消选择
    if (ImGui::IsMouseDown(0) && ImGui::IsWindowHovered())
        selectedObject = nullptr;

    ImGui::End();
}
```

./editor/panels/hierarchy_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/scene.h"

class HierarchyPanel : public Panel {
public:
    HierarchyPanel();
    
    // 我们需要传入 Scene 指针来遍历物体
    // 我们需要传入 selectedObject 的引用，以便面板能修改当前选中的物体
    void onImGuiRender(const std::unique_ptr<Scene>& scene, GameObject*& selectedObject);

    // 覆盖基类接口 (虽然主要用上面的带参版本)
    void onImGuiRender() override {} 
};
```

./editor/panels/inspector_panel.cpp:
```
#include "inspector_panel.h"
#include "engine/geometry_factory.h"
#include "engine/resource_manager.h"
#include <imgui.h>
#include <glm/gtc/type_ptr.hpp>

InspectorPanel::InspectorPanel() : Panel("Inspector") {}

void InspectorPanel::onImGuiRender(GameObject*& selectedObject, Scene* sceneContext)
{
    if (!_isOpen) return;

    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    if (selectedObject)
    {
        // 1. Name & Delete Object
        char nameBuf[128];
        strcpy(nameBuf, selectedObject->name.c_str());

        ImGuiStyle& style = ImGui::GetStyle();
        float availableWidth = ImGui::GetContentRegionAvail().x;
        const char* btnLabel = "Delete Object"; 
        float buttonWidth = ImGui::CalcTextSize(btnLabel).x + style.FramePadding.x * 2.0f;
        float inputWidth = availableWidth - buttonWidth - style.ItemSpacing.x;

        ImGui::SetNextItemWidth(inputWidth);
        if (ImGui::InputText("##Name", nameBuf, sizeof(nameBuf)))
            selectedObject->name = nameBuf;

        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.2f, 0.2f, 1));
        bool shouldDeleteObj = ImGui::Button(btnLabel);
        ImGui::PopStyleColor();

        if (shouldDeleteObj && sceneContext)
        {
            sceneContext->markForDestruction(selectedObject);
            selectedObject = nullptr;
            // 立即结束当前 Frame 的绘制，防止访问野指针
            ImGui::End(); 
            return;
        }
        else 
        {
            // 只有没删除的时候才继续绘制
            ImGui::Separator();
            drawComponents(selectedObject);
        }
    }
    else
    {
        float availW = ImGui::GetContentRegionAvail().x;
        float textW = ImGui::CalcTextSize("No Object Selected").x;
        if (availW > textW) ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availW - textW) * 0.5f);
        ImGui::TextDisabled("No Object Selected");
    }

    ImGui::End();
}

void InspectorPanel::drawComponents(GameObject* obj)
{
    // 2. Transform
    if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen))
    {
        ImGui::DragFloat3("Position", glm::value_ptr(obj->transform.position), 0.1f);
        if (ImGui::DragFloat3("Rotation", glm::value_ptr(obj->transform.rotationEuler), 0.5f))
        {
            obj->transform.setRotation(obj->transform.rotationEuler);
        }
        ImGui::DragFloat3("Scale", glm::value_ptr(obj->transform.scale), 0.1f);
    }

    // 3. Components Loop
    Component *compToRemove = nullptr;
    for (auto &comp : obj->components)
    {
        ImGui::PushID(comp->getInstanceID());

        std::string headerName = "Unknown Component";
        if (comp->getType() == ComponentType::MeshRenderer) headerName = "Mesh Renderer";
        else if (comp->getType() == ComponentType::Light) headerName = "Light Source";
        else if (comp->getType() == ComponentType::ReflectionProbe) headerName = "Reflection Probe";

        bool isOpen = ImGui::CollapsingHeader(headerName.c_str(), ImGuiTreeNodeFlags_DefaultOpen);
        if (isOpen)
        {
            ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.6f, 0.2f, 0.2f, 1.0f));
            if (ImGui::Button("Remove Component", ImVec2(-1, 0))) 
                compToRemove = comp.get();
            ImGui::PopStyleColor();

            ImGui::Dummy(ImVec2(0, 5));
            drawComponentUI(comp.get()); // 调用具体绘制
            ImGui::Dummy(ImVec2(0, 10));
        }
        ImGui::PopID();
    }

    if (compToRemove) obj->removeComponent(compToRemove);

    // 4. Add Component
    ImGui::Separator();
    if (ImGui::Button("Add Component..."))
        ImGui::OpenPopup("AddCompPopup");

    if (ImGui::BeginPopup("AddCompPopup"))
    {
        bool hasMesh = obj->getComponent<MeshComponent>() != nullptr;
        bool hasLight = obj->getComponent<LightComponent>() != nullptr;

        if (ImGui::MenuItem("Mesh Renderer", nullptr, false, !hasMesh))
            obj->addComponent<MeshComponent>(GeometryFactory::createCube());

        if (ImGui::MenuItem("Light Source", nullptr, false, !hasLight))
        {
            auto light = obj->addComponent<LightComponent>(LightType::Point);
            if (hasMesh) {
                auto mesh = obj->getComponent<MeshComponent>();
                mesh->isGizmo = true; 
            }
        }

        bool hasProbe = obj->getComponent<ReflectionProbeComponent>() != nullptr;
        if (ImGui::MenuItem("Reflection Probe", nullptr, false, !hasProbe))
        {
            obj->addComponent<ReflectionProbeComponent>();
        }
        ImGui::EndPopup();
    }
}

// [搬运] 从 SceneRoaming::drawComponentUI 原封不动搬过来
void InspectorPanel::drawComponentUI(Component *comp)
{
    // ... 这里请粘贴原 SceneRoaming.cpp 中 drawComponentUI 的完整内容 ...
    // ... 包含 Mesh Filter, Shape Combo, Light Type Combo 等几百行代码 ...
    // 注意：需要确保 geometry_factory.h 和 resource_manager.h 已包含
    // --- Case 1: Mesh Renderer ---
    if (comp->getType() == ComponentType::MeshRenderer)
    {
        auto mesh = static_cast<MeshComponent *>(comp);
        bool needRebuild = false;

        ImGui::Checkbox("Is Gizmo (Unlit)", &mesh->isGizmo);
        ImGui::SameLine();
        ImGui::Checkbox("Double Sided", &mesh->doubleSided);

        bool canFlatShade = (mesh->shapeType == MeshShapeType::Sphere ||
                             mesh->shapeType == MeshShapeType::Cylinder || 
                             mesh->shapeType == MeshShapeType::Cone ||
                             mesh->shapeType == MeshShapeType::Prism || 
                             mesh->shapeType == MeshShapeType::Frustum ||
                             mesh->shapeType == MeshShapeType::CustomOBJ);
        
        if (canFlatShade) {
            ImGui::SameLine();
            if (ImGui::Checkbox("Flat Shade", &mesh->useFlatShade)) {
                needRebuild = true;
            }
        }

        // Mesh Filter 设置区域
        ImGui::Separator();
        ImGui::Text("Mesh Filter");

        // 1. 形状选择下拉菜单
        const char *shapeNames[] = {"Cube", "Sphere", "Cylinder", "Cone", "Prism", "Frustum", "Plane", "Custom OBJ"};
        int currentItem = (int)mesh->shapeType;

        if (ImGui::Combo("Shape", &currentItem, shapeNames, IM_ARRAYSIZE(shapeNames)))
        {
            mesh->shapeType = (MeshShapeType)currentItem;
            
            switch (mesh->shapeType) {
                case MeshShapeType::Cube:
                    mesh->doubleSided = false;
                    break;
                case MeshShapeType::Sphere:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Cylinder:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Cone:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = false;
                    break;
                case MeshShapeType::Prism:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = true; // 硬边
                    break;
                case MeshShapeType::Frustum:
                    mesh->doubleSided = false;
                    mesh->useFlatShade = true; // 硬边
                    break;
                case MeshShapeType::Plane:
                    mesh->doubleSided = true;
                    break;
                default:
                    mesh->doubleSided = false;
                    break;
            }
            
            if (mesh->shapeType != MeshShapeType::CustomOBJ)
            {
                needRebuild = true; // <--- 立即触发重建
            }
        }

        // 2. 根据类型显示不同的参数滑块
        switch (mesh->shapeType)
        {
        case MeshShapeType::Cube:
            if (ImGui::DragFloat("Size", &mesh->params.size, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            break;

        case MeshShapeType::Sphere:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            if (ImGui::SliderInt("Stacks", &mesh->params.stacks, 2, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Cylinder:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Cone:
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Slices", &mesh->params.slices, 3, 64))
                needRebuild = true;
            break;

        case MeshShapeType::Prism: // 多面棱柱
            if (ImGui::DragFloat("Radius", &mesh->params.radius, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Sides", &mesh->params.sides, 3, 32))
                needRebuild = true;
            break;

        case MeshShapeType::Frustum: // 多面棱台
            if (ImGui::DragFloat("Top Radius", &mesh->params.topRadius, 0.05f, 0.0f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Btm Radius", &mesh->params.bottomRadius, 0.05f, 0.0f, 10.0f))
                needRebuild = true;
            if (ImGui::DragFloat("Height", &mesh->params.height, 0.05f, 0.01f, 10.0f))
                needRebuild = true;
            if (ImGui::SliderInt("Sides", &mesh->params.sides, 3, 32))
                needRebuild = true;
            break;

        case MeshShapeType::Plane:
            if (ImGui::DragFloat("Width", &mesh->params.width, 0.1f))
                needRebuild = true; // 复用 params 里的变量，或者在 struct 加 width/depth
                                    // 暂时复用 params.size 作为 width, params.height 作为 depth，或者我们在 struct 里加
                                    // 为了简单，我们复用 size=width, height=depth
            if (ImGui::DragFloat("Depth", &mesh->params.depth, 0.1f))
                needRebuild = true;
            break;

        case MeshShapeType::CustomOBJ:
            {
                // 显示当前路径 (只读，或可编辑)
                std::string fullPath = mesh->params.objPath;
                std::string fileName = std::filesystem::path(fullPath).filename().string();

                drawResourceSlot("Mesh File", fileName, fullPath, "ASSET_OBJ",
                    // OnDrop
                    [&](const std::string& path) {
                        bool initialFlatState = false;
                        // 使用 path 加载
                        auto newModel = ResourceManager::Get().getModel(path, initialFlatState);
                        if (newModel) {
                            mesh->setMesh(newModel);
                            mesh->isGizmo = false;
                            mesh->doubleSided = false;
                            mesh->useFlatShade = initialFlatState;

                            if (!newModel->hasUVs()) {
                                // 如果模型没有 UV，自动开启 Triplanar，并给一个合理的缩放
                                mesh->useTriplanar = true;
                                mesh->triplanarScale = 0.2f; // 0.2 通常适合房间大小的物体，1.0 适合小物体，可自行调整默认值
                            } else {
                                // 如果有 UV，默认使用原始 UV
                                mesh->useTriplanar = false;
                                mesh->triplanarScale = 1.0f;
                            }
                            
                            strncpy(mesh->params.objPath, path.c_str(), sizeof(mesh->params.objPath) - 1);
                            mesh->params.objPath[sizeof(mesh->params.objPath) - 1] = '\0';
                        }
                    },
                    // OnClear
                    nullptr
                );
                
                // 提示信息可以移到 Tooltip 或者保留在下方
                // ImGui::TextDisabled("(?)"); 
                break;
            }
        }

        // 3. 执行重建逻辑
        if (needRebuild)
        {
            std::shared_ptr<Model> newModel = nullptr;
            auto &p = mesh->params;

            switch (mesh->shapeType)
            {
            case MeshShapeType::Cube:
                newModel = GeometryFactory::createCube(p.size);
                break;
            case MeshShapeType::Sphere:
                newModel = GeometryFactory::createSphere(p.radius, p.stacks, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Cylinder:
                newModel = GeometryFactory::createCylinder(p.radius, p.height, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Cone:
                newModel = GeometryFactory::createCone(p.radius, p.height, p.slices, mesh->useFlatShade);
                break;
            case MeshShapeType::Prism:
                newModel = GeometryFactory::createPrism(p.radius, p.height, p.sides, mesh->useFlatShade);
                break;
            case MeshShapeType::Frustum:
                newModel = GeometryFactory::createPyramidFrustum(p.topRadius, p.bottomRadius, p.height, p.sides, mesh->useFlatShade);
                break;
            case MeshShapeType::Plane:
                newModel = GeometryFactory::createPlane(p.width, p.depth);
                break;
            case MeshShapeType::CustomOBJ:
                if (strlen(p.objPath) > 0) {
                    newModel = ResourceManager::Get().getModel(p.objPath, mesh->useFlatShade);
                }
                break;
            default:
                break;
            }

            if (newModel)
            {
                // 保持原有的 Transform 不变，只换 Mesh
                // 但是 Model 类里也有 Transform (local transform)，新建的 Model transform 是默认的
                // 如果需要保留 Model 内部的 transform (例如箭头缩放)，这里需要额外处理
                // 不过 GeometryFactory 创建出来的 Model transform 都是默认的，所以直接覆盖没问题

                // 继承旧 Model 的局部缩放? 通常不需要，GeometryFactory 出来的都是标准大小
                // 如果之前对 Gizmo 做了特殊缩放，可能会丢失，但这里是用户主动重建，重置是合理的。

                mesh->setMesh(std::move(newModel));
            }
        }

        ImGui::Separator();

        // 检查宿主是否有点光源组件
        auto lightComp = comp->owner->getComponent<LightComponent>();

        // 材质 UI
        if (ImGui::TreeNode("Material"))
        {
            if (lightComp)
            {
                // [逻辑] 如果有光源组件，强制同步颜色，并显示提示
                mesh->material.diffuse = lightComp->color;
                mesh->material.ambient = lightComp->color * 0.1f; // 简单的关联
                mesh->material.specular = glm::vec3(0.0f);        // 发光体一般没有高光

                ImGui::TextColored(ImVec4(1, 1, 0, 1), "[Locked]");
                ImGui::SameLine();
                ImGui::TextWrapped("Color is controlled by the Light Source component.");

                // 仅显示只读的颜色预览 (使用 ColorButton)
                ImGui::ColorButton("##preview", ImVec4(mesh->material.diffuse.r, mesh->material.diffuse.g, mesh->material.diffuse.b, 1.0f));
            }
            else
            {
                // [逻辑] 没有光源组件，正常显示编辑器
                ImGui::ColorEdit3("Ambient", glm::value_ptr(mesh->material.ambient));
                ImGui::ColorEdit3("Diffuse", glm::value_ptr(mesh->material.diffuse));
                ImGui::ColorEdit3("Specular", glm::value_ptr(mesh->material.specular));
            }

            // 2. [新增] 纹理贴图设置 (Texture Map)
            ImGui::Spacing();
            ImGui::Separator();
        
            std::string fullPath = mesh->diffuseMap ? mesh->diffuseMap->getUri() : "";
            std::string fileName = std::filesystem::path(fullPath).filename().string();

            drawResourceSlot("Diffuse Map", fileName, fullPath, "ASSET_TEXTURE",
                // OnDrop
                [&](const std::string& path) {
                    auto tex = ResourceManager::Get().getTexture(path);
                    if (tex) mesh->diffuseMap = tex;
                },
                // OnClear
                [&]() {
                    mesh->diffuseMap = nullptr;
                }
            );

            if (mesh->diffuseMap) // 只有有纹理时才显示这些选项
            {
                ImGui::Dummy(ImVec2(0, 5));
                ImGui::Text("UV Mapping");

                if (mesh->model && !mesh->model->hasUVs()) 
                {
                    ImGui::SameLine();
                    // 黄色警告文字
                    ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), " [!] No UVs"); 
                    // 注意：如果你没有集成 FontAwesome (ICON_FA...)，可以直接写 "[!]" 或 "No UVs"
                    
                    if (ImGui::IsItemHovered()) {
                        ImGui::SetTooltip("This model has no UV coordinates.\nStandard texture mapping will fail.\nTriplanar Mapping is highly recommended.");
                    }
                }
                
                // 开关
                ImGui::Checkbox("Use Triplanar Mapping", &mesh->useTriplanar);
                
                // 提示信息
                if (ImGui::IsItemHovered())
                    ImGui::SetTooltip("Auto-generate UVs based on world position.\nUseful for models with missing or bad UVs.");

                // 如果开启了，显示缩放滑块
                if (mesh->useTriplanar) {
                    ImGui::DragFloat("Tiling Scale", &mesh->triplanarScale, 0.01f, 0.01f, 10.0f);
                }
            }

            ImGui::Separator();

            // Shininess 总是可以调的
            ImGui::DragFloat("Shininess", &mesh->material.shininess, 1.0f, 1.0f, 256.0f);

            ImGui::Separator();

            ImGui::Text("Advanced (Reflection / Refraction)");

            // 反射率
            ImGui::SliderFloat("Reflectivity", &mesh->material.reflectivity, 0.0f, 1.0f);
            
            // 透明度 (控制折射混合)
            ImGui::SliderFloat("Transparency", &mesh->material.transparency, 0.0f, 1.0f);

            // 只有当开启透明时，才需要调折射率
            if (mesh->material.transparency > 0.0f)
            {
                // 提供一些常用预设
                if (ImGui::BeginCombo("IOR Preset", "Custom"))
                {
                    if (ImGui::Selectable("Air (1.00)")) mesh->material.refractionIndex = 1.00f;
                    if (ImGui::Selectable("Water (1.33)")) mesh->material.refractionIndex = 1.33f;
                    if (ImGui::Selectable("Glass (1.52)")) mesh->material.refractionIndex = 1.52f;
                    if (ImGui::Selectable("Diamond (2.42)")) mesh->material.refractionIndex = 2.42f;
                    ImGui::EndCombo();
                }
                ImGui::DragFloat("IOR", &mesh->material.refractionIndex, 0.01f, 1.0f, 3.0f);
            }

            ImGui::TreePop();
        }
    }

    // --- Case 2: Light Source ---
    else if (comp->getType() == ComponentType::Light)
    {
        auto light = static_cast<LightComponent *>(comp);

        // 下拉菜单选择光源类型
        const char *typeNames[] = {"Directional", "Point", "Spot"};
        int currentType = (int)light->type;
        if (ImGui::Combo("Type", &currentType, typeNames, 3))
        {
            light->type = (LightType)currentType;
        }

        ImGui::ColorEdit3("Color", glm::value_ptr(light->color));
        ImGui::DragFloat("Intensity", &light->intensity, 0.1f, 0.0f, 10.0f);

        if (light->type == LightType::Directional) {
            ImGui::Separator();
            ImGui::Text("Shadow Settings");
            
            // Depth Bias
            ImGui::DragFloat("Depth Bias", &light->shadowBias, 0.0001f, 0.0f, 0.1f, "%.4f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pushes the shadow away, which fixes z-fighting.");

            // Normal Bias
            ImGui::DragFloat("Normal Bias", &light->shadowNormalBias, 0.001f, 0.0f, 1.0f, "%.3f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Shrinks the shadow caster along normals, which fixes acne.");

            // [新增] 剔除模式选择
            const char* cullModeNames[] = { "Cull Back", "Cull Front" };
            // 简单的逻辑映射：0 -> GL_BACK, 1 -> GL_FRONT
            int currentCull = (light->shadowCullFace == GL_FRONT) ? 1 : 0;

            if (ImGui::Combo("Shadow Culling", &currentCull, cullModeNames, 2)) {
                light->shadowCullFace = (currentCull == 1) ? GL_FRONT : GL_BACK;
            }
            
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Front: Best for solid objects (no acne).\nBack: Best for thin objects (no leaking).");
            }
        }

        if (light->type == LightType::Point || light->type == LightType::Spot)
        {
            ImGui::Text("Attenuation");
            ImGui::DragFloat("Linear", &light->linear, 0.001f);
            ImGui::DragFloat("Quadratic", &light->quadratic, 0.001f);
        }

        if (light->type == LightType::Spot)
        {
            ImGui::Text("Spot Angle");
            float innerDeg = glm::degrees(glm::acos(light->cutOff));
            float outerDeg = glm::degrees(glm::acos(light->outerCutOff));

            if (ImGui::DragFloat("Inner (Deg)", &innerDeg, 0.5f, 0.0f, 180.0f))
            {
                light->cutOff = glm::cos(glm::radians(innerDeg));
            }
            if (ImGui::DragFloat("Outer (Deg)", &outerDeg, 0.5f, 0.0f, 180.0f))
            {
                light->outerCutOff = glm::cos(glm::radians(outerDeg));
            }
        }
    }

    // --- Case 3: Ref;ection Probe ---
    else if (comp->getType() == ComponentType::ReflectionProbe)
    {
        auto probe = static_cast<ReflectionProbeComponent*>(comp);
        ImGui::Text("Resolution: %d x %d", probe->resolution, probe->resolution);

        ImGui::DragFloat3("Box Size", glm::value_ptr(probe->boxSize), 0.1f, 0.1f, 100.0f);
        
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("The size of the room/environment for correct reflections.\nAdjust this to match your walls.");
        }

        ImGui::TextDisabled("Real-time baked environment map");
    }
}

void InspectorPanel::drawResourceSlot(const char* label, 
                                      const std::string& currentName, 
                                      const std::string& fullPath,
                                      const char* payloadType,
                                      std::function<void(const std::string&)> onDrop,
                                      std::function<void()> onClear) // 允许传入 nullptr
{
    // 1. 绘制左侧标签
    ImGui::Text("%s", label);
    
    // 2. 计算布局
    bool allowClear = (onClear != nullptr); // [新增] 检查是否有清除回调
    
    float clearBtnSize = ImGui::GetFrameHeight();
    // 如果允许清除，留出 X 按钮的空间；否则占满 (-1.0f)
    float slotWidth = allowClear ? (ImGui::GetContentRegionAvail().x - clearBtnSize - 5.0f) : -1.0f;
    
    // 准备按钮文本
    std::string btnText = currentName.empty() ? "(None)" : currentName;

    // 3. 资源按钮
    ImGui::PushStyleVar(ImGuiStyleVar_ButtonTextAlign, ImVec2(0.0f, 0.5f)); 
    if (ImGui::Button(btnText.c_str(), ImVec2(slotWidth, 0))) {
        // 点击逻辑 (可选)
    }
    ImGui::PopStyleVar();

    // Tooltip
    if (ImGui::IsItemHovered() && !fullPath.empty()) {
        ImGui::SetTooltip("%s", fullPath.c_str());
    }

    // 4. 拖拽接收
    if (ImGui::BeginDragDropTarget())
    {
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(payloadType))
        {
            const char* path = (const char*)payload->Data;
            if (onDrop) onDrop(path);
        }
        ImGui::EndDragDropTarget();
    }

    // 5. [修改] 只有在允许清除时，才绘制 X 按钮和右键菜单
    if (allowClear) {
        ImGui::SameLine();
        if (ImGui::Button("X", ImVec2(clearBtnSize, 0))) {
            onClear();
        }
        
        // 右键清除菜单
        if (ImGui::BeginPopupContextItem()) {
            if (ImGui::MenuItem("Clear")) {
                onClear();
            }
            ImGui::EndPopup();
        }
    }
}
```

./editor/panels/inspector_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/scene_object.h"
#include "engine/scene.h"

class InspectorPanel : public Panel {
public:
    InspectorPanel();
    
    // 渲染选中物体的属性
    void onImGuiRender(GameObject*& selectedObject, Scene* sceneContext);

    void onImGuiRender() override {}

private:
    // 内部辅助函数：绘制组件列表
    void drawComponents(GameObject* obj);
    
    // 内部辅助函数：绘制单个组件的具体 UI
    void drawComponentUI(Component* comp);

    // 通用资源槽绘制函数
    // label: 属性名 (如 "Diffuse Map")
    // currentName: 当前资源的显示名称 (如 "box.png" 或 "(None)")
    // fullPath: 完整路径 (用于 Tooltip 显示)
    // payloadType: 拖拽类型 (如 "ASSET_OBJ")
    // onDrop: 接收到拖拽时的回调
    // onClear: 点击清除时的回调
    void drawResourceSlot(const char* label, 
                          const std::string& currentName, 
                          const std::string& fullPath, 
                          const char* payloadType,
                          std::function<void(const std::string&)> onDrop,
                          std::function<void()> onClear);
};
```

./editor/panels/panel.h:
```
#pragma once
#include <string>
#include <imgui.h>

class Panel {
public:
    Panel(const std::string& title) : _title(title) {}
    virtual ~Panel() = default;

    // 核心绘制函数
    // 子类实现具体的 ImGui::Begin() ... End() 逻辑
    virtual void onImGuiRender() = 0;

    // 显示/隐藏控制
    void open() { _isOpen = true; }
    void close() { _isOpen = false; }
    bool isOpen() const { return _isOpen; }
    
    // 设置是否可见的引用 (用于 MenuItem 的 bool*)
    bool* getOpenPtr() { return &_isOpen; }

protected:
    std::string _title;
    bool _isOpen = true;
};
```

./editor/panels/project_panel.cpp:
```
#include "project_panel.h"
#include <imgui.h>
#include <algorithm>

ProjectPanel::ProjectPanel() : Panel("Project / Assets") {}

void ProjectPanel::onImGuiRender()
{
    if (!_isOpen) return;

    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End();
        return;
    }

    const auto& files = ResourceManager::Get().getFileList();
    
    float padding = 10.0f;
    float thumbnailSize = 80.0f;
    float cellSize = thumbnailSize + padding;
    float panelWidth = ImGui::GetContentRegionAvail().x;
    int columnCount = (int)(panelWidth / cellSize);
    if (columnCount < 1) columnCount = 1;

    ImGui::Columns(columnCount, 0, false);

    for (const auto& file : files)
    {
        std::string filename = file.first;
        std::string relativePath = file.second;

        std::string ext = std::filesystem::path(filename).extension().string();
        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
        bool isModel = (ext == ".obj");
        bool isTexture = (ext == ".png" || ext == ".jpg" || ext == ".jpeg" || ext == ".bmp" || ext == ".tga");

        ImGui::PushID(relativePath.c_str());

        // 按钮代表文件
        ImGui::Button(filename.c_str(), ImVec2(80, 80));

        // 拖拽源
        if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_SourceAllowNullID))
        {
            if (isModel) {
                ImGui::SetDragDropPayload("ASSET_OBJ", relativePath.c_str(), relativePath.size() + 1);
                ImGui::Text("Model: %s", filename.c_str());
            }
            else if (isTexture)
            {
                ImGui::SetDragDropPayload("ASSET_TEXTURE", relativePath.c_str(), relativePath.size() + 1);
                ImGui::Text("Texture: %s", filename.c_str());
            }
            ImGui::EndDragDropSource();
        }

        ImGui::TextWrapped("%s", filename.c_str());
        ImGui::PopID();
        ImGui::NextColumn();
    }

    ImGui::Columns(1);
    ImGui::End();
}
```

./editor/panels/project_panel.h:
```
#pragma once
#include "panel.h"
#include "engine/resource_manager.h"

class ProjectPanel : public Panel {
public:
    ProjectPanel();
    void onImGuiRender() override;
private:
    // 这里可以缓存一些缩略图纹理 ID
};
```

./editor/panels/scene_view_panel.cpp:
```
#include "scene_view_panel.h"
#include <imgui.h>
#include <iostream>
#include <limits> // for std::numeric_limits

SceneViewPanel::SceneViewPanel() : Panel("3D Viewport")
{
    // 初始化 FBO (初始大小可以为 0，后面会自动 Resize)
    initFBO(100, 100); 
    
    // 初始化相机控制器
    // 初始宽高暂定为 800x600，会在第一次渲染时修正
    _cameraController = std::make_unique<EditorCamera>(800, 600);
}

SceneViewPanel::~SceneViewPanel()
{
    if (_fbo.id) glDeleteFramebuffers(1, &_fbo.id);
    if (_fbo.texture) glDeleteTextures(1, &_fbo.texture);
    if (_fbo.rbo) glDeleteRenderbuffers(1, &_fbo.rbo);
}

void SceneViewPanel::initFBO(int width, int height)
{
    _fbo.width = width;
    _fbo.height = height;

    glGenFramebuffers(1, &_fbo.id);
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo.id);

    glGenTextures(1, &_fbo.texture);
    glBindTexture(GL_TEXTURE_2D, _fbo.texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _fbo.texture, 0);

    glGenRenderbuffers(1, &_fbo.rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, _fbo.rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _fbo.rbo);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: SceneView Framebuffer is not complete!" << std::endl;
    
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void SceneViewPanel::resizeFBO(int width, int height)
{
    if (_fbo.width == width && _fbo.height == height) return;
    
    glDeleteFramebuffers(1, &_fbo.id);
    glDeleteTextures(1, &_fbo.texture);
    glDeleteRenderbuffers(1, &_fbo.rbo);
    initFBO(width, height);
}
// [修改后的签名]
void SceneViewPanel::onImGuiRender(Scene* scene, Renderer* renderer, GameObject*& selectedObject, float contentScale)
{
    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f)); 
    if (!ImGui::Begin(_title.c_str(), &_isOpen)) {
        ImGui::End(); ImGui::PopStyleVar(); return;
    }

    _isFocused = ImGui::IsWindowFocused(); 
    _isHovered = ImGui::IsWindowHovered();

    ImVec2 viewportPanelSize = ImGui::GetContentRegionAvail();
    if (viewportPanelSize.x <= 0) viewportPanelSize.x = 1;
    if (viewportPanelSize.y <= 0) viewportPanelSize.y = 1;

    int rawWidth = (int)(viewportPanelSize.x * contentScale);
    int rawHeight = (int)(viewportPanelSize.y * contentScale);

    // 2. Resize FBO
    if (rawWidth != _fbo.width || rawHeight != _fbo.height)
    {
        resizeFBO(rawWidth, rawHeight);
        renderer->onResize(rawWidth, rawHeight);
        _cameraController->onResize(rawWidth, rawHeight);
    }

    // 3. 执行渲染 (Render to FBO)
    // 注意：这里我们直接调用 renderer，不再需要 SceneRoaming 中转
    if (_fbo.id != 0) {
        renderer->render(*scene, 
                         _cameraController->getActiveCamera(), 
                         _fbo.id, rawWidth, rawHeight, 
                         contentScale, selectedObject);
    }

    // 4. 绘制 Image
    ImGui::Image((ImTextureID)(intptr_t)_fbo.texture, viewportPanelSize, ImVec2(0, 1), ImVec2(1, 0));

    // 记录视口位置 (用于射线检测和 Gizmo)
    _viewportPos = ImGui::GetItemRectMin();
    _viewportSize = ImGui::GetItemRectSize();

    // 5. 绘制 Gizmo
    _cameraController->drawViewGizmo(
        glm::vec2(_viewportPos.x, _viewportPos.y), 
        glm::vec2(_viewportSize.x, _viewportSize.y)
    );

    ImGui::End();
    ImGui::PopStyleVar();
}

// [完整签名]
void SceneViewPanel::onInputUpdate(float dt, Scene* scene, GameObject*& selectedObject)
{
    // 如果键盘正被 UI 占用（例如正在输入文字），不处理 3D 快捷键
    if (ImGui::GetIO().WantCaptureKeyboard) return;

    _isControlling = _cameraController->isControlling();

    // 快捷键 (F 聚焦)
    // 这里需要 GLFW 窗口句柄来检测按键吗？ ImGui 提供了 IsKeyPressed
    if (ImGui::IsKeyPressed(ImGuiKey_F)) {
        _cameraController->frameObject(selectedObject);
    }
    
    // Key 1: Front View (+Z)
    if (ImGui::IsKeyPressed(ImGuiKey_1) || ImGui::IsKeyPressed(ImGuiKey_Keypad1)) {
        _cameraController->switchToView(glm::vec3(0, 0, 1));
    }
    // Key 3: Right View (+X)
    if (ImGui::IsKeyPressed(ImGuiKey_3) || ImGui::IsKeyPressed(ImGuiKey_Keypad3)) {
        _cameraController->switchToView(glm::vec3(1, 0, 0));
    }
    // Key 7: Top View (+Y)
    if (ImGui::IsKeyPressed(ImGuiKey_7) || ImGui::IsKeyPressed(ImGuiKey_Keypad7)) {
        _cameraController->switchToView(glm::vec3(0, 1, 0));
    }

    // Delete
    if (ImGui::IsKeyPressed(ImGuiKey_Delete) && selectedObject)
    {
        if (scene) scene->markForDestruction(selectedObject);
        selectedObject = nullptr; 
    }

    if (_isHovered || _isFocused || _isControlling) {
        _cameraController->handleInput(); 
    }
    _cameraController->update(dt);

    // 拾取逻辑
    if (_isHovered && ImGui::IsMouseClicked(0) && !ImGui::IsKeyDown(ImGuiKey_LeftAlt)) {
        // 还要检查是否点到了 Gizmo (isControlling)
        if (!_cameraController->isControlling()) {
            handleMousePick(scene, selectedObject);
        }
    }
}

// [搬运] handleMousePick
void SceneViewPanel::handleMousePick(Scene* scene, GameObject*& selectedObject)
{
    // [变化1] 使用成员变量 _isHovered
    if (!_isHovered) 
        return;

    // [变化2] 使用 ImGui 获取鼠标绝对坐标 (替代 glfwGetCursorPos)
    ImVec2 mousePos = ImGui::GetMousePos();
    float mouseX = mousePos.x;
    float mouseY = mousePos.y;

    // [变化3] 使用成员变量 _cameraController, _viewportPos, _viewportSize
    auto camRay = _cameraController->screenPointToRay(
        mouseX, mouseY, 
        _viewportPos.x, _viewportPos.y, 
        _viewportSize.x, _viewportSize.y
    );

    // 转换成 Physics Ray
    // (假设 EditorCamera::Ray 和 PhysicsUtils::Ray 结构一致，或者是同一种类型)
    Ray worldRay(camRay.origin, camRay.direction);

    // [调试]
    // std::cout << "Ray Dir: " << worldRay.direction.x << ", " 
    //           << worldRay.direction.y << ", " << worldRay.direction.z << std::endl;

    GameObject *closestObj = nullptr;
    float closestDist = std::numeric_limits<float>::max();

    // [变化4] 使用传入的 scene 指针
    if (scene) 
    {
        const auto& objects = scene->getGameObjects();
        for (const auto &go : objects)
        {
            auto meshComp = go->getComponent<MeshComponent>();
            if (!meshComp || !meshComp->enabled) continue;

            // --- 以下数学逻辑完全保持不变 ---

            // 1. 计算 Model Matrix
            glm::mat4 modelMatrix = go->transform.getLocalMatrix();
            modelMatrix = modelMatrix * meshComp->model->transform.getLocalMatrix();

            // 2. 将射线转到局部空间
            glm::mat4 invModel = glm::inverse(modelMatrix);

            glm::vec3 localOrigin = glm::vec3(invModel * glm::vec4(worldRay.origin, 1.0f));
            glm::vec3 localDir = glm::vec3(invModel * glm::vec4(worldRay.direction, 0.0f));
            
            // 归一化
            localDir = glm::normalize(localDir);

            Ray localRay(localOrigin, localDir);

            // 3. 检测
            float tBox = 0.0f;
            if (PhysicsUtils::intersectRayAABB(localRay, meshComp->model->getBoundingBox(), tBox))
            {
                // 如果只击中盒子，还不算选中，必须击中三角形
                // 只有当 AABB 击中时，才进行昂贵的 Mesh 检测
                
                // ==================================================
                // Phase 2: 精测 (Narrow Phase) - Mesh
                // ==================================================
                float tMesh = 0.0f;
                const auto& verts = meshComp->model->getVertices();
                const auto& indices = meshComp->model->getIndices();

                if (PhysicsUtils::intersectRayMesh(localRay, verts, indices, tMesh))
                {
                    // [关键] tMesh 是局部空间的距离。
                    // 为了在不同缩放的物体之间正确排序，我们需要把它转换回世界空间距离。
                    // WorldPos = WorldOrigin + WorldDir * tWorld
                    // LocalPos = LocalOrigin + LocalDir * tMesh
                    // 简单的近似：把 LocalHitPos 转回 WorldPos，然后算距离。
                    
                    glm::vec3 localHitPos = localRay.origin + localRay.direction * tMesh;
                    glm::vec3 worldHitPos = glm::vec3(modelMatrix * glm::vec4(localHitPos, 1.0f));
                    float worldDist = glm::distance(worldRay.origin, worldHitPos);

                    if (worldDist < closestDist)
                    {
                        closestDist = worldDist;
                        closestObj = go.get();
                    }
                }
            }
        }
    }

    // [变化5] 更新传入的引用引用
    selectedObject = closestObj;
    
    // [调试]
    if(selectedObject) std::cout << "Picked: " << selectedObject->name << std::endl;
}
```

./editor/panels/scene_view_panel.h:
```
#pragma once
#include "panel.h"
#include <memory>
#include <glad/gl.h>
#include "editor/editor_camera.h"
#include "engine/renderer.h"
#include "engine/scene.h"

class SceneViewPanel : public Panel {
public:
    SceneViewPanel();
    ~SceneViewPanel();

    // 核心绘制函数
    // 需要传入 Scene 和 Renderer，因为面板只负责"显示"，不负责"拥有"数据
    void onImGuiRender(Scene* scene, Renderer* renderer, GameObject*& selectedObject, float contentScale);

    // 2. [关键修复] 必须覆盖基类的纯虚函数，否则此类为抽象类
    // 给一个空实现即可，因为我们不会通过 Panel* 多态指针来调用这个函数
    void onImGuiRender() override {}

    // 处理输入 (键盘/鼠标)
    // 之前在 SceneRoaming::handleInput 里的逻辑移到这里
    void onInputUpdate(float dt, Scene* scene, GameObject*& selectedObject);

    // 获取内部的相机 (供外部查询，如 Renderer 需要相机矩阵)
    Camera* getCamera() const { return _cameraController->getActiveCamera(); }

private:
    std::unique_ptr<EditorCamera> _cameraController;

    // FBO 相关资源
    struct FrameBuffer {
        GLuint id = 0;
        GLuint texture = 0;
        GLuint rbo = 0;
        int width = 0;
        int height = 0;
    } _fbo;

    // 视口状态
    ImVec2 _viewportPos = {0, 0};
    ImVec2 _viewportSize = {0, 0};
    bool _isHovered = false;
    bool _isFocused = false;
    bool _isControlling = false;

    // 内部辅助
    void initFBO(int width, int height);
    void resizeFBO(int width, int height);
    void handleMousePick(Scene* scene, GameObject*& selectedObject);
};
```

./engine/geometry_factory.cpp:
```
#include "geometry_factory.h"
#include <cmath>

// 辅助函数：添加四边形面 (由两个三角形组成)
static void addQuad(std::vector<Vertex> &vertices, std::vector<uint32_t> &indices,
                    const Vertex &v0, const Vertex &v1, const Vertex &v2, const Vertex &v3)
{
    // 两个三角形: 0-1-2 和 0-2-3
    uint32_t baseIndex = static_cast<uint32_t>(vertices.size());
    vertices.push_back(v0);
    vertices.push_back(v1);
    vertices.push_back(v2);
    vertices.push_back(v3);

    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 1);
    indices.push_back(baseIndex + 2);

    indices.push_back(baseIndex + 0);
    indices.push_back(baseIndex + 2);
    indices.push_back(baseIndex + 3);
}

void GeometryFactory::convertToFlat(std::vector<Vertex>& vertices, std::vector<uint32_t>& indices)
{
    std::vector<Vertex> newVertices;
    std::vector<uint32_t> newIndices;

    newVertices.reserve(indices.size());
    newIndices.reserve(indices.size());

    for (size_t i = 0; i < indices.size(); i += 3)
    {
        uint32_t i0 = indices[i];
        uint32_t i1 = indices[i+1];
        uint32_t i2 = indices[i+2];

        Vertex v0 = vertices[i0];
        Vertex v1 = vertices[i1];
        Vertex v2 = vertices[i2];

        // 重新计算面法线
        glm::vec3 edge1 = v1.position - v0.position;
        glm::vec3 edge2 = v2.position - v0.position;
        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

        v0.normal = faceNormal;
        v1.normal = faceNormal;
        v2.normal = faceNormal;

        newVertices.push_back(v0);
        newVertices.push_back(v1);
        newVertices.push_back(v2);

        uint32_t startIdx = static_cast<uint32_t>(newVertices.size()) - 3;
        newIndices.push_back(startIdx);
        newIndices.push_back(startIdx + 1);
        newIndices.push_back(startIdx + 2);
    }

    vertices = std::move(newVertices);
    indices = std::move(newIndices);
}

std::shared_ptr<Model> GeometryFactory::createFrustum(float topRadius, float bottomRadius, float height, int slices, bool useFlatShade)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;

    float halfH = height / 2.0f;

    // ==========================================
    // 1. 生成侧面 (Side)
    // ==========================================
    // 我们需要多生成一个点来闭合纹理坐标 (0.0 -> 1.0)
    for (int i = 0; i <= slices; ++i)
    {
        float u = (float)i / (float)slices;
        float theta = u * 2.0f * glm::pi<float>();

        float cosTheta = cos(theta);
        float sinTheta = sin(theta);

        // 顶点位置
        glm::vec3 topPos(cosTheta * topRadius, halfH, sinTheta * topRadius);
        glm::vec3 bottomPos(cosTheta * bottomRadius, -halfH, sinTheta * bottomRadius);

        // 1. 计算半径差 (底 - 顶)
        //    如果底比顶大 (圆锥)，diff > 0，法线应该朝上 (Y > 0)
        //    如果底比顶小 (倒圆台)，diff < 0，法线应该朝下 (Y < 0)
        float rDiff = bottomRadius - topRadius;

        // 2. 计算斜边长度 (勾股定理)
        //    用于归一化，确保法线长度为 1
        float slantLen = std::sqrt(rDiff * rDiff + height * height);

        // 3. 计算法线分量
        //    水平分量由高度决定 (面越陡，法线越平)
        //    垂直分量由半径差决定 (面越平，法线越竖)
        float nx = cosTheta * (height / slantLen);
        float ny = rDiff / slantLen; 
        float nz = sinTheta * (height / slantLen);

        glm::vec3 normal(nx, ny, nz);

        // 如果是棱柱/棱台（sides较少），通常需要 Flat Shading（每个面独立顶点），
        // 但为了代码简洁，这里使用 Smooth Shading（共用顶点）。
        // 如果觉得棱柱看起来太圆滑，可以后续改为每个面独立生成顶点。

        vertices.push_back(Vertex(bottomPos, normal, glm::vec2(u, 0.0f))); // 偶数索引
        vertices.push_back(Vertex(topPos, normal, glm::vec2(u, 1.0f)));    // 奇数索引
    }

    // 侧面索引生成 (Triangle Strip 逻辑转为 Triangles)
    for (int i = 0; i < slices; ++i)
    {
        // 当前列的两个顶点索引
        int currentBottom = i * 2;
        int currentTop = currentBottom + 1;
        // 下一列的两个顶点索引
        int nextBottom = currentBottom + 2;
        int nextTop = currentTop + 2;

        // 三角形 1
        indices.push_back(currentBottom);
        indices.push_back(currentTop);
        indices.push_back(nextBottom);

        // 三角形 2
        indices.push_back(currentTop);
        indices.push_back(nextTop);
        indices.push_back(nextBottom);
    }
    

    // ==========================================
    // 2. 生成顶盖 (Top Cap) - 如果半径 > 0
    // ==========================================
    if (topRadius > 1e-6)
    {
        uint32_t centerIndex = static_cast<uint32_t>(vertices.size());

        // 中心点
        vertices.push_back(Vertex(glm::vec3(0, halfH, 0), glm::vec3(0, 1, 0), glm::vec2(0.5f, 0.5f)));

        // 圆环点
        for (int i = 0; i <= slices; ++i)
        {
            float u = (float)i / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();
            float x = cos(theta) * topRadius;
            float z = sin(theta) * topRadius;

            // 纹理坐标简单映射
            float uMap = (cos(theta) * 0.5f) + 0.5f;
            float vMap = (sin(theta) * 0.5f) + 0.5f;

            vertices.push_back(Vertex(glm::vec3(x, halfH, z), glm::vec3(0, 1, 0), glm::vec2(uMap, vMap)));
        }

        // 索引 (Triangle Fan)
        for (int i = 0; i < slices; ++i)
        {
            indices.push_back(centerIndex);
            indices.push_back(centerIndex + 1 + i + 1); // 下一点
            indices.push_back(centerIndex + 1 + i);     // 当前点
        }
    }

    // ==========================================
    // 3. 生成底盖 (Bottom Cap) - 如果半径 > 0
    // ==========================================
    if (bottomRadius > 1e-6)
    {
        uint32_t centerIndex = static_cast<uint32_t>(vertices.size());

        // 中心点
        vertices.push_back(Vertex(glm::vec3(0, -halfH, 0), glm::vec3(0, -1, 0), glm::vec2(0.5f, 0.5f)));

        // 圆环点
        for (int i = 0; i <= slices; ++i)
        {
            float u = (float)i / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();
            float x = cos(theta) * bottomRadius;
            float z = sin(theta) * bottomRadius;

            float uMap = (cos(theta) * 0.5f) + 0.5f;
            float vMap = (sin(theta) * 0.5f) + 0.5f;

            vertices.push_back(Vertex(glm::vec3(x, -halfH, z), glm::vec3(0, -1, 0), glm::vec2(uMap, vMap)));
        }

        // 索引 (Triangle Fan) - 注意顺序相反以保持逆时针
        for (int i = 0; i < slices; ++i)
        {
            indices.push_back(centerIndex);
            indices.push_back(centerIndex + 1 + i);     // 当前点
            indices.push_back(centerIndex + 1 + i + 1); // 下一点
        }
    }

    if (useFlatShade) {
        convertToFlat(vertices, indices);
    }

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createCube(float size)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    float h = size / 2.0f;

    // 前面 (Normal +Z)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, h), glm::vec3(0, 0, 1), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, h), glm::vec3(0, 0, 1), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, h), glm::vec3(0, 0, 1), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, h), glm::vec3(0, 0, 1), glm::vec2(0, 1)});
    // 后面 (Normal -Z)
    addQuad(vertices, indices,
            Vertex{glm::vec3(h, -h, -h), glm::vec3(0, 0, -1), glm::vec2(0, 0)},
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(0, 0, -1), glm::vec2(1, 0)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(0, 0, -1), glm::vec2(1, 1)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(0, 0, -1), glm::vec2(0, 1)});
    // 左面 (Normal -X)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(-1, 0, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(-h, -h, h), glm::vec3(-1, 0, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(-h, h, h), glm::vec3(-1, 0, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(-1, 0, 0), glm::vec2(0, 1)});
    // 右面 (Normal +X)
    addQuad(vertices, indices,
            Vertex{glm::vec3(h, -h, h), glm::vec3(1, 0, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, -h), glm::vec3(1, 0, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(1, 0, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(h, h, h), glm::vec3(1, 0, 0), glm::vec2(0, 1)});
    // 上面 (Normal +Y)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, h, h), glm::vec3(0, 1, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, h, h), glm::vec3(0, 1, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, h, -h), glm::vec3(0, 1, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, h, -h), glm::vec3(0, 1, 0), glm::vec2(0, 1)});
    // 下面 (Normal -Y)
    addQuad(vertices, indices,
            Vertex{glm::vec3(-h, -h, -h), glm::vec3(0, -1, 0), glm::vec2(0, 0)},
            Vertex{glm::vec3(h, -h, -h), glm::vec3(0, -1, 0), glm::vec2(1, 0)},
            Vertex{glm::vec3(h, -h, h), glm::vec3(0, -1, 0), glm::vec2(1, 1)},
            Vertex{glm::vec3(-h, -h, h), glm::vec3(0, -1, 0), glm::vec2(0, 1)});

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createPlane(float width, float depth)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    float w = width / 2.0f;
    float d = depth / 2.0f;

    // 一个向上平铺的大矩形
    addQuad(vertices, indices,
            Vertex{glm::vec3(-w, 0, d), glm::vec3(0, 1, 0), glm::vec2(0, 0)},         // 左下
            Vertex{glm::vec3(w, 0, d), glm::vec3(0, 1, 0), glm::vec2(width, 0)},      // 右下 (UV重复)
            Vertex{glm::vec3(w, 0, -d), glm::vec3(0, 1, 0), glm::vec2(width, depth)}, // 右上
            Vertex{glm::vec3(-w, 0, -d), glm::vec3(0, 1, 0), glm::vec2(0, depth)}     // 左上
    );

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createSphere(float radius, int stacks, int slices, bool useFlatShade)
{
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;

    for (int i = 0; i <= stacks; ++i)
    {
        float v = (float)i / (float)stacks;
        float phi = v * glm::pi<float>();

        for (int j = 0; j <= slices; ++j)
        {
            float u = (float)j / (float)slices;
            float theta = u * 2.0f * glm::pi<float>();

            float x = cos(theta) * sin(phi);
            float y = cos(phi);
            float z = sin(theta) * sin(phi);

            glm::vec3 pos = glm::vec3(x, y, z) * radius;
            glm::vec3 normal = glm::vec3(x, y, z);
            glm::vec2 uv = glm::vec2(u, v);

            vertices.push_back(Vertex(pos, normal, uv));
        }
    }

    for (int i = 0; i < stacks; ++i)
    {
        for (int j = 0; j < slices; ++j)
        {
            int first = (i * (slices + 1)) + j;
            int second = first + slices + 1;

            indices.push_back(first);
            indices.push_back(first + 1);
            indices.push_back(second);

            indices.push_back(second);
            indices.push_back(first + 1);
            indices.push_back(second + 1);
        }
    }

    if (useFlatShade) {
        convertToFlat(vertices, indices);
    }

    return std::make_unique<Model>(vertices, indices);
}

std::shared_ptr<Model> GeometryFactory::createCylinder(float radius, float height, int slices, bool useFlatShade)
{
    return createFrustum(radius, radius, height, slices, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createCone(float radius, float height, int slices, bool useFlatShade)
{
    return createFrustum(0.0f, radius, height, slices, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createPrism(float radius, float height, int sides, bool useFlatShade)
{
    // 棱柱本质上就是 slices 很少的圆柱
    return createFrustum(radius, radius, height, sides, useFlatShade);
}

std::shared_ptr<Model> GeometryFactory::createPyramidFrustum(float topRadius, float bottomRadius, float height, int sides, bool useFlatShade)
{
    // 棱台本质上就是 slices 很少的圆台
    return createFrustum(topRadius, bottomRadius, height, sides, useFlatShade);
}
```

./engine/geometry_factory.h:
```
#pragma once

#include <vector>
#include <memory>
#include "base/vertex.h"
#include "model.h" // 我们需要返回 Model 对象

class GeometryFactory
{
public:
    // 1. 立方体 (用于墙壁、地板、箱子)
    static std::shared_ptr<Model> createCube(float size = 1.0f);

    // 5. 平面 (专门用于地板，虽然可以用压扁的立方体代替，但单面更高效)
    static std::shared_ptr<Model> createPlane(float width = 10.0f, float depth = 10.0f);

    // 2. 球体 (用于装饰、测试光照)
    // stacks: 纬度切片数, slices: 经度切片数 (越高越圆)
    static std::shared_ptr<Model> createSphere(float radius = 0.5f, int stacks = 16, int slices = 32, bool useFlatShade = false);

    // -----------------------------------------------------------------------
    // 通用几何生成核心 (Frustum)
    // -----------------------------------------------------------------------
    // 这是一个万能函数：
    // - topRadius == bottomRadius, slices > 20 -> 圆柱
    // - topRadius == 0                         -> 圆锥
    // - topRadius != bottomRadius              -> 圆台
    // - slices == 3, 4, 5, 6...                -> 三棱柱/台, 四棱柱/台...
    static std::shared_ptr<Model> createFrustum(float topRadius, float bottomRadius, float height, int slices, bool useFlatShade);

    // 4. 圆柱体 (Cylinder) - 实际上是调用 createFrustum
    static std::shared_ptr<Model> createCylinder(float radius = 0.5f, float height = 1.0f, int slices = 32, bool useFlatShade = false);

    // 5. 圆锥体 (Cone) - 实际上是调用 createFrustum
    static std::shared_ptr<Model> createCone(float radius = 0.5f, float height = 1.0f, int slices = 32, bool useFlatShade = false);

    // 6. 多面棱柱 (Prism) - 比如六棱柱: radius=1, slices=6
    static std::shared_ptr<Model> createPrism(float radius = 0.5f, float height = 1.0f, int sides = 6, bool useFlatShade = false);

    // 7. 多面棱台 (Prism Frustum) - 比如四棱台: topR=0.5, bottomR=1, slices=4
    static std::shared_ptr<Model> createPyramidFrustum(float topRadius, float bottomRadius, float height, int sides = 4, bool useFlatShade = false);

private:
    static void convertToFlat(std::vector<Vertex>& vertices, std::vector<uint32_t>& indices);
};
```

./engine/model.cpp:
```
#include "model.h"
#include "obj_loader.h"

#include <algorithm>
#include <iostream>
#include <limits>

Model::Model(const std::string &filepath, bool useFlatShade)
    : _isUploaded(false)
{
    // 1. 调用 OBJLoader 获取数据
    // 这里利用了 C++ 的返回值优化 (RVO)，不会产生不必要的深拷贝
    MeshData data = OBJLoader::load(filepath, useFlatShade);

    // 2. 将数据移动到 Model 的成员变量中
    _vertices = std::move(data.vertices);
    _indices = std::move(data.indices);
    _hasUVs = data.hasUVs;

    // 3. 后续初始化流程保持不变
    computeBoundingBox();
}

Model::Model(const std::vector<Vertex> &vertices, const std::vector<uint32_t> &indices)
    : _vertices(vertices), _indices(indices), _isUploaded(false)
{
    _hasUVs = true;
    computeBoundingBox();
}

Model::Model(Model &&rhs) noexcept
    : _vertices(std::move(rhs._vertices)), _indices(std::move(rhs._indices)),
      _boundingBox(std::move(rhs._boundingBox)), _vao(rhs._vao), _vbo(rhs._vbo), _ebo(rhs._ebo),
      _boxVao(rhs._boxVao), _boxVbo(rhs._boxVbo), _boxEbo(rhs._boxEbo)
{
    rhs._vao = 0;
    rhs._vbo = 0;
    rhs._ebo = 0;

    rhs._boxVao = 0;
    rhs._boxVbo = 0;
    rhs._boxEbo = 0;
}

Model::~Model()
{
    cleanup();
}

BoundingBox Model::getBoundingBox() const
{
    return _boundingBox;
}

void Model::initGL()
{
    if (_isUploaded) return; // 防止重复初始化

    // 确保此时有 OpenGL 上下文 (如果没有，glGetError 或 glGen* 会报错/崩溃，但此时通常都在渲染循环里了)
    initGLResources();
    initBoxGLResources();

    _isUploaded = true;
}

void Model::draw()
{
    if (!_isUploaded) {
        // const_cast 是一种妥协，或者将 initGL 声明为 const 并把内部变量设为 mutable
        // 这里最优雅的方式是将 _isUploaded 设为 mutable (已在 .h 中完成)
        const_cast<Model*>(this)->initGL();
    }

    if (_vao == 0) return; // 如果初始化失败，防止崩溃

    glBindVertexArray(_vao);
    glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(_indices.size()), GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}

void Model::drawBoundingBox()
{
    if (!_isUploaded) {
         const_cast<Model*>(this)->initGL();
    }

    if (_boxVao == 0) return;
    
    glBindVertexArray(_boxVao);
    glDrawElements(GL_LINES, 24, GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}

GLuint Model::getVao() const
{
    return _vao;
}

GLuint Model::getBoundingBoxVao() const
{
    return _boxVao;
}

size_t Model::getVertexCount() const
{
    return _vertices.size();
}

size_t Model::getFaceCount() const
{
    return _indices.size() / 3;
}

void Model::initGLResources()
{
    // create a vertex array object
    glGenVertexArrays(1, &_vao);
    // create a vertex buffer object
    glGenBuffers(1, &_vbo);
    // create a element array buffer
    glGenBuffers(1, &_ebo);

    glBindVertexArray(_vao);
    glBindBuffer(GL_ARRAY_BUFFER, _vbo);
    glBufferData(
        GL_ARRAY_BUFFER, sizeof(Vertex) * _vertices.size(), _vertices.data(), GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _ebo);
    glBufferData(
        GL_ELEMENT_ARRAY_BUFFER, _indices.size() * sizeof(uint32_t), _indices.data(),
        GL_STATIC_DRAW);

    // specify layout, size of a vertex, data type, normalize, sizeof vertex array, offset of the
    // attribute
    glVertexAttribPointer(
        0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, position));
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(
        1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, normal));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(
        2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)offsetof(Vertex, texCoord));
    glEnableVertexAttribArray(2);

    glBindVertexArray(0);
}

void Model::computeBoundingBox()
{
    float minX = std::numeric_limits<float>::max();
    float minY = std::numeric_limits<float>::max();
    float minZ = std::numeric_limits<float>::max();
    float maxX = -std::numeric_limits<float>::max();
    float maxY = -std::numeric_limits<float>::max();
    float maxZ = -std::numeric_limits<float>::max();

    for (const auto &v : _vertices)
    {
        minX = std::min(v.position.x, minX);
        minY = std::min(v.position.y, minY);
        minZ = std::min(v.position.z, minZ);
        maxX = std::max(v.position.x, maxX);
        maxY = std::max(v.position.y, maxY);
        maxZ = std::max(v.position.z, maxZ);
    }

    _boundingBox.min = glm::vec3(minX, minY, minZ);
    _boundingBox.max = glm::vec3(maxX, maxY, maxZ);

    // =========================================================
    // [修复] 防止零厚度导致的射线检测失败
    // 给极薄的物体（如 Plane, Quad）增加一个微小的厚度 (Epsilon)
    // =========================================================
    constexpr float EPSILON = 0.01f;

    if ((_boundingBox.max.x - _boundingBox.min.x) < EPSILON)
    {
        _boundingBox.max.x += EPSILON;
        _boundingBox.min.x -= EPSILON;
    }
    if ((_boundingBox.max.y - _boundingBox.min.y) < EPSILON)
    {
        _boundingBox.max.y += EPSILON;
        _boundingBox.min.y -= EPSILON; // 向下加厚一点
    }
    if ((_boundingBox.max.z - _boundingBox.min.z) < EPSILON)
    {
        _boundingBox.max.z += EPSILON;
        _boundingBox.min.z -= EPSILON;
    }
}

void Model::initBoxGLResources()
{
    std::vector<glm::vec3> boxVertices = {
        glm::vec3(_boundingBox.min.x, _boundingBox.min.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.min.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.max.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.max.y, _boundingBox.min.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.min.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.min.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.min.x, _boundingBox.max.y, _boundingBox.max.z),
        glm::vec3(_boundingBox.max.x, _boundingBox.max.y, _boundingBox.max.z),
    };

    std::vector<uint32_t> boxIndices = {0, 1, 0, 2, 0, 4, 3, 1, 3, 2, 3, 7,
                                        5, 4, 5, 1, 5, 7, 6, 4, 6, 7, 6, 2};

    glGenVertexArrays(1, &_boxVao);
    glGenBuffers(1, &_boxVbo);
    glGenBuffers(1, &_boxEbo);

    glBindVertexArray(_boxVao);
    glBindBuffer(GL_ARRAY_BUFFER, _boxVbo);
    glBufferData(
        GL_ARRAY_BUFFER, boxVertices.size() * sizeof(glm::vec3), boxVertices.data(),
        GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _boxEbo);
    glBufferData(
        GL_ELEMENT_ARRAY_BUFFER, boxIndices.size() * sizeof(uint32_t), boxIndices.data(),
        GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3), 0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(0);
}

void Model::cleanup()
{
    if (_boxEbo)
    {
        glDeleteBuffers(1, &_boxEbo);
        _boxEbo = 0;
    }

    if (_boxVbo)
    {
        glDeleteBuffers(1, &_boxVbo);
        _boxVbo = 0;
    }

    if (_boxVao)
    {
        glDeleteVertexArrays(1, &_boxVao);
        _boxVao = 0;
    }

    if (_ebo != 0)
    {
        glDeleteBuffers(1, &_ebo);
        _ebo = 0;
    }

    if (_vbo != 0)
    {
        glDeleteBuffers(1, &_vbo);
        _vbo = 0;
    }

    if (_vao != 0)
    {
        glDeleteVertexArrays(1, &_vao);
        _vao = 0;
    }
}
```

./engine/model.h:
```
#pragma once

#include <string>
#include <vector>

#include "base/bounding_box.h"
#include "base/gl_utility.h"
#include "base/transform.h"
#include "base/vertex.h"

class Model
{
public:
    Model(const std::string &filepath, bool useFlatShade);

    Model(const std::vector<Vertex> &vertices, const std::vector<uint32_t> &indices);

    Model(Model &&rhs) noexcept;

    Model(const Model &) = delete;
    Model &operator=(const Model &) = delete;

    virtual ~Model();

    GLuint getVao() const;
    GLuint getBoundingBoxVao() const;
    size_t getVertexCount() const;
    size_t getFaceCount() const;
    BoundingBox getBoundingBox() const;

    void initGL();

    virtual void draw();

    virtual void drawBoundingBox();

    const std::vector<uint32_t> &getIndices() const
    {
        return _indices;
    }
    const std::vector<Vertex> &getVertices() const
    {
        return _vertices;
    }
    const Vertex &getVertex(int i) const
    {
        return _vertices[i];
    }
    
    bool hasUVs() const { return _hasUVs; }

public:
    Transform transform;

protected:
    // vertices of the table represented in model's own coordinate
    std::vector<Vertex> _vertices;
    std::vector<uint32_t> _indices;
    bool _hasUVs = false;

    // bounding box
    BoundingBox _boundingBox;

    // opengl objects
    GLuint _vao = 0;
    GLuint _vbo = 0;
    GLuint _ebo = 0;

    GLuint _boxVao = 0;
    GLuint _boxVbo = 0;
    GLuint _boxEbo = 0;

    bool _isUploaded = false;

    void computeBoundingBox();

    void initGLResources();

    void initBoxGLResources();

    void cleanup();
};
```

./engine/obj_loader.cpp:
```
#include "obj_loader.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <unordered_map>

// 辅助函数：安全地将 OBJ 索引转换为 vector 下标
// 1. 处理正数索引 (1-based -> 0-based)
// 2. 处理负数索引 (相对位置 -> 绝对位置)
// 3. 边界检查
static int fixIndex(int idx, size_t size) {
    if (idx > 0) return idx - 1;             // 正数：1 -> 0
    if (idx < 0) return (int)size + idx;     // 负数：-1 -> size-1
    return -1;                               // 0 是无效索引
}

// 辅助函数：将 "1/2/3" 这种字符串分割成索引
// 返回 {posIndex, texIndex, normIndex}，如果某项缺失返回 -1
static glm::ivec3 parseFaceIndex(const std::string& token, size_t vSize, size_t vtSize, size_t vnSize) {
    glm::ivec3 result(-1);
    std::string part;
    std::stringstream ss(token);
    
    // 1. Position Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.x = fixIndex(rawIdx, vSize);
            } catch (...) { result.x = -1; }
        }
    }
    
    // 2. TexCoord Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.y = fixIndex(rawIdx, vtSize);
            } catch (...) { result.y = -1; }
        }
    }

    // 3. Normal Index
    if (std::getline(ss, part, '/')) {
        if (!part.empty()) {
            try {
                int rawIdx = std::stoi(part);
                result.z = fixIndex(rawIdx, vnSize);
            } catch (...) { result.z = -1; }
        }
    }

    return result;
}

MeshData OBJLoader::load(const std::string& filepath, bool useFlatShade) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        // 抛出异常供 Model 捕获，或者打印错误并返回空数据
        throw std::runtime_error("[OBJ Loader] Failed to open OBJ file: " + filepath);
    }

    // 临时存储原始数据
    std::vector<glm::vec3> temp_positions;
    std::vector<glm::vec3> temp_normals;
    std::vector<glm::vec2> temp_texCoords;

    MeshData meshData; // 最终返回的数据

    // 顶点去重 Map
    std::unordered_map<Vertex, uint32_t> uniqueVertices;

    std::string line;
    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '#') continue;

        std::stringstream ss(line);
        std::string type;
        ss >> type;

        if (type == "v") {
            glm::vec3 v;
            ss >> v.x >> v.y >> v.z;
            temp_positions.push_back(v);
        }
        else if (type == "vn") {
            glm::vec3 vn;
            ss >> vn.x >> vn.y >> vn.z;
            temp_normals.push_back(vn);
        }
        else if (type == "vt") {
            glm::vec2 vt;
            ss >> vt.x >> vt.y;
            meshData.hasUVs = true;
            temp_texCoords.push_back(vt);
        }
        else if (type == "f") {
            std::string token;
            std::vector<Vertex> faceVertices;

            // 读取面数据
            while (ss >> token) {
                glm::ivec3 indices = parseFaceIndex(token, temp_positions.size(), temp_texCoords.size(), temp_normals.size());
                Vertex currentVertex;
                
                // Position
                if (indices.x >= 0 && indices.x < temp_positions.size())
                    currentVertex.position = temp_positions[indices.x];
                else
                    continue;

                // TexCoord
                if (indices.y >= 0 && indices.y < temp_texCoords.size())
                    currentVertex.texCoord = temp_texCoords[indices.y];
                else
                    currentVertex.texCoord = glm::vec2(0.0f);

                // Normal
                if (indices.z >= 0 && indices.z < temp_normals.size())
                    currentVertex.normal = temp_normals[indices.z];
                else
                    currentVertex.normal = glm::vec3(0.0f);

                faceVertices.push_back(currentVertex);
            }

            // 三角化 (Triangle Fan)
            // 将多边形分解为三角形
            if (faceVertices.size() >= 3) {
                for (size_t i = 1; i < faceVertices.size() - 1; ++i) {
                    Vertex triVerts[3] = {faceVertices[0], faceVertices[i], faceVertices[i+1]};

                    if (useFlatShade)
                    {
                        // 1. 强制计算面法线 (忽略 OBJ 文件自带的法线)
                        glm::vec3 edge1 = triVerts[1].position - triVerts[0].position;
                        glm::vec3 edge2 = triVerts[2].position - triVerts[0].position;
                        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

                        // 2. 将三个顶点直接加入，不做去重
                        for (int k = 0; k < 3; ++k) {
                            triVerts[k].normal = faceNormal; // 覆盖法线
                            
                            // 直接 push，不查 map
                            meshData.indices.push_back(static_cast<uint32_t>(meshData.vertices.size()));
                            meshData.vertices.push_back(triVerts[k]);
                        }
                    }
                    else
                    {
                        for (int k = 0; k < 3; ++k) {
                            if (uniqueVertices.count(triVerts[k]) == 0) {
                                uniqueVertices[triVerts[k]] = static_cast<uint32_t>(meshData.vertices.size());
                                meshData.vertices.push_back(triVerts[k]);
                            }
                            meshData.indices.push_back(uniqueVertices[triVerts[k]]);
                        }
                    }
                }
            }
        }
    }

    // 自动计算法线（如果 OBJ 文件里完全没有法线信息）
    if (!useFlatShade && temp_normals.empty()) {
        for (size_t i = 0; i < meshData.indices.size(); i += 3) {
            Vertex& v0 = meshData.vertices[meshData.indices[i]];
            Vertex& v1 = meshData.vertices[meshData.indices[i+1]];
            Vertex& v2 = meshData.vertices[meshData.indices[i+2]];

            glm::vec3 edge1 = v1.position - v0.position;
            glm::vec3 edge2 = v2.position - v0.position;
            glm::vec3 normal = glm::normalize(glm::cross(edge1, edge2));

            v0.normal = normal;
            v1.normal = normal;
            v2.normal = normal;
        }
    }

    std::cout << "Loaded OBJ: " << filepath << "\n" 
              << "  Vertices: " << meshData.vertices.size() << "\n" 
              << "  Indices: " << meshData.indices.size() << std::endl;

    return meshData;
}

std::vector<SubMesh> OBJLoader::loadScene(const std::string& filepath, bool useFlatShade) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        throw std::runtime_error("[OBJ Loader] Failed to open OBJ file for scene: " + filepath);
    }

    std::vector<SubMesh> meshes;
    
    // 全局数据池 (v, vn, vt 是跨物体共享索引的)
    std::vector<glm::vec3> global_positions;
    std::vector<glm::vec3> global_normals;
    std::vector<glm::vec2> global_texCoords;

    // 当前正在构建的 SubMesh
    SubMesh currentMesh;
    currentMesh.name = "Object_0";
    currentMesh.hasUVs = false;

    // 当前 SubMesh 的顶点去重 Map
    std::unordered_map<Vertex, uint32_t> uniqueVertices;

    // 辅助 lambda：用于在切换物体或结束时保存当前 Mesh
    auto flushCurrentMesh = [&]() {
        if (!currentMesh.indices.empty()) {
            
            // 如果需要自动计算法线 (Smooth 且源文件没法线)
            if (!useFlatShade && global_normals.empty()) {
                 for (size_t i = 0; i < currentMesh.indices.size(); i += 3) {
                    Vertex& v0 = currentMesh.vertices[currentMesh.indices[i]];
                    Vertex& v1 = currentMesh.vertices[currentMesh.indices[i+1]];
                    Vertex& v2 = currentMesh.vertices[currentMesh.indices[i+2]];
                    glm::vec3 edge1 = v1.position - v0.position;
                    glm::vec3 edge2 = v2.position - v0.position;
                    glm::vec3 normal = glm::normalize(glm::cross(edge1, edge2));
                    v0.normal = normal; v1.normal = normal; v2.normal = normal;
                }
            }
            meshes.push_back(currentMesh);
        }
        
        // 重置状态
        currentMesh = SubMesh();
        uniqueVertices.clear();
        currentMesh.hasUVs = false; 
    };

    std::string line;
    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '#') continue;

        std::stringstream ss(line);
        std::string type;
        ss >> type;

        // --- 读取全局数据 ---
        if (type == "v") {
            glm::vec3 v; ss >> v.x >> v.y >> v.z;
            global_positions.push_back(v);
        }
        else if (type == "vn") {
            glm::vec3 vn; ss >> vn.x >> vn.y >> vn.z;
            global_normals.push_back(vn);
        }
        else if (type == "vt") {
            glm::vec2 vt; ss >> vt.x >> vt.y;
            global_texCoords.push_back(vt);
        }

        // --- 切换物体 (o) 或 组 (g) ---
        else if (type == "o" || type == "g") {
            // 保存上一个物体
            flushCurrentMesh();

            // 读取新名字 (读取整行，因为名字可能包含空格)
            std::string name;
            std::getline(ss, name); 
            
            // std::getline 会读取前面的空格，我们需要 Trim (修剪) 一下
            size_t first = name.find_first_not_of(" \t\r");
            size_t last = name.find_last_not_of(" \t\r");
            
            if (first != std::string::npos && last != std::string::npos) {
                currentMesh.name = name.substr(first, last - first + 1);
            } else {
                // 如果全是空格或者为空
                currentMesh.name = "Object"; 
            }
        }

        // --- 读取面 (f) ---
        else if (type == "f") {
            std::string token;
            std::vector<Vertex> faceVertices;

            while (ss >> token) {
                // 注意：这里传入的是当前全局池的大小
                glm::ivec3 indices = parseFaceIndex(token, global_positions.size(), global_texCoords.size(), global_normals.size());
                Vertex currentVertex;

                // 1. Position
                if (indices.x >= 0 && indices.x < global_positions.size())
                    currentVertex.position = global_positions[indices.x];
                else continue;

                // 2. TexCoord
                if (indices.y >= 0 && indices.y < global_texCoords.size()) {
                    currentVertex.texCoord = global_texCoords[indices.y];
                    currentMesh.hasUVs = true; // 只要用到了 UV 索引，就标记有 UV
                } else {
                    currentVertex.texCoord = glm::vec2(0.0f);
                }

                // 3. Normal
                if (indices.z >= 0 && indices.z < global_normals.size())
                    currentVertex.normal = global_normals[indices.z];
                else 
                    currentVertex.normal = glm::vec3(0.0f);

                faceVertices.push_back(currentVertex);
            }

            // 三角化
            if (faceVertices.size() >= 3) {
                for (size_t i = 1; i < faceVertices.size() - 1; ++i) {
                    Vertex triVerts[3] = {faceVertices[0], faceVertices[i], faceVertices[i+1]};

                    if (useFlatShade) {
                        // Flat Shading 逻辑：分裂顶点，重算法线
                        glm::vec3 edge1 = triVerts[1].position - triVerts[0].position;
                        glm::vec3 edge2 = triVerts[2].position - triVerts[0].position;
                        glm::vec3 faceNormal = glm::normalize(glm::cross(edge1, edge2));

                        for (int k = 0; k < 3; ++k) {
                            triVerts[k].normal = faceNormal;
                            currentMesh.indices.push_back(static_cast<uint32_t>(currentMesh.vertices.size()));
                            currentMesh.vertices.push_back(triVerts[k]);
                        }
                    } 
                    else {
                        // Smooth Shading 逻辑：使用 Map 去重
                        for (int k = 0; k < 3; ++k) {
                            if (uniqueVertices.count(triVerts[k]) == 0) {
                                uniqueVertices[triVerts[k]] = static_cast<uint32_t>(currentMesh.vertices.size());
                                currentMesh.vertices.push_back(triVerts[k]);
                            }
                            currentMesh.indices.push_back(uniqueVertices[triVerts[k]]);
                        }
                    }
                }
            }
        }
    }

    // 循环结束，保存最后一个物体
    flushCurrentMesh();

    std::cout << "Loaded Scene OBJ: " << filepath << " containing " << meshes.size() << " meshes." << std::endl;
    return meshes;
}
```

./engine/obj_loader.h:
```
#pragma once

#include <string>
#include <vector>
#include "base/vertex.h"

// 定义一个中间结构体，用于在 Loader 和 Model 之间传递数据
struct MeshData {
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    bool hasUVs = false;
};

struct SubMesh {
    std::string name;
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    bool hasUVs = false;
};

class OBJLoader {
public:
    // 修改返回类型为 MeshData
    // 如果加载失败，选择抛出异常，或者返回空的 MeshData（根据你的错误处理策略）
    static MeshData load(const std::string& filepath, bool useFlatShade = false);

    // 场景加载 (返回多个子网格)
    static std::vector<SubMesh> loadScene(const std::string& filepath, bool useSplitVert = false);
};
```

./engine/outline_pass.cpp:
```
#include "outline_pass.h"
#include <vector>

OutlinePass::OutlinePass(int width, int height)
    : _screenWidth(width), _screenHeight(height)
{
    initShaders();
    initQuad();
    initFrameBuffer();
}

OutlinePass::~OutlinePass()
{
    if (_fbo)
        glDeleteFramebuffers(1, &_fbo);
    if (_maskTexture)
        glDeleteTextures(1, &_maskTexture);
    // if (_depthRenderBuffer)
    //     glDeleteRenderbuffers(1, &_depthRenderBuffer);
    // [新增] 释放 MSAA 资源
    if (_msaaFbo)
        glDeleteFramebuffers(1, &_msaaFbo);
    if (_msaaColorBuffer)
        glDeleteRenderbuffers(1, &_msaaColorBuffer);
    if (_msaaDepthBuffer)
        glDeleteRenderbuffers(1, &_msaaDepthBuffer);
    if (_quadVAO)
        glDeleteVertexArrays(1, &_quadVAO);
    if (_quadVBO)
        glDeleteBuffers(1, &_quadVBO);
}

void OutlinePass::onResize(int width, int height)
{
    _screenWidth = width;
    _screenHeight = height;
    // 重新生成 FBO (简单粗暴的方法是删了重建)
    if (_fbo)
        glDeleteFramebuffers(1, &_fbo);
    if (_maskTexture)
        glDeleteTextures(1, &_maskTexture);
    // if (_depthRenderBuffer)
    //     glDeleteRenderbuffers(1, &_depthRenderBuffer);
    // [新增]
    if (_msaaFbo)
        glDeleteFramebuffers(1, &_msaaFbo);
    if (_msaaColorBuffer)
        glDeleteRenderbuffers(1, &_msaaColorBuffer);
    if (_msaaDepthBuffer)
        glDeleteRenderbuffers(1, &_msaaDepthBuffer);
    
    initFrameBuffer();
}

void OutlinePass::initFrameBuffer()
{
    GLint maxSamples;
    glGetIntegerv(GL_MAX_SAMPLES, &maxSamples);
    int samples = std::min(4, maxSamples); // 尝试用 4，如果不支持则用最大值

    // ==========================================
    // 1. 创建 MSAA FBO (渲染目标)
    // ==========================================
    glGenFramebuffers(1, &_msaaFbo);
    glBindFramebuffer(GL_FRAMEBUFFER, _msaaFbo);

    // 创建多重采样颜色缓冲 (4 samples)
    glGenRenderbuffers(1, &_msaaColorBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _msaaColorBuffer);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, samples, GL_R8, _screenWidth, _screenHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _msaaColorBuffer);

    // 创建多重采样深度缓冲 (必须匹配)
    glGenRenderbuffers(1, &_msaaDepthBuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _msaaDepthBuffer);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, samples, GL_DEPTH_COMPONENT24, _screenWidth, _screenHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _msaaDepthBuffer);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: MSAA Framebuffer is not complete!" << std::endl;

    // ==========================================
    // 2. 创建 Resolve FBO (读取目标 - 普通纹理)
    // ==========================================
    glGenFramebuffers(1, &_fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);

    // 创建普通单通道纹理 (GL_LINEAR 很重要)
    glGenTextures(1, &_maskTexture);
    glBindTexture(GL_TEXTURE_2D, _maskTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, _screenWidth, _screenHeight, 0, GL_RED, GL_FLOAT, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); // 线性过滤
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, _maskTexture, 0);

    // 这个 FBO 不需要深度缓冲，因为我们只是要把 MSAA 的颜色 Blit 过来

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: Resolve Framebuffer is not complete!" << std::endl;

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void OutlinePass::initQuad()
{
    // 标准的覆盖全屏的 NDC 坐标
    float quadVertices[] = {
        // positions   // texCoords
        -1.0f, 1.0f, 0.0f, 1.0f,
        -1.0f, -1.0f, 0.0f, 0.0f,
        1.0f, -1.0f, 1.0f, 0.0f,

        -1.0f, 1.0f, 0.0f, 1.0f,
        1.0f, -1.0f, 1.0f, 0.0f,
        1.0f, 1.0f, 1.0f, 1.0f};
    glGenVertexArrays(1, &_quadVAO);
    glGenBuffers(1, &_quadVBO);
    glBindVertexArray(_quadVAO);
    glBindBuffer(GL_ARRAY_BUFFER, _quadVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void *)(2 * sizeof(float)));
}

void OutlinePass::initShaders()
{
    // 1. Mask Shader: 将物体渲染为纯白色
    const char *maskVs = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;
        void main() {
            gl_Position = projection * view * model * vec4(aPos, 1.0);
        }
    )";
    const char *maskFs = R"(
        #version 330 core
        out vec4 FragColor; // 只写 GL_RED
        void main() {
            FragColor = vec4(1.0, 0.0, 0.0, 1.0); // R=1
        }
    )";
    _maskShader.reset(new GLSLProgram);
    _maskShader->attachVertexShader(maskVs);
    _maskShader->attachFragmentShader(maskFs);
    _maskShader->link();

    // 2. Post Shader: 边缘检测
    const char *postVs = R"(
        #version 330 core
        layout (location = 0) in vec2 aPos;
        layout (location = 1) in vec2 aTexCoords;
        out vec2 TexCoords;
        void main() {
            gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
            TexCoords = aTexCoords;
        }
    )";

    const char *postFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec2 TexCoords;

        uniform sampler2D maskTexture;
        uniform float outlineWidth; 
        uniform vec3 outlineColor; 

        void main() {
            vec2 texSize = textureSize(maskTexture, 0);
            vec2 px = 1.0 / texSize; 
            
            // 采样中心
            float center = texture(maskTexture, TexCoords).r;

            // [修复 1] 移除硬 Discard，改用透明度控制内边缘
            // 原代码: if (center > 0.8) discard; (导致内圈锯齿)
            // 新逻辑: 如果 center 很白(物体内部)，我们让 alpha 变 0；
            // 如果 center 是灰色(物体抗锯齿边缘)，我们让 alpha 慢慢变 0。
            // 这样轮廓线会平滑地“隐入”物体后面。
            float innerAlpha = 1.0 - smoothstep(0.5, 0.9, center);

            // 提前优化：如果完全在物体内部，就不需要做昂贵的搜索了
            if (innerAlpha <= 0.0) discard;

            // 2. 暴力搜索 + [修复 2] 亚像素精度补偿
            int radius = int(ceil(outlineWidth));
            float minDistance = 1000.0; 

            for (int x = -radius; x <= radius; x++) {
                for (int y = -radius; y <= radius; y++) {
                    
                    vec2 offset = vec2(x, y) * px;
                    float neighbor = texture(maskTexture, TexCoords + offset).r;

                    // 只要邻居不是全黑
                    if (neighbor > 0.01) {
                        float dist = length(vec2(x, y));

                        // [核心黑科技] 亚像素距离补偿
                        // 如果 neighbor 是 1.0 (全白)，说明边界在这个像素的更外侧，实际距离更近，减去 0.5
                        // 如果 neighbor 是 0.1 (很淡)，说明边界在这个像素的内侧，实际距离更远
                        // 公式：修正后的距离 = 像素中心距离 - (亮度 - 0.5)
                        // 这样生成的距离场会非常平滑，不再受像素网格限制
                        float subPixelCorrection = neighbor - 0.5;
                        dist -= subPixelCorrection;

                        minDistance = min(minDistance, dist);
                    }
                }
            }

            // 3. 渲染逻辑
            if (minDistance > outlineWidth) discard;

            // 4. 外边缘抗锯齿 (保持不变，这部分逻辑是对的)
            float outerAlpha = 1.0 - smoothstep(outlineWidth - 1.0, outlineWidth, minDistance);
            
            // 5. 最终 Alpha = 外边缘衰减 * 内边缘遮罩
            float finalAlpha = outerAlpha * innerAlpha;

            // 提升一点实心感 (Gamma校正)
            finalAlpha = pow(finalAlpha, 0.5);

            if (finalAlpha > 0.01) {
                FragColor = vec4(outlineColor, finalAlpha);
            } else {
                discard;
            }
        }
    )";
    _postShader.reset(new GLSLProgram);
    _postShader->attachVertexShader(postVs);
    _postShader->attachFragmentShader(postFs);
    _postShader->link();
}

void OutlinePass::render(GameObject *targetObj, Camera *camera, float contentScale, int width, int height)
{
    if (!targetObj)
        return;
    
    // [新增] 1. 保存进入函数时绑定的 FBO (即 _sceneFbo)
    GLint prevFbo;
    glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &prevFbo);

    if (width != _screenWidth || height != _screenHeight)
    {
        // 调用你现有的 onResize 函数重建 FBO
        onResize(width, height);
        
        // 注意：onResize 里已经更新了 _screenWidth 和 _screenHeight，
        // 所以下一帧不会重复进入这里。
    }

    GLint prevViewport[4];
    glGetIntegerv(GL_VIEWPORT, prevViewport);

    // ===========================================
    // Pass 1: 渲染到 MSAA FBO (生成高精度 Mask)
    // ===========================================
    glBindFramebuffer(GL_FRAMEBUFFER, _msaaFbo); // <--- 改为绑定 MSAA FBO
    glViewport(0, 0, _screenWidth, _screenHeight);
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    _maskShader->use();
    _maskShader->setUniformMat4("view", camera->getViewMatrix());
    _maskShader->setUniformMat4("projection", camera->getProjectionMatrix());

    // 遍历该物体的所有 Mesh 组件进行渲染
    for (const auto &comp : targetObj->components)
    {
        if (comp->getType() == ComponentType::MeshRenderer)
        {
            auto mesh = static_cast<MeshComponent *>(comp.get());
            if (!mesh->enabled)
                continue;
            // Gizmo 通常不画外框，跳过
            // if (mesh->isGizmo)
            //     continue;

            // 计算矩阵
            glm::mat4 modelMatrix = targetObj->transform.getLocalMatrix();
            modelMatrix = modelMatrix * mesh->model->transform.getLocalMatrix();
            _maskShader->setUniformMat4("model", modelMatrix);

			if (mesh->doubleSided) {
                glDisable(GL_CULL_FACE); // 允许绘制背面到 Mask
            }
            mesh->model->draw();
            if (mesh->doubleSided) {
                glEnable(GL_CULL_FACE); // 恢复背面剔除
            }
        }
    }

    // ===========================================
    // Pass 1.5: 将 MSAA Resolve 到普通纹理
    // ===========================================
    glBindFramebuffer(GL_READ_FRAMEBUFFER, _msaaFbo); // 源：MSAA
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, _fbo);     // 目标：Texture
    
    // 执行 Blit：硬件会自动混合 4 个采样点，生成平滑的边缘 (抗锯齿)
    glBlitFramebuffer(0, 0, _screenWidth, _screenHeight, 
                      0, 0, _screenWidth, _screenHeight, 
                      GL_COLOR_BUFFER_BIT, GL_NEAREST);

    // ===========================================
    // Pass 2: 边缘检测并叠加 (渲染到屏幕)
    // ===========================================
    // [修改] 2. 恢复之前保存的 FBO，而不是绑定 0
    glBindFramebuffer(GL_FRAMEBUFFER, prevFbo);

    glViewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);

    // 重要：我们需要在现有的画面上“叠加”外框，而不是覆盖
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_DEPTH_TEST); // 后处理是一个 2D 贴图，不需要深度测试

    _postShader->use();
    _postShader->setUniformVec3("outlineColor", glm::vec3(1.0, 0.6, 0.0)); // 橙色
    _postShader->setUniformFloat("outlineWidth", 3.0f * contentScale);     // 线宽 3

    glBindVertexArray(_quadVAO);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, _maskTexture); // 绑定刚才生成的黑白图
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glBindVertexArray(0);

    // 恢复状态
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
}
```

./engine/outline_pass.h:
```
#pragma once

#include <glad/gl.h>
#include <vector>
#include <memory>
#include <iostream>

#include "base/glsl_program.h"
#include "base/camera.h"
#include "engine/model.h"
#include "scene_object.h" // 为了访问 GameObject

class OutlinePass
{
public:
    OutlinePass(int screenWidth, int screenHeight);
    ~OutlinePass();

    // 当窗口大小改变时调用
    void onResize(int width, int height);

    // 核心渲染函数
    // 1. targetObj: 当前选中的物体
    // 2. camera: 当前相机 (需要视图和投影矩阵)
    void render(GameObject *targetObj, Camera *camera, float contentScale, int width, int height);

private:
    int _screenWidth, _screenHeight;

    // FBO 相关
    GLuint _fbo = 0;
    GLuint _maskTexture = 0;       // 存储黑白遮罩
    // GLuint _depthRenderBuffer = 0; // 深度缓冲 (即使是遮罩也需要深度测试来保证遮挡关系正确吗？通常做Outline时，我们希望Outline被前面的物体遮挡，所以需要深度)

    // [新增] MSAA FBO (用于渲染 Mask)
    GLuint _msaaFbo = 0;
    GLuint _msaaColorBuffer = 0; // 使用 RenderBuffer 而不是 Texture，因为不需要采样
    GLuint _msaaDepthBuffer = 0; // MSAA 深度缓冲

    // 全屏矩形资源
    GLuint _quadVAO = 0;
    GLuint _quadVBO = 0;

    // Shaders
    std::unique_ptr<GLSLProgram> _maskShader; // 用于把物体画成纯白
    std::unique_ptr<GLSLProgram> _postShader; // 用于边缘检测和混合

    void initFrameBuffer();
    void initQuad();
    void initShaders();
};
```

./engine/physics_utils.h:
```
#pragma once

#include <glm/glm.hpp>
#include <algorithm>
#include <limits>
#include "base/vertex.h"
#include "base/bounding_box.h" // 你的 base 里应该有这个，如果没有请看 Model 类里的定义

struct Ray
{
    glm::vec3 origin;
    glm::vec3 direction;

    Ray(const glm::vec3 &o, const glm::vec3 &d) : origin(o), direction(d) {}
};

class PhysicsUtils
{
public:
    // 射线与 AABB (轴对齐包围盒) 的相交检测
    // 算法：Slab Method
    // 输入：射线 (ray)，包围盒 (box)
    // 输出：是否相交，如果相交，tMin 返回交点距离
    static bool intersectRayAABB(const Ray &ray, const BoundingBox &box, float &tMinResult)
    {
        // 防止射线方向为 0 导致的除零异常
        if (glm::length(ray.direction) < 1e-6f) return false;

        float tMin = 0.0f;
        float tMax = std::numeric_limits<float>::max();

        glm::vec3 boxMin = box.min;
        glm::vec3 boxMax = box.max;

        // 对 X, Y, Z 三个轴分别进行检测
        for (int i = 0; i < 3; i++)
        {
            float invD = 1.0f / ray.direction[i];
            float t0 = (boxMin[i] - ray.origin[i]) * invD;
            float t1 = (boxMax[i] - ray.origin[i]) * invD;

            if (invD < 0.0f)
                std::swap(t0, t1);

            tMin = std::max(tMin, t0);
            tMax = std::min(tMax, t1);

            if (tMax <= tMin)
                return false;
        }

        tMinResult = tMin;
        return true;
    }

    // Ray-Triangle (Möller–Trumbore) - 精测
    static bool intersectRayTriangle(const Ray& ray, const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2, float& outT)
    {
        const float EPSILON = 0.0000001f;
        glm::vec3 edge1 = v1 - v0;
        glm::vec3 edge2 = v2 - v0;
        glm::vec3 h = glm::cross(ray.direction, edge2);
        float a = glm::dot(edge1, h);

        // 如果 a 接近 0，说明射线平行于三角形
        if (a > -EPSILON && a < EPSILON)
            return false;

        float f = 1.0f / a;
        glm::vec3 s = ray.origin - v0;
        float u = f * glm::dot(s, h);

        if (u < 0.0f || u > 1.0f)
            return false;

        glm::vec3 q = glm::cross(s, edge1);
        float v = f * glm::dot(ray.direction, q);

        if (v < 0.0f || u + v > 1.0f)
            return false;

        // 计算 t
        float t = f * glm::dot(edge2, q);

        if (t > EPSILON) // 射线相交
        {
            outT = t;
            return true;
        }
        return false;
    }

    // ==========================================
    // 3. Ray-Mesh - 遍历所有三角形
    // ==========================================
    // 输入：局部空间的射线、顶点列表、索引列表
    // 输出：是否击中，tMin 返回最近的距离
    static bool intersectRayMesh(const Ray& localRay, 
                                 const std::vector<Vertex>& vertices, 
                                 const std::vector<uint32_t>& indices, 
                                 float& tMin)
    {
        bool hit = false;
        float closestT = std::numeric_limits<float>::max();

        // 遍历所有三角形 (每次步进 3)
        for (size_t i = 0; i < indices.size(); i += 3)
        {
            const glm::vec3& v0 = vertices[indices[i]].position;
            const glm::vec3& v1 = vertices[indices[i+1]].position;
            const glm::vec3& v2 = vertices[indices[i+2]].position;

            float t = 0.0f;
            if (intersectRayTriangle(localRay, v0, v1, v2, t))
            {
                if (t < closestT)
                {
                    closestT = t;
                    hit = true;
                }
            }
        }

        if (hit)
        {
            tMin = closestT;
            return true;
        }
        return false;
    }
};
```

./engine/renderer.cpp:
```
#include "renderer.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp>

Renderer::Renderer() {
    // 构造函数可以留空，把初始化放在 init() 里更安全
}

Renderer::~Renderer() {
    // unique_ptr 和 shared_ptr 会自动释放资源
}

void Renderer::init() {
    glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
    // 1. 初始化 Shader (从 SceneRoaming::initShader 搬运过来)
    // 请将 vsCode, fsCode, gridVs, gridFs, skyVs, skyFs 的定义和 link 逻辑放在这里
    // 例如：
    // _mainShader.reset(new GLSLProgram);
    // _mainShader->attachVertexShader(vsCode); ...
    
    // [注意] 这里你需要把 SceneRoaming.cpp 里那一大段 const char* shader code 复制过来
    // ... (省略几百行 Shader 代码) ...
    // 调用 initShader(); 
    // 顶点着色器 (Vertex Shader)
    const char *vsCode = R"(
        #version 330 core
        layout(location = 0) in vec3 aPosition;
        layout(location = 1) in vec3 aNormal;
        layout(location = 2) in vec2 aTexCoord;

        out vec3 FragPos;
        out vec3 Normal;
        out vec2 TexCoord;

        out vec3 LocalPos;
        // 输出视空间深度 (或者直接用 gl_Position.w)
        out float ClipSpaceZ;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;

        void main() {
            vec4 worldPos = model * vec4(aPosition, 1.0);
            FragPos = vec3(worldPos);
            
            // 使用 Normal Matrix 修正法线 (防止非均匀缩放导致法线错误)
            Normal = mat3(transpose(inverse(model))) * aNormal;
            TexCoord = aTexCoord;

            LocalPos = aPosition;
            
            gl_Position = projection * view * worldPos;
            
            // 保存 View Space 的深度 (对于透视投影，w 分量就是 -ViewZ)
            // 用于 CSM 层级选择
            ClipSpaceZ = gl_Position.w;
        }
    )";

    // 片元着色器 (Fragment Shader) - Blinn-Phong 多光源版本
    const char *fsCode = R"(
        #version 330 core
        out vec4 FragColor;

        in vec3 FragPos;
        in vec3 Normal;
        in vec2 TexCoord;
        in vec3 LocalPos;
        in float ClipSpaceZ;

        // 材质定义
        struct Material {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            float shininess;

            float reflectivity;
            float refractionIndex;
            float transparency;
        }; 

        uniform sampler2D diffuseMap; 
        uniform bool hasDiffuseMap;
        uniform bool useTriplanar;
        uniform float triplanarScale;

        // 动态环境贴图
        uniform samplerCube envMap;
        uniform bool hasEnvMap;

        // 视差校正所需的 Uniforms
        uniform vec3 probePos;    // 探针拍摄时的中心位置 (世界坐标)
        uniform vec3 probeBoxMin; // 房间的最小边界 (世界坐标)
        uniform vec3 probeBoxMax; // 房间的最大边界 (世界坐标)

        // 平行光定义
        struct DirLight {
            vec3 direction;
            vec3 color;
            float intensity;
        };

        // 点光源定义
        struct PointLight {
            vec3 position;
            float constant;
            float linear;
            float quadratic;
            vec3 color;
            float intensity;
        };

        // 聚光灯定义
        struct SpotLight {
            vec3 position;
            vec3 direction;
            float cutOff;
            float outerCutOff;
            float constant;
            float linear;
            float quadratic;
            vec3 color;
            float intensity;
        };

        // 定义最大光源数量常量
        #define NR_POINT_LIGHTS 4
        #define NR_SPOT_LIGHTS 4

        uniform bool isUnlit;
        uniform bool isDoubleSided;
        uniform bool isDebug;

        uniform vec3 viewPos;
        uniform Material material;
        
        // 我们允许多个平行光(如多个太阳)
        #define NR_DIR_LIGHTS 2 
        uniform DirLight dirLights[NR_DIR_LIGHTS];
        uniform int dirLightCount; // 实际传入的数量

        uniform PointLight pointLights[NR_POINT_LIGHTS];
        uniform int pointLightCount;

        uniform SpotLight spotLights[NR_SPOT_LIGHTS];
        uniform int spotLightCount;

        // -----------------------------------------------------------
        // [新增] CSM 阴影相关 Uniforms
        // -----------------------------------------------------------
        // 纹理数组采样器 (Array + Shadow 比较)
        uniform sampler2DArrayShadow shadowMap; 
        
        // 级联矩阵数组 (建议使用 UBO，这里为了简单用 Uniform 数组)
        // 布局必须匹配 C++ 传递方式
        uniform mat4 lightSpaceMatrices[16]; 
        
        uniform float cascadePlaneDistances[16];
        uniform int cascadeCount;   
        uniform float shadowBias;

        // 函数声明
        vec4 getTriplanarSample(vec3 worldPos, vec3 normal);

        vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir, vec3 albedo);
        vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 albedo);
        vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 albedo);

        vec3 BoxProjectedCubemapDirection(vec3 worldPos, vec3 worldRefDir, vec3 pPos, vec3 boxMin, vec3 boxMax);

        float ShadowCalculation(vec3 fragPosWorld, vec3 normal, vec3 lightDir, float viewSpaceDepth);

		// 获取法线辅助函数
		vec3 getNormal() {
            // 归一化插值后的法线
            vec3 n = normalize(Normal);
            // 只有当物体明确开启了双面渲染(isDoubleSided == true)，
            // 并且我们正在渲染背面(!gl_FrontFacing)时，才反转法线。
            // 对于普通的球体/立方体，这段逻辑将被跳过，从而避免了 macOS 上的误判问题。
            if (isDoubleSided && !gl_FrontFacing) {
                n = -n; 
            }
            return n;
        }
        
        void main() {
            vec3 norm = getNormal();
            vec3 baseDiffuse = material.diffuse;

            // 1. 基础纹理采样
            if (hasDiffuseMap) {
                vec4 texColor;
                // 根据开关选择采样方式
                if (useTriplanar) {
                    texColor = getTriplanarSample(LocalPos, norm);
                } else {
                    texColor = texture(diffuseMap, TexCoord);
                }
                baseDiffuse = texColor.rgb * material.diffuse; 
            }

            // Unlit 模式直接返回
            if (isUnlit) {
                FragColor = vec4(baseDiffuse, 1.0); 
                return;
            }
            
            vec3 viewDir = normalize(viewPos - FragPos);

            // 计算阴影
            // 假设 dirLights[0] 是产生阴影的主光源 (太阳)
            float shadow = 1.0;
            if (dirLightCount > 0) {
                vec3 lightDir = normalize(-dirLights[0].direction);
                // 传入 ClipSpaceZ 用于级联选择
                shadow = ShadowCalculation(FragPos, norm, lightDir, ClipSpaceZ);
            }
            
            // 2. 计算标准 Phong 光照
            // 先计算全局基础环境光
            // 我们可以取一个固定的环境光颜色，或者取第一个平行光的颜色作为环境基调
            // 这里为了简单，我们假设环境光是白色的微弱光 (0.05 强度) * 材质的环境光系数
            vec3 ambient = vec3(0.05) * material.ambient;
            
            // 如果有平行光，我们可以用第一个平行光的颜色来影响环境光，稍微自然一点（可选）
            if (dirLightCount > 0) {
                ambient = dirLights[0].color * 0.1 * material.ambient; 
            }

            // 初始化 result 为环境光
            vec3 result = ambient;

            for(int i = 0; i < dirLightCount; i++) {
                // 只有第一个平行光投射阴影
                float s = (i == 0) ? shadow : 1.0; 
                result += CalcDirLight(dirLights[i], norm, viewDir, baseDiffuse) * s; 
            }
            
            for(int i = 0; i < pointLightCount; i++)
                result += CalcPointLight(pointLights[i], norm, FragPos, viewDir, baseDiffuse);
                
            for(int i = 0; i < spotLightCount; i++)
                result += CalcSpotLight(spotLights[i], norm, FragPos, viewDir, baseDiffuse);

            // 3. 环境反射与折射
            if (hasEnvMap) {
                vec3 I = normalize(FragPos - viewPos); // 视线向量 I
                vec3 N = norm;                         // 法线 N

                // ------------------------------------------
                // 1. 计算菲涅尔系数 (Fresnel)
                // ------------------------------------------
                // 描述：视线与法线越垂直(边缘)，反射越强(F接近1)；越平行(中心)，折射越强(F接近0)
                // F0 是基础反射率：
                //   - 水/玻璃等非金属 (Dielectric) 约为 0.04
                //   - 金属 (Metal) 约为 material.diffuse 颜色本身
                // 我们用 reflectivity 参数来控制这个 F0
                float F0_val = mix(0.04, 1.0, material.reflectivity);
                vec3 F0 = vec3(F0_val);
                
                // Schlick 近似公式
                float cosTheta = clamp(dot(N, -I), 0.0, 1.0);
                vec3 F = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);

                // ------------------------------------------
                // 2. 计算反射 (Reflection)
                // ------------------------------------------
                vec3 reflectColor = vec3(0.0);
                {
                    vec3 R = reflect(I, N);
                    // 应用视差校正
                    vec3 correctedR = BoxProjectedCubemapDirection(FragPos, R, probePos, probeBoxMin, probeBoxMax);
                    reflectColor = texture(envMap, correctedR).rgb;
                }

                // ------------------------------------------
                // 3. 计算折射 + 色散 (Refraction + Dispersion)
                // ------------------------------------------
                vec3 refractColor = vec3(0.0);
                if (material.transparency > 0.01) {
                    // 基础折射率比
                    float k = (material.refractionIndex < 1.0) ? 1.0 : material.refractionIndex;
                    float ratio = 1.00 / k;
                    
                    // [色散核心]：为 R, G, B 通道使用微小差异的折射率
                    // 0.01 ~ 0.02 的偏移量通常能产生很好的钻石/厚玻璃效果
                    float dispersion = 0.02; 
                    
                    vec3 R_r = refract(I, N, ratio * (1.0 - dispersion)); // 红光折射少
                    vec3 R_g = refract(I, N, ratio);                      // 绿光居中
                    vec3 R_b = refract(I, N, ratio * (1.0 + dispersion)); // 蓝光折射多

                    // 分别对 R, G, B 进行视差校正采样
                    vec3 correctedR_r = BoxProjectedCubemapDirection(FragPos, R_r, probePos, probeBoxMin, probeBoxMax);
                    vec3 correctedR_g = BoxProjectedCubemapDirection(FragPos, R_g, probePos, probeBoxMin, probeBoxMax);
                    vec3 correctedR_b = BoxProjectedCubemapDirection(FragPos, R_b, probePos, probeBoxMin, probeBoxMax);

                    // 分别采样并组合
                    float r = texture(envMap, correctedR_r).r;
                    float g = texture(envMap, correctedR_g).g;
                    float b = texture(envMap, correctedR_b).b;
                    
                    refractColor = vec3(r, g, b);
                }

                // ------------------------------------------
                // 4. 最终物理混合 (Mix based on Fresnel)
                // ------------------------------------------
                // 如果物体是透明的 (transparency > 0)
                // 最终颜色 = 反射 * F + 折射 * (1 - F)
                // 这种混合方式保证了能量守恒：光线要么反射走，要么折射进去
                
                vec3 glassColor = mix(refractColor, reflectColor, F);
                
                // 最后，我们要把这个“玻璃计算结果”和物体原本的颜色(Phong光照)混合
                // 如果 transparency = 1.0 (全透明)，我们只显示 glassColor
                // 如果 transparency = 0.0 (不透明)，我们主要显示 result (Phong光照) + 表面反射
                
                if (material.transparency > 0.01) {
                    // 全透明模式：忽略漫反射本身，只保留高光
                    // (玻璃本身几乎没有漫反射，只有镜面反射和折射)
                    // 我们保留一点 result 里的 specular 高光
                    result = glassColor + (result * 0.1); // 这里的 0.1 是为了防止全黑，保留一点环境光感
                } else {
                    // 不透明模式 (金属)：简单的反射叠加
                    // 金属也是由 Fresnel 控制的
                    result = mix(result, reflectColor, material.reflectivity * F); 
                }
            }

            FragColor = vec4(result, 1.0);

            if (isDebug) {
                if (gl_FrontFacing) {
                    FragColor = vec4(1.0, 0.4, 0.4, 1.0); // 红
                } else {
                    FragColor = vec4(0.4, 1.0, 0.4, 1.0); // 绿
                }
            }

            int layer = -1;
    for (int i = 0; i < cascadeCount; ++i) {
        if (ClipSpaceZ < cascadePlaneDistances[i]) {
            layer = i;
            break;
        }
    }
    if (layer == -1) layer = cascadeCount;

    vec3 debugColor = vec3(0.0);
    if (layer == 0) debugColor = vec3(1.0, 0.0, 0.0); // 红: 近处 (0-10m)
    else if (layer == 1) debugColor = vec3(0.0, 1.0, 0.0); // 绿: 中近 (10-60m)
    else if (layer == 2) debugColor = vec3(0.0, 0.0, 1.0); // 蓝: 中远 (50-250m)
    else if (layer == 3) debugColor = vec3(1.0, 1.0, 0.0); // 黄: 最远 (250m - zFar)
    else debugColor = vec3(1.0, 0.0, 1.0); // 紫: 错误/超出范围

    // 将调试颜色以 20% 的强度混合到最终结果中
    FragColor = vec4(mix(FragColor.rgb, debugColor, 0.2), 1.0);
        }

        // --- 函数实现 ---

        vec4 getTriplanarSample(vec3 position, vec3 normal) {
            // 1. 计算混合权重
            // 使用幂函数 (pow) 增加对比度，让主轴方向的纹理更清晰，侧面的纹理快速衰减
            // 这里的 4.0 是“锐度”，数值越大，交界处越硬；数值越小，交界处越模糊
            vec3 blending = abs(normal);
            blending = pow(blending, vec3(4.0)); 
            
            // 归一化权重，确保加起来等于 1
            float b = (blending.x + blending.y + blending.z);
            blending /= vec3(b, b, b);

            // 2. [核心修改] 使用传入的 position (将是 LocalPos) 计算 UV
            vec2 uvX = position.zy * triplanarScale;
            vec2 uvY = position.xz * triplanarScale;
            vec2 uvZ = position.xy * triplanarScale;

            // 3. 采样三次
            vec4 colX = texture(diffuseMap, uvX);
            vec4 colY = texture(diffuseMap, uvY);
            vec4 colZ = texture(diffuseMap, uvZ);

            // 4. 混合结果
            return colX * blending.x + colY * blending.y + colZ * blending.z;
        }

        vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir, vec3 albedo) {
            vec3 lightDir = normalize(-light.direction);
            // 漫反射
            float diff = max(dot(normal, lightDir), 0.0);
            // 镜面反射 (Blinn-Phong)
            vec3 halfwayDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
            // 合并
            vec3 diffuse = light.color * light.intensity * diff * albedo;
            vec3 specular = light.color * light.intensity * spec * material.specular;
            return (diffuse + specular);
        }

        vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 albedo) {
            vec3 lightDir = normalize(light.position - fragPos);
            // 衰减
            float distance = length(light.position - fragPos);
            float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
            // 漫反射
            float diff = max(dot(normal, lightDir), 0.0);
            // 镜面反射
            vec3 halfwayDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
            // 合并
            vec3 diffuse = light.color * light.intensity * diff * attenuation * albedo;
            vec3 specular = light.color * light.intensity * spec * material.specular * attenuation;
            return (diffuse + specular);
        }

        vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 albedo) {
            vec3 lightDir = normalize(light.position - fragPos);
            // 衰减
            float distance = length(light.position - fragPos);
            float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
            // 聚光强度 (Soft edges)
            float theta = dot(lightDir, normalize(-light.direction)); 
            float epsilon = light.cutOff - light.outerCutOff;
            float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
            
            // 漫反射
            float diff = max(dot(normal, lightDir), 0.0);
            // 镜面反射
            vec3 halfwayDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
            // 合并
            vec3 diffuse = light.color * light.intensity * diff * attenuation * intensity * albedo;
            vec3 specular = light.color * light.intensity * spec * material.specular * attenuation * intensity;
            return (diffuse + specular);
        }

        // Box Projection
        // worldPos: 当前片元的世界坐标
        // worldRefDir: 原始反射向量
        vec3 BoxProjectedCubemapDirection(vec3 worldPos, vec3 worldRefDir, vec3 pPos, vec3 boxMin, vec3 boxMax) {
            vec3 nrdir = normalize(worldRefDir);
            
            // 1. 计算射线与 Box 6个面的交点距离 (类似于 AABB 碰撞检测)
            vec3 rbmax = (boxMax - worldPos) / nrdir;
            vec3 rbmin = (boxMin - worldPos) / nrdir;

            // 2. 找出正向射线的交点 (只关心反射方向那一侧的墙)
            vec3 rbminmax;
            rbminmax.x = (nrdir.x > 0.0) ? rbmax.x : rbmin.x;
            rbminmax.y = (nrdir.y > 0.0) ? rbmax.y : rbmin.y;
            rbminmax.z = (nrdir.z > 0.0) ? rbmax.z : rbmin.z;

            // 3. 取最小的正距离 (最近的交点)
            float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);

            // 4. 计算交点位置
            vec3 posonbox = worldPos + nrdir * fa;

            // 5. 将交点转换为相对于探针中心的向量
            return posonbox - pPos;
        }

        vec2 poissonDisk[16] = vec2[]( 
            vec2( -0.94201624, -0.39906216 ),
            vec2( 0.94558609, -0.76890725 ),
            vec2( -0.094184101, -0.92938870 ),
            vec2( 0.34495938, 0.29387760 ),
            vec2( -0.91588581, 0.45771432 ),
            vec2( -0.81544232, -0.87912464 ),
            vec2( -0.38277543, 0.27676845 ),
            vec2( 0.97484398, 0.75648379 ),
            vec2( 0.44323325, -0.97511554 ),
            vec2( 0.53742981, -0.47373420 ),
            vec2( -0.26496911, -0.41893023 ),
            vec2( 0.79197514, 0.19090188 ),
            vec2( -0.24188840, 0.99706507 ),
            vec2( -0.81409955, 0.91437590 ),
            vec2( 0.19984126, 0.78641367 ),
            vec2( 0.14383161, -0.14100790 )
        );

        // 随机函数 (生成伪随机噪声)
        float random(vec3 seed, int i){
            vec4 seed4 = vec4(seed, i);
            float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
            return fract(sin(dot_product) * 43758.5453);
        }

        // 阴影计算函数 (PCF + Bias)
        // 返回 0.0 (全阴影) 到 1.0 (无阴影)
        float ShadowCalculation(vec3 fragPosWorld, vec3 normal, vec3 lightDir, float viewSpaceDepth)
        {
            // 1. 选择级联层级
            int layer = -1;
            for (int i = 0; i < cascadeCount; ++i) {
                if (viewSpaceDepth < cascadePlaneDistances[i]) {
                    layer = i;
                    break;
                }
            }
            if (layer == -1) layer = cascadeCount;

            // ------------------------------------------------------------------
            // [核心修复]：混合权重计算 (同时考虑 Z轴 和 UV边界)
            // ------------------------------------------------------------------
            
            // A. 计算 Z 轴混合权重 (基于视锥分割距离)
            float blendFactor = 0.0;
            int nextLayer = layer + 1;
            if (nextLayer > cascadeCount) nextLayer = cascadeCount; // 保护
            
            if (layer < cascadeCount) {
                float splitDist = cascadePlaneDistances[layer];
                float distToEdge = splitDist - viewSpaceDepth;
                float blendBand = 5.0; // Z轴混合带宽度
                
                if (distToEdge < blendBand) {
                    blendFactor = 1.0 - (distToEdge / blendBand);
                }
            }

            // B. 计算 UV 边缘混合权重 (防止侧面漏光/阴影截断)
            // 我们提前计算当前层在光空间的位置，看看是否快出界了
            vec4 fragPosLightSpace = lightSpaceMatrices[layer] * vec4(fragPosWorld, 1.0);
            vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
            projCoords = projCoords * 0.5 + 0.5;

            // 计算当前点距离纹理中心的距离 (0~0.5)
            vec2 distFromCenter = abs(projCoords.xy - 0.5);
            // 找出最远的那个轴
            float maxDist = max(distFromCenter.x, distFromCenter.y);
            
            // 定义边缘阈值：从 0.4 (80%处) 开始混合，到 0.49 (98%处) 完全切换到下一层
            // 这样保证在出界(0.5)之前，我们已经完全切换到了下一层
            float uvBlendFactor = smoothstep(0.4, 0.49, maxDist);

            // [关键]：最终混合权重取 Z轴 和 UV边缘 的最大值
            // 这意味着：即使 Z 轴认为不需要混合，如果 UV 快出界了，也强制混合！
            blendFactor = max(blendFactor, uvBlendFactor);
            
            // 如果已经是最后一层了，就不能再往后混合了，避免采样越界
            if (layer == cascadeCount) {
                blendFactor = 0.0; 
            }

            // ------------------------------------------------------------------
            // 下面是通用的 PCF 采样逻辑 (基本不用动)
            // ------------------------------------------------------------------
            
            vec3 N = normalize(normal);
            vec3 L = normalize(lightDir);
            float cosTheta = clamp(dot(N, L), 0.0, 1.0);
            float baseBias = shadowBias * (1.0 - cosTheta);
            baseBias = max(baseBias, shadowBias * 0.1);

            // 泊松旋转
            float rotAngle = random(vec3(gl_FragCoord.xy, 1.0), 0) * 6.283185;
            float s = sin(rotAngle); float c = cos(rotAngle);
            mat2 rot = mat2(c, -s, s, c);

            // 采样循环：如果 blendFactor > 0，我们需要采样两层
            int layersToSample = (blendFactor > 0.001) ? 2 : 1;
            float layerShadows[2]; 
            layerShadows[0] = 1.0; layerShadows[1] = 1.0; // 默认为1.0(亮)

            for (int i = 0; i < layersToSample; ++i) 
            {
                int currentLayer = (i == 0) ? layer : nextLayer;
                
                // 计算当前层级的坐标
                vec4 fPosLight = lightSpaceMatrices[currentLayer] * vec4(fragPosWorld, 1.0);
                vec3 pCoords = fPosLight.xyz / fPosLight.w;
                pCoords = pCoords * 0.5 + 0.5;

                // 越界检查 (如果出界，直接返回无阴影，交由混合逻辑处理)
                if(pCoords.z > 1.0 || pCoords.x < 0.0 || pCoords.x > 1.0 || pCoords.y < 0.0 || pCoords.y > 1.0) {
                    layerShadows[i] = 1.0; 
                    continue; 
                }

                // 计算 Bias
                vec3 N = normalize(normal);
                vec3 L = normalize(lightDir);
                float cosTheta = clamp(dot(N, L), 0.0, 1.0);
                
                // 基础 Bias
                float baseBias = shadowBias * (1.0 - cosTheta);
                baseBias = max(baseBias, shadowBias * 0.1);

                if (currentLayer == 1) baseBias *= 0.5;
                else if (currentLayer == 2) baseBias *= 0.25;
                else if (currentLayer == 3) baseBias *= 0.125;

                float currentDepth = pCoords.z - baseBias;
                
                // 设置 PCF 半径
                float filterRadius = 1.0;
                if (currentLayer == 0) filterRadius = 4.0;
                else if (currentLayer == 1) filterRadius = 2.0;
                else if (currentLayer == 2) filterRadius = 1.0;
                else filterRadius = 0.5;

                vec2 texSize = 1.0 / textureSize(shadowMap, 0).xy;
                
                float shadowSum = 0.0;
                for(int k = 0; k < 16; ++k)
                {
                    vec2 offset = rot * poissonDisk[k];
                    shadowSum += texture(shadowMap, vec4(pCoords.xy + offset * texSize * filterRadius, currentLayer, currentDepth));
                }
                layerShadows[i] = shadowSum / 16.0; 
            }

            // 最终混合
            float finalVisibility = layerShadows[0];
            if (layersToSample > 1) {
                finalVisibility = mix(layerShadows[0], layerShadows[1], blendFactor);
            }
            
            return finalVisibility; 
        }
    )";

    _mainShader.reset(new GLSLProgram);
    _mainShader->attachVertexShader(vsCode);
    _mainShader->attachFragmentShader(fsCode);
    _mainShader->link();

    // =============================================================
    // 1. 无限网格 Shader (Unity 风格)
    // =============================================================
    const char* gridVs = R"(
        #version 330 core
        layout(location = 0) in vec3 aPos;
        uniform mat4 view;
        uniform mat4 projection;
        uniform vec3 viewPos;
        
        out vec3 WorldPos;
        out float Near;
        out float Far;

        void main() {
            // 我们把一个小的平面放大很多倍来模拟无限
            vec3 pos = aPos * 1000.0; // 放大平面
            pos.y = 0.0; // 强制在 XZ 平面
            WorldPos = pos;
            gl_Position = projection * view * vec4(pos, 1.0);
            
            // 传递裁剪面信息用于淡出计算
            Near = 0.1; 
            Far = 100.0; 
        }
    )";

    const char* gridFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec3 WorldPos;
        in float Near;
        in float Far;

        uniform vec3 viewPos;

        void main() {
            vec2 coord = WorldPos.xz;
            vec2 derivative = fwidth(coord);
            
            // --- 基础参数 ---
            // 亮白色线条，在深色背景下更清晰
            vec3 gridColor = vec3(0.7, 0.7, 0.7); 
            
            // 1. 绘制小格子 (1米)
            vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;
            float line = min(grid.x, grid.y);
            float minimumz = min(derivative.y, 1.0);
            float minimumx = min(derivative.x, 1.0);
            
            // 小格子透明度低一点 (0.3)
            vec4 color = vec4(gridColor, 0.3 * (1.0 - min(line, 1.0))); 

            // 2. 绘制大格子 (10米)
            vec2 coord2 = coord / 10.0;
            vec2 derivative2 = fwidth(coord2);
            vec2 grid2 = abs(fract(coord2 - 0.5) - 0.5) / derivative2;
            float line2 = min(grid2.x, grid2.y);
            
            // 如果是大格子线，透明度高一点 (0.8)，覆盖小格子
            if(1.0 - min(line2, 1.0) > 0.1) {
                color = vec4(gridColor, 0.8 * (1.0 - min(line2, 1.0)));
            }

            // 3. 轴线高亮 (X轴红色，Z轴蓝色) - 类似 Unity 编辑器
            // 当 z 接近 0 时是 X 轴
            // if(abs(WorldPos.z) < 0.05) color = vec4(1.0, 0.2, 0.2, 1.0); // Red X-Axis
            // 当 x 接近 0 时是 Z 轴
            // if(abs(WorldPos.x) < 0.05) color = vec4(0.2, 0.2, 1.0, 1.0); // Blue Z-Axis

            // 4. 距离淡出 (Fade out)
            float dist = distance(viewPos.xz, WorldPos.xz);
            float alpha = 1.0 - smoothstep(10.0, 400.0, dist);
            color.a *= alpha;

            if (color.a <= 0.0) discard;
            FragColor = color;
        }
    )";

    _gridShader.reset(new GLSLProgram);
    _gridShader->attachVertexShader(gridVs);
    _gridShader->attachFragmentShader(gridFs);
    _gridShader->link();

    // =============================================================
    // 2. 程序化天空盒 Shader (Unity 默认风格)
    // =============================================================
    const char* skyVs = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        out vec3 TexCoords;
        uniform mat4 projection;
        uniform mat4 view;

        void main() {
            TexCoords = aPos;
            // 移除平移分量，让天空盒永远跟着相机
            vec4 pos = projection * mat4(mat3(view)) * vec4(aPos, 1.0);
            
            // [技巧] 让天空盒永远在深度测试的最远处 (z = w, 透视除法后 z/w = 1.0)
            gl_Position = pos.xyww; 
        }
    )";

    const char* skyFs = R"(
        #version 330 core
        out vec4 FragColor;
        in vec3 TexCoords;

        void main() {
            vec3 dir = normalize(TexCoords);
            float y = dir.y;

            // =========================================================
            // [配色方案] 
            // =========================================================
            
            // 1. 地面颜色 (Deep Dark Gray)
            vec3 colGround = vec3(0.2, 0.2, 0.2); 

            // 2. 地平线颜色 (Horizon Fog)
            // [修改]: 稍微提亮一点，增加一点“厚重感”和不透明度
            vec3 colHorizon = vec3(0.7, 0.75, 0.82); 

            // 3. 天顶颜色 (Sky Zenith)
            vec3 colZenith  = vec3(0.2, 0.45, 0.8); 

            vec3 finalColor;

            // =========================================================
            // [混合逻辑] 
            // =========================================================
            
            if (y < 0.0) {
                // --- 地下部分 ---
                
                // [核心改进 1: 平滑过渡]
                // 原代码这里使用了 colHorizon * 0.5，导致和上半部分产生接缝。
                // 我们现在直接从 colHorizon 开始，确保 y=0 处无缝连接。

                // [核心改进 2: 加大雾气密度]
                // 我们不改变 -0.2 这个范围，而是改变混合曲线的"形状"。
                // 原始线性混合会让地面黑得太快。
                // 这里先算出线性因子 factorLinear (0.0 到 1.0)
                float factorLinear = smoothstep(0.0, -0.2, y);
                
                // 使用 pow 函数处理因子。
                // 0.4 的指数会让混合因子在接近 0 (地平线) 的地方停留更久，
                // 从而让雾气颜色"渗"入地面更多，看起来雾更浓，但并没有扩大实际渲染范围。
                float factorCurved = pow(factorLinear, 0.4); 

                finalColor = mix(colHorizon, colGround, factorCurved); 
            } 
            else {
                // --- 天空部分 ---
                
                // 同样为了增加雾气感，我们让天顶蓝色的出现稍微"迟"一点
                // 0.5 的指数比原来的 0.7 更小，意味着白色雾气会向上延伸得更有力
                float t = pow(y, 0.5); 
                finalColor = mix(colHorizon, colZenith, t);
            }

            // [色调映射] (可选) 
            // 加上轻微的 Gamma 矫正或 Tone Mapping 可以让雾气看起来更柔和
            // finalColor = pow(finalColor, vec3(1.0/2.2)); 

            FragColor = vec4(finalColor, 1.0);
        }
    )";

    _skyboxShader.reset(new GLSLProgram);
    _skyboxShader->attachVertexShader(skyVs);
    _skyboxShader->attachFragmentShader(skyFs);
    _skyboxShader->link();

    // 2. 初始化模型资源
    _gridPlane = GeometryFactory::createPlane(2.0f, 2.0f);
    _skyboxCube = GeometryFactory::createCube(1.0f);

    // 3. 初始化 OutlinePass (初始大小可以给 0 或窗口大小，后面 onResize 会修)
    _outlinePass = std::make_unique<OutlinePass>(1920, 1080);

    // 4. 初始化 ShadowMapPass
    _shadowPass = std::make_unique<ShadowMapPass>(4096);
}

void Renderer::onResize(int width, int height) {
    if (_outlinePass) {
        _outlinePass->onResize(width, height);
    }
}

void Renderer::render(const Scene& scene, Camera* camera, 
                      GLuint targetFBO, int width, int height, 
                      float contentScale,
                      GameObject* selectedObj)
{
    // ===============================================
    // Pass -1: 烘焙反射探针 (Bake Reflection Probes)
    // ===============================================
    // 在渲染主画面之前，先更新场景里的“镜子”所看到的景象
    updateReflectionProbes(scene);

    // ===============================================
    // Pass -0.5: Render Shadows (Shadow Mapping) [新增]
    // ===============================================
    // 找到主光源
    LightComponent* mainLight = nullptr;
    glm::vec3 lightDir(0, -1, 0);
    
    for (const auto& go : scene.getGameObjects()) {
        auto light = go->getComponent<LightComponent>();
        if (light && light->enabled && light->type == LightType::Directional) {
            lightDir = go->transform.rotation * glm::vec3(0, 0, -1);
            mainLight = light; // 记录下来
            break; 
        }
    }
    
    float nBias = mainLight ? mainLight->shadowNormalBias : 0.0f; // 获取 Normal Bias

    unsigned int cullMode = mainLight ? mainLight->shadowCullFace : GL_BACK;

    // CSM 不需要 shadowProjectionSize (因为它会自动计算视锥切片大小)，或者你可以保留它用于非透视相机
    // 这里我们依然调用 render，shadowPass 内部会处理多级渲染
    _shadowPass->render(scene, lightDir, camera, nBias, cullMode);

    // 1. 绑定目标 FBO
    glBindFramebuffer(GL_FRAMEBUFFER, targetFBO);
    glViewport(0, 0, width, height);

    // 2. 清屏
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);

    // 3. 准备矩阵
    glm::mat4 view = camera->getViewMatrix();
    glm::mat4 proj = camera->getProjectionMatrix();
    glm::vec3 viewPos = camera->transform.position;

    // 绑定 CSM 纹理数组 (Texture Array) 到 Slot 2
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _shadowPass->getDepthMapArray());

    // --- Pass 0: 天空盒 ---
    drawSkybox(view, proj);

    // --- Pass 1 & 2: 物体渲染 (光照 + 绘制) ---
    drawSceneObjects(scene, view, proj, viewPos);

    // --- Pass 2.5: 网格 ---
    drawGrid(view, proj, viewPos);

    // --- Pass 3: 描边 ---
    if (selectedObj) {
        // OutlinePass 需要传入宽高用于重新生成纹理
        _outlinePass->render(selectedObj, camera, contentScale, width, height);
        
        // 恢复 FBO 绑定 (防止 OutlinePass 内部解绑)
        glBindFramebuffer(GL_FRAMEBUFFER, targetFBO);
    }

    // 解绑
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// === 下面是将 SceneRoaming::renderScene 中的逻辑拆分出来的私有函数 ===

void Renderer::drawSkybox(const glm::mat4& view, const glm::mat4& proj) {
    glDepthFunc(GL_LEQUAL);
    _skyboxShader->use();
    _skyboxShader->setUniformMat4("view", view);
    _skyboxShader->setUniformMat4("projection", proj);
    
    glDisable(GL_CULL_FACE);
    _skyboxCube->draw();
    glEnable(GL_CULL_FACE);
    
    glDepthFunc(GL_LESS);
}

void Renderer::drawGrid(const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos) {
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDepthMask(GL_FALSE);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(-1.0f, -1.0f);
    glDisable(GL_CULL_FACE);

    _gridShader->use();
    _gridShader->setUniformMat4("view", view);
    _gridShader->setUniformMat4("projection", proj);
    _gridShader->setUniformVec3("viewPos", viewPos);
    
    _gridPlane->draw();

    glEnable(GL_CULL_FACE);
    glDisable(GL_POLYGON_OFFSET_FILL);
    glDepthFunc(GL_LESS);
    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
}

void Renderer::drawSceneObjects(const Scene& scene, const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos, const GameObject* excludeObject) {
    _mainShader->use();
    _mainShader->setUniformMat4("projection", proj);
    _mainShader->setUniformMat4("view", view);
    _mainShader->setUniformVec3("viewPos", viewPos);

    _mainShader->setUniformBool("isDebug", false);

    // 1. 告诉 Shader 阴影图在 Slot 2
    _mainShader->setUniformInt("shadowMap", 2); 

    // 2. 传递矩阵数组 (lightSpaceMatrices[16])
    const auto& matrices = _shadowPass->getLightSpaceMatrices();
    if (!matrices.empty()) {
        GLint loc = glGetUniformLocation(_mainShader->getHandle(), "lightSpaceMatrices");
        if (loc != -1) {
            glUniformMatrix4fv(loc, (GLsizei)matrices.size(), GL_FALSE, glm::value_ptr(matrices[0]));
        }
    }

    // 3. 传递级联分割距离 (cascadePlaneDistances[16])
    const auto& levels = _shadowPass->getCascadeLevels();
    if (!levels.empty()) {
        GLint loc = glGetUniformLocation(_mainShader->getHandle(), "cascadePlaneDistances");
        if (loc != -1) {
            glUniform1fv(loc, (GLsizei)levels.size(), levels.data());
        }
        _mainShader->setUniformInt("cascadeCount", (int)levels.size());
    }

    glFrontFace(GL_CCW);

    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    // 1. 收集光源 (Lighting Loop)
    int dirCount = 0, pointCount = 0, spotCount = 0;
    
    for (const auto& go : scene.getGameObjects()) {
        auto light = go->getComponent<LightComponent>();
        if (light && light->enabled) {
            // ... (复制 SceneRoaming 中的光源收集逻辑，注意变量名 go->transform) ...
            // 注意：这里需要原封不动地把那段长长的 if/else light type 判断拷过来
            // 并调用 _mainShader->setUniform...
            std::string baseName;
            if (light->type == LightType::Directional && dirCount < 2)
            {
                baseName = "dirLights[" + std::to_string(dirCount++) + "]";
                glm::vec3 dir = go->transform.rotation * glm::vec3(0, 0, -1);
                _mainShader->setUniformVec3(baseName + ".direction", dir);
                _mainShader->setUniformFloat("shadowBias", light->shadowBias);
            }
            else if (light->type == LightType::Point && pointCount < 4)
            {
                baseName = "pointLights[" + std::to_string(pointCount++) + "]";
                _mainShader->setUniformVec3(baseName + ".position", go->transform.position);
                _mainShader->setUniformFloat(baseName + ".constant", light->constant);
                _mainShader->setUniformFloat(baseName + ".linear", light->linear);
                _mainShader->setUniformFloat(baseName + ".quadratic", light->quadratic);

                // 同步 Gizmo 颜色
                if (auto mesh = go->getComponent<MeshComponent>()) {
                    if (mesh->isGizmo) mesh->material.diffuse = light->color;
                }
            }
            else if (light->type == LightType::Spot && spotCount < 4)
            {
                baseName = "spotLights[" + std::to_string(spotCount++) + "]";
                _mainShader->setUniformVec3(baseName + ".position", go->transform.position);
                glm::vec3 dir = go->transform.rotation * glm::vec3(0.0f, 0.0f, -1.0f);
                _mainShader->setUniformVec3(baseName + ".direction", dir);
                _mainShader->setUniformFloat(baseName + ".cutOff", light->cutOff);
                _mainShader->setUniformFloat(baseName + ".outerCutOff", light->outerCutOff);
                _mainShader->setUniformFloat(baseName + ".constant", light->constant);
                _mainShader->setUniformFloat(baseName + ".linear", light->linear);
                _mainShader->setUniformFloat(baseName + ".quadratic", light->quadratic);

                if (auto mesh = go->getComponent<MeshComponent>()) {
                    if (mesh->isGizmo) mesh->material.diffuse = light->color;
                }
            }

            if (!baseName.empty())
            {
                _mainShader->setUniformVec3(baseName + ".color", light->color);
                _mainShader->setUniformFloat(baseName + ".intensity", light->intensity);
            }
        }
    }
    _mainShader->setUniformInt("dirLightCount", dirCount);
    _mainShader->setUniformInt("pointLightCount", pointCount);
    _mainShader->setUniformInt("spotLightCount", spotCount);

    _mainShader->setUniformInt("diffuseMap", 0);

    // 2. 绘制物体 (Mesh Loop)
    for (const auto& go : scene.getGameObjects()) {
        // 排除特定物体 (防止烘焙时自己遮挡自己)
        if (excludeObject && go.get() == excludeObject) continue;

        auto meshComp = go->getComponent<MeshComponent>();
        if (!meshComp || !meshComp->enabled) continue;
        
        auto lightComp = go->getComponent<LightComponent>();
        
        // 双面渲染处理
        if (meshComp->doubleSided) glDisable(GL_CULL_FACE);

        // 纹理绑定
        if (meshComp->diffuseMap) {
            meshComp->diffuseMap->bind(0); // Bind to Slot 0
            _mainShader->setUniformBool("hasDiffuseMap", true);
        } else {
            _mainShader->setUniformBool("hasDiffuseMap", false);
            // 为了安全，解绑 Slot 0 或者绑定一个白色纹理
            // Texture2D::unbind() 是静态的或者解绑当前，这里简单处理：
            // 只要 hasDiffuseMap 是 false，Shader 就不会采样，所以不解绑也行，
            // 但为了防止状态污染，最好解绑。
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        
        _mainShader->setUniformBool("isUnlit", meshComp->isGizmo);
        _mainShader->setUniformBool("isDoubleSided", meshComp->doubleSided);
        _mainShader->setUniformVec3("material.ambient", meshComp->material.ambient);
        _mainShader->setUniformVec3("material.diffuse", meshComp->material.diffuse);
        _mainShader->setUniformVec3("material.specular", meshComp->material.specular);
        _mainShader->setUniformFloat("material.shininess", meshComp->material.shininess);

        _mainShader->setUniformFloat("material.reflectivity", meshComp->material.reflectivity);
        _mainShader->setUniformFloat("material.refractionIndex", meshComp->material.refractionIndex);
        _mainShader->setUniformFloat("material.transparency", meshComp->material.transparency);

        _mainShader->setUniformBool("useTriplanar", meshComp->useTriplanar);
        _mainShader->setUniformFloat("triplanarScale", meshComp->triplanarScale);

        auto probe = go->getComponent<ReflectionProbeComponent>();
        if (probe && probe->textureID != 0) {
            // 如果这个物体本身就是一个反射探针，我们就使用它生成的 Environment Map
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_CUBE_MAP, probe->textureID);
            
            _mainShader->setUniformBool("hasEnvMap", true);
            _mainShader->setUniformInt("envMap", 1); // 告诉 Shader 去纹理单元 1 找
            
            // 计算并传递 Box 参数
            // 假设探针中心就是物体中心
            glm::vec3 pPos = go->transform.position;
            // 计算世界坐标下的 AABB
            glm::vec3 bMin = pPos - probe->boxSize * 0.5f;
            glm::vec3 bMax = pPos + probe->boxSize * 0.5f;

            _mainShader->setUniformVec3("probePos", pPos);
            _mainShader->setUniformVec3("probeBoxMin", bMin);
            _mainShader->setUniformVec3("probeBoxMax", bMax);
        } else {
            _mainShader->setUniformBool("hasEnvMap", false);
        }

        // 计算 Model Matrix
        glm::mat4 modelMatrix = go->transform.getLocalMatrix();
        modelMatrix = modelMatrix * meshComp->model->transform.getLocalMatrix();

        _mainShader->setUniformMat4("model", modelMatrix);
        
        meshComp->model->draw();

        if (meshComp->doubleSided) glEnable(GL_CULL_FACE);
    }
}

void Renderer::updateReflectionProbes(const Scene& scene)
{
    // 获取当前视口，以便烘焙完后恢复
    GLint prevViewport[4];
    glGetIntegerv(GL_VIEWPORT, prevViewport);

    // 遍历所有物体，找带 ReflectionProbeComponent 的
    for (const auto& go : scene.getGameObjects())
    {
        auto probe = go->getComponent<ReflectionProbeComponent>();
        if (!probe) continue;

        // 1. 确保 GL 资源已创建
        probe->initGL();

        // 2. 准备烘焙参数
        glBindFramebuffer(GL_FRAMEBUFFER, probe->fboID);
        glViewport(0, 0, probe->resolution, probe->resolution);

        glm::vec3 probePos = go->transform.position;
        // 投影矩阵：90度 FOV, 1:1 比例, 近裁剪面 0.1, 远裁剪面 100
        glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, 100.0f);

        // 3. 朝 6 个方向渲染
        // OpenGL Cubemap 面顺序: +X, -X, +Y, -Y, +Z, -Z
        std::vector<glm::mat4> shadowViews;
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3(-1.0f,  0.0f,  0.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  1.0f,  0.0f), glm::vec3(0.0f,  0.0f,  1.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f, -1.0f,  0.0f), glm::vec3(0.0f,  0.0f, -1.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  0.0f,  1.0f), glm::vec3(0.0f, -1.0f,  0.0f)));
        shadowViews.push_back(glm::lookAt(probePos, probePos + glm::vec3( 0.0f,  0.0f, -1.0f), glm::vec3(0.0f, -1.0f,  0.0f)));

        for (int i = 0; i < 6; ++i)
        {
            // 将 FBO 颜色附件绑定到 Cubemap 的当前面
            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
                                   GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, probe->textureID, 0);
            
            // 清屏 (注意：这里不需要 glClearColor 设置太亮，否则缝隙会明显)
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            // A. 画天空盒
            // 注意：DrawSkybox 需要去平移的 View 矩阵
            glm::mat4 viewNoTrans = glm::mat4(glm::mat3(shadowViews[i])); 
            drawSkybox(viewNoTrans, shadowProj);

            // B. 画场景物体
            // 关键：传入 go.get() 作为 excludeObject，防止画自己
            drawSceneObjects(scene, shadowViews[i], shadowProj, probePos, go.get());
        }

        // 6个面都画完了，生成 Mipmap
        glBindTexture(GL_TEXTURE_CUBE_MAP, probe->textureID);
        glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
    }

    // 恢复状态
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glViewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);
}
```

./engine/renderer.h:
```
#pragma once

#include <memory>
#include <vector>
#include <glad/gl.h>

#include "scene.h"
#include "base/camera.h"
#include "base/glsl_program.h"
#include "outline_pass.h"
#include "geometry_factory.h"
#include "shadow_map_pass.h"

class Renderer
{
public:
    Renderer();
    ~Renderer();

    // 初始化 Shader、天空盒、网格等资源
    void init();

    // 调整大小 (通知 OutlinePass 等)
    void onResize(int width, int height);

    // 核心渲染函数
    // targetFBO: 传入 0 渲染到屏幕，传入 FBO ID 渲染到纹理
    // selectedObj: 如果非空，则绘制描边 (Editor 模式用)
    void render(const Scene& scene, Camera* camera, 
                GLuint targetFBO, int width, int height,
                float contentScale, 
                GameObject* selectedObj = nullptr);

private:
    // --- Shader 资源 ---
    std::unique_ptr<GLSLProgram> _mainShader;
    std::unique_ptr<GLSLProgram> _gridShader;
    std::unique_ptr<GLSLProgram> _skyboxShader;
    std::unique_ptr<ShadowMapPass> _shadowPass;

    // --- 全局模型 ---
    std::shared_ptr<Model> _gridPlane;
    std::shared_ptr<Model> _skyboxCube;

    // --- Render Pass ---
    std::unique_ptr<OutlinePass> _outlinePass;

    // --- 内部绘制函数 ---
    void drawSkybox(const glm::mat4& view, const glm::mat4& proj);
    void drawGrid(const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos);
    void drawSceneObjects(const Scene& scene, const glm::mat4& view, const glm::mat4& proj, const glm::vec3& viewPos, const GameObject* excludeObject = nullptr);
    // 更新场景中的所有反射探针
    void updateReflectionProbes(const Scene& scene);
};
```

./engine/resource_manager.cpp:
```
#include "resource_manager.h"
#include <iostream>
#include <algorithm>

ResourceManager& ResourceManager::Get()
{
    static ResourceManager instance;
    return instance;
}

void ResourceManager::setProjectRoot(const std::string& rootPath)
{
    _projectRoot = rootPath;
    
    // 确保路径以分隔符结尾 (Windows '\' 或 Linux '/')
    if (!_projectRoot.empty() && _projectRoot.back() != '/' && _projectRoot.back() != '\\') {
        _projectRoot += "/";
    }

    // 设置完路径后，立即重新扫描
    scanDirectory(_projectRoot);
    
    // 清空旧缓存 (可选，切换项目时应该清空)
    _modelCache.clear();
}

std::string ResourceManager::getFullPath(const std::string& relativePath)
{
    // 如果已经是绝对路径，直接返回
    if (std::filesystem::path(relativePath).is_absolute()) {
        return relativePath;
    }
    return _projectRoot + relativePath;
}

// scanDirectory 里的逻辑稍微改一下，确保存储的是“相对路径”
void ResourceManager::scanDirectory(const std::string& rootDir)
{
    _fileList.clear();
    namespace fs = std::filesystem;
    if (rootDir.empty() || !fs::exists(rootDir) || !fs::is_directory(rootDir)) return;

    for (const auto& entry : fs::recursive_directory_iterator(rootDir))
    {
        if (entry.is_regular_file())
        {
            std::string ext = entry.path().extension().string();
            std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
            
            bool isModel = (ext == ".obj");
            bool isTexture = (ext == ".png" || ext == ".jpg" || ext == ".jpeg" || ext == ".bmp" || ext == ".tga");

            if (isModel || isTexture)
            {
                std::string filename = entry.path().filename().string();
                
                std::string storePath;
                try {
                    // 尝试计算相对路径
                    storePath = fs::relative(entry.path(), rootDir).string();
                } catch (const fs::filesystem_error& e) {
                    // 如果无法计算相对路径（比如跨盘符），则退化为存储绝对路径
                    storePath = entry.path().string();
                }
                std::replace(storePath.begin(), storePath.end(), '\\', '/');
                
                _fileList.push_back({filename, storePath});
            }
        }
    }
}

std::shared_ptr<Model> ResourceManager::getModel(const std::string& pathKey, bool useFlatShade)
{
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    std::string cacheKey = cleanPath;
    if (useFlatShade) cacheKey += ":useFlatShade";

    // 1. 检查缓存 (Key 是相对路径，比如 "assets/sphere.obj")
    auto it = _modelCache.find(cacheKey);
    if (it != _modelCache.end())
    {
        return it->second;
    }

    // 2. 缓存未命中，准备加载
    // [核心修复] 获取硬盘上的绝对路径
    std::string fullPath = getFullPath(cleanPath);

    if (!std::filesystem::exists(fullPath)) {
        std::cerr << "[ResourceManager] Error: File not found: " << fullPath << std::endl;
        return nullptr; // 或者返回一个紫黑格子的 "ErrorModel"
    }

    // [调试] 打印一下路径，确认拼对了吗
    // std::cout << "Loading Model: " << fullPath << std::endl;

    try {
        // 3. 使用【绝对路径】去打开文件
        std::shared_ptr<Model> newModel = std::make_shared<Model>(fullPath, useFlatShade);
        
        // 4. 存入缓存 (Key 依然是【相对路径】，方便下次查找)
        _modelCache[cacheKey] = newModel;
        
        return newModel;
    }
    catch (std::exception& e) {
        std::cerr << "[ResourceManager] Failed to load model: " << e.what() << std::endl;
        return nullptr;
    }
}

std::shared_ptr<ImageTexture2D> ResourceManager::getTexture(const std::string& pathKey)
{
    std::string cleanPath = pathKey;
    std::replace(cleanPath.begin(), cleanPath.end(), '\\', '/');

    std::string cacheKey = cleanPath;

    // 1. 查缓存
    auto it = _textureCache.find(cleanPath);
    if (it != _textureCache.end()) {
        return it->second;
    }

    // 2. 加载
    std::string fullPath = getFullPath(cleanPath);
    if (!std::filesystem::exists(fullPath)) {
        std::cerr << "[ResourceManager] Error: Texture not found: " << fullPath << std::endl;
        return nullptr;
    }

    try {
        // ImageTexture2D 构造函数会抛出异常如果加载失败
        auto newTex = std::make_shared<ImageTexture2D>(fullPath);
        _textureCache[cacheKey] = newTex;
        return newTex;
    }
    catch (std::exception& e) {
        std::cerr << "[ResourceManager] Failed to load texture: " << e.what() << std::endl;
        return nullptr;
    }
}
```

./engine/resource_manager.h:
```
#pragma once

#include <string>
#include <unordered_map>
#include <memory>
#include <vector>
#include <filesystem>
#include "engine/model.h"
#include "base/texture2d.h"

class ResourceManager
{
public:
    // 单例访问
    static ResourceManager& Get();

    // 设置项目根目录 (比如 "D:/MyGraphicsProject/")
    void setProjectRoot(const std::string& rootPath);
    
    // 获取项目根目录
    std::string getProjectRoot() const { return _projectRoot; }

    // 获取完整路径 (用于加载)
    std::string getFullPath(const std::string& relativePath);

    // 加载或获取已缓存的模型
    // path: 相对路径，例如 "obj/bunny.obj"
    std::shared_ptr<Model> getModel(const std::string& pathKey, bool useFlatShade);

    // 加载或获取已缓存的纹理
    std::shared_ptr<ImageTexture2D> getTexture(const std::string& pathKey);

    // 扫描资源目录下所有的 .obj 文件 (用于 UI 显示)
    // rootDir: 资源根目录，例如 "../../media/"
    void scanDirectory(const std::string& rootDir);

    // 获取扫描到的文件列表 (文件名, 相对路径)
    const std::vector<std::pair<std::string, std::string>>& getFileList() const { return _fileList; }

    void shutdown() {
        _modelCache.clear(); // 强制释放所有 Model shared_ptr
        _textureCache.clear();
    }

private:
    ResourceManager() = default;

    std::string _projectRoot = ""; // 默认为空

    // 模型缓存：key=相对路径, value=模型指针
    std::unordered_map<std::string, std::shared_ptr<Model>> _modelCache;

    // 纹理缓存
    std::unordered_map<std::string, std::shared_ptr<ImageTexture2D>> _textureCache;

    // 扫描到的文件列表
    std::vector<std::pair<std::string, std::string>> _fileList;
};
```

./engine/scene.cpp:
```
#include "scene.h"
#include "resource_manager.h" // 如果需要加载默认图标
#include "obj_loader.h"

#include <fstream>
#include <iomanip>
#include <iostream>

GameObject* Scene::createCube()
{
    auto go = new GameObject("Cube");
    // 使用 GeometryFactory 创建
    auto meshComp = go->addComponent<MeshComponent>(GeometryFactory::createCube());
    
    // 初始化默认参数
    meshComp->shapeType = MeshShapeType::Cube;
    meshComp->params.size = 1.0f;
    meshComp->material.diffuse = glm::vec3(0.8f);

    // 存入容器
    _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    return go;
}

GameObject* Scene::createPointLight()
{
    auto go = new GameObject("Point Light");
    auto lightComp = go->addComponent<LightComponent>(LightType::Point);
    lightComp->color = glm::vec3(1.0f, 1.0f, 0.0f);

    // 光源可视化 (Gizmo)
    auto meshComp = go->addComponent<MeshComponent>(GeometryFactory::createSphere(0.2f), true);
    meshComp->shapeType = MeshShapeType::Sphere;
    meshComp->params.radius = 0.2f;
    meshComp->material.diffuse = lightComp->color;

    _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    return go;
}

void Scene::createDefaultScene()
{
    // 创建默认的平行光 (Sun)
    auto sun = new GameObject("Directional Light");
    auto lightComp = sun->addComponent<LightComponent>(LightType::Directional);
    
    sun->transform.rotationEuler = glm::vec3(-50.0f, -30.0f, 0.0f);
    sun->transform.setRotation(sun->transform.rotationEuler);

    // 尝试加载 Gizmo 图标
    try {
        std::string arrowPath = "media/obj/arrow.obj";
        auto arrowModel = ResourceManager::Get().getModel(arrowPath, false);
        if (arrowModel) {
            auto arrowMesh = sun->addComponent<MeshComponent>(arrowModel, true);
            arrowMesh->shapeType = MeshShapeType::CustomOBJ;
            strcpy(arrowMesh->params.objPath, arrowPath.c_str());
            sun->transform.scale = glm::vec3(0.5f);
        }
    } catch (...) {}

    _gameObjects.push_back(std::unique_ptr<GameObject>(sun));
}

void Scene::markForDestruction(GameObject* go)
{
    // 检查是否已经在队列中，防止重复添加
    if (std::find(_killQueue.begin(), _killQueue.end(), go) == _killQueue.end()) {
        _killQueue.push_back(go);
    }
}

void Scene::destroyMarkedObjects()
{
    if (_killQueue.empty()) return;

    for (GameObject* go : _killQueue)
    {
        // 执行真正的物理删除
        _gameObjects.erase(
            std::remove_if(_gameObjects.begin(), _gameObjects.end(),
                [go](const std::unique_ptr<GameObject>& p) { 
                    return p.get() == go; 
                }),
            _gameObjects.end());
    }
    _killQueue.clear();
}

void Scene::exportToOBJ(const std::string& filename)
{
    std::ofstream out(filename);
    if (!out.is_open())
    {
        std::cerr << "Failed to open file for export: " << filename << std::endl;
        return;
    }

    out << "# Exported Scene\n";
    
    // 全局顶点偏移量 (OBJ 索引从 1 开始)
    uint32_t globalVertexOffset = 1; 

    for (const auto& go : _gameObjects)
    {
        // 1. 获取网格组件
        auto meshComp = go->getComponent<MeshComponent>();
        if (!meshComp || !meshComp->enabled || !meshComp->model) continue;

        const auto& vertices = meshComp->model->getVertices();
        const auto& indices = meshComp->model->getIndices();

        if (vertices.empty() || indices.empty()) continue;

        // 写入对象名称
        out << "o " << go->name << "_" << go->getInstanceID() << "\n";

        // 2. 计算变换矩阵
        glm::mat4 modelMat = go->transform.getLocalMatrix();
        // 还要叠加上 Model 自身的变换 (如果有的话，通常 Model 自带变换是单位矩阵，但也可能不是)
        modelMat = modelMat * meshComp->model->transform.getLocalMatrix();

        // 法线矩阵 (用于正确变换法线，处理非均匀缩放)
        glm::mat3 normalMat = glm::mat3(glm::transpose(glm::inverse(modelMat)));

        // 3. 写入顶点数据 (v, vt, vn)
        for (const auto& v : vertices)
        {
            // --- 顶点位置 (转换到世界空间) ---
            glm::vec4 worldPos = modelMat * glm::vec4(v.position, 1.0f);
            out << "v " << std::fixed << std::setprecision(6) 
                << worldPos.x << " " << worldPos.y << " " << worldPos.z << "\n";

            // --- 纹理坐标 (直接输出) ---
            out << "vt " << v.texCoord.x << " " << v.texCoord.y << "\n";

            // --- 法线 (转换到世界空间并归一化) ---
            glm::vec3 worldNorm = glm::normalize(normalMat * v.normal);
            out << "vn " << worldNorm.x << " " << worldNorm.y << " " << worldNorm.z << "\n";
        }

        // 4. 写入面数据 (f v/vt/vn)
        // 注意：OBJ 索引是从 1 开始的全局索引
        for (size_t i = 0; i < indices.size(); i += 3)
        {
            uint32_t idx0 = indices[i]     + globalVertexOffset;
            uint32_t idx1 = indices[i + 1] + globalVertexOffset;
            uint32_t idx2 = indices[i + 2] + globalVertexOffset;

            // 格式: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
            // 这里我们假设 v, vt, vn 的索引是相同的 (因为我们的 Mesh 结构体就是这样存的)
            out << "f " 
                << idx0 << "/" << idx0 << "/" << idx0 << " "
                << idx1 << "/" << idx1 << "/" << idx1 << " "
                << idx2 << "/" << idx2 << "/" << idx2 << "\n";
        }

        // 更新偏移量
        globalVertexOffset += (uint32_t)vertices.size();
    }

    out.close();
    std::cout << "Scene exported successfully to " << filename << std::endl;
}

void Scene::importSceneFromOBJ(const std::string& filepath)
{
    // 1. 调用多网格加载器
    // 这里的 false 表示不强制 Split Vertices (Smooth Shading)，保留 OBJ 原貌
    // 如果你希望导入的模型默认都是 Low-Poly 风格，可以传 true
    std::vector<SubMesh> meshes;
    try {
        meshes = OBJLoader::loadScene(filepath, false);
    }
    catch (const std::exception& e) {
        std::cerr << "[Scene] Import failed: " << e.what() << std::endl;
        return;
    }

    if (meshes.empty()) {
        std::cout << "[Scene] No meshes found in " << filepath << std::endl;
        return;
    }

    // 2. 为每个 SubMesh 创建 GameObject
    for (const auto& subMesh : meshes)
    {
        // 创建 GameObject
        // 注意：subMesh.name 来自 OBJ 文件里的 'o' 或 'g' 标签
        auto go = new GameObject(subMesh.name);

        // 创建 Model
        // 我们利用现有的 Model 构造函数 (从顶点/索引数组构建)
        // 注意：Model 内部会重新计算包围盒
        auto model = std::make_shared<Model>(subMesh.vertices, subMesh.indices);
        
        // 添加 MeshComponent
        auto meshComp = go->addComponent<MeshComponent>(model);
        meshComp->shapeType = MeshShapeType::CustomOBJ;
        
        // 记录来源路径
        // 虽然这个路径指向的是整个场景文件，但作为元数据保留是有用的
        strncpy(meshComp->params.objPath, filepath.c_str(), sizeof(meshComp->params.objPath) - 1);
        meshComp->params.objPath[sizeof(meshComp->params.objPath) - 1] = '\0';
        
        // [智能 UV 检测]
        // 如果 SubMesh 标记没有 UV，自动开启 Triplanar Mapping
        // 这样导入的无 UV 模型（如简单的几何体组合）也能直接贴图
        if (!subMesh.hasUVs) {
            meshComp->useTriplanar = true;
            meshComp->triplanarScale = 0.2f; // 默认缩放，可视情况调整
        } else {
            meshComp->useTriplanar = false;
        }

        // 将新创建的物体加入场景列表
        _gameObjects.push_back(std::unique_ptr<GameObject>(go));
    }
    
    std::cout << "[Scene] Imported " << meshes.size() << " objects from " << filepath << std::endl;
}

void Scene::importSingleMeshFromOBJ(const std::string& filepath)
{
    // 1. 从路径提取文件名作为物体名称 (例如 "C:/Assets/Chair.obj" -> "Chair")
    std::string name = std::filesystem::path(filepath).stem().string();
    if (name.empty()) name = "Imported Mesh";

    // 2. 加载网格数据 (Flatten 模式，不拆分物体)
    MeshData meshData;
    try {
        // false = 不强制 Flat Shading (默认平滑)
        meshData = OBJLoader::load(filepath, false);
    }
    catch (const std::exception& e) {
        std::cerr << "[Scene] Failed to load mesh: " << e.what() << std::endl;
        return;
    }

    if (meshData.vertices.empty()) {
        std::cerr << "[Scene] Mesh is empty: " << filepath << std::endl;
        return;
    }

    // 3. 创建 GameObject
    auto go = new GameObject(name);

    // 4. 创建 Model
    // 使用顶点和索引数组构建 Model
    auto model = std::make_shared<Model>(meshData.vertices, meshData.indices);

    // 5. 添加 MeshComponent
    auto meshComp = go->addComponent<MeshComponent>(model);
    
    // 设置类型为 CustomOBJ，这样 Inspector 会显示文件路径槽
    meshComp->shapeType = MeshShapeType::CustomOBJ;

    // 6. 记录文件路径
    strncpy(meshComp->params.objPath, filepath.c_str(), sizeof(meshComp->params.objPath) - 1);
    meshComp->params.objPath[sizeof(meshComp->params.objPath) - 1] = '\0';

    // 7. [智能 UV 检测]
    // 如果加载的数据里没有 UV，自动开启 Triplanar Mapping
    if (!meshData.hasUVs) {
        meshComp->useTriplanar = true;
        meshComp->triplanarScale = 0.2f; // 默认缩放值，可视情况调整
    } else {
        meshComp->useTriplanar = false;
    }

    // 8. 加入场景列表
    _gameObjects.push_back(std::unique_ptr<GameObject>(go));

    std::cout << "[Scene] Imported single mesh: " << name << std::endl;
}
```

./engine/scene.h:
```
#pragma once

#include <vector>
#include <memory>
#include <algorithm>
#include "scene_object.h" // 根据你的实际路径调整
#include "geometry_factory.h"

class Scene
{
public:
    Scene() = default;
    ~Scene() = default;

    // --- 对象管理 ---
    
    // 获取所有对象 (供 Renderer 遍历)
    const std::vector<std::unique_ptr<GameObject>>& getGameObjects() const { return _gameObjects; }

    // 添加一个已经创建好的对象
    void addGameObject(std::unique_ptr<GameObject> go) {
        _gameObjects.push_back(std::move(go));
    }

    // 删除指定对象
    void removeGameObject(GameObject* go) {
        _gameObjects.erase(
            std::remove_if(_gameObjects.begin(), _gameObjects.end(),
                [go](const std::unique_ptr<GameObject>& p) { return p.get() == go; }),
            _gameObjects.end());
    }

    // 清空场景
    void clear() { _gameObjects.clear(); }

    // --- 工厂方法 (从 SceneRoaming 迁移过来的逻辑) ---
    
    // 创建默认立方体
    GameObject* createCube();
    
    // 创建点光源
    GameObject* createPointLight();

    // 创建默认场景 (比如初始化一个太阳)
    void createDefaultScene();

    void markForDestruction(GameObject* go);

    bool isMarkedForDestruction(GameObject* go) const {
        if (!go) return false;
        // 检查指针是否存在于 _killQueue 中
        return std::find(_killQueue.begin(), _killQueue.end(), go) != _killQueue.end();
    }

    void destroyMarkedObjects();

    // 导出当前场景为 OBJ
    void exportToOBJ(const std::string& filename);

    // 从 OBJ 导入场景（多个物体）
    void importSceneFromOBJ(const std::string& filepath);
    // 从 OBJ 导入单体
    void importSingleMeshFromOBJ(const std::string& filepath);

private:
    std::vector<std::unique_ptr<GameObject>> _gameObjects;

    std::vector<GameObject*> _killQueue;
};
```

./engine/scene_object.cpp:
```
#include "scene_object.h"
#include <glad/gl.h> // 只有这里需要包含 OpenGL 头文件，净化了头文件
#include <iostream>

// ==========================================
// IDGenerator
// ==========================================
int IDGenerator::generate() {
    static std::atomic<int> counter{ 1 };
    return counter.fetch_add(1);
}

// ==========================================
// Component
// ==========================================
Component::Component() : _instanceId(IDGenerator::generate()) {}

// ==========================================
// MeshComponent
// ==========================================
MeshComponent::MeshComponent(std::shared_ptr<Model> m, bool gizmo)
    : model(m), isGizmo(gizmo) {}

void MeshComponent::setMesh(std::shared_ptr<Model> newModel) {
    if (newModel) model = newModel;
}

// ==========================================
// LightComponent
// ==========================================
LightComponent::LightComponent(LightType t) : type(t) {}

// ==========================================
// ReflectionProbeComponent
// ==========================================
ReflectionProbeComponent::~ReflectionProbeComponent() {
    if (textureID) glDeleteTextures(1, &textureID);
    if (fboID) glDeleteFramebuffers(1, &fboID);
    if (rboID) glDeleteRenderbuffers(1, &rboID);
}

void ReflectionProbeComponent::initGL() {
    if (textureID != 0) return; // 已初始化

    // 1. 创建 Cubemap 纹理
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);
    for (unsigned int i = 0; i < 6; ++i) {
        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, 
                     resolution, resolution, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    // 2. 创建 FBO
    glGenFramebuffers(1, &fboID);
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);

    // 3. 创建深度缓冲 (RBO)
    glGenRenderbuffers(1, &rboID);
    glBindRenderbuffer(GL_RENDERBUFFER, rboID);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, resolution, resolution);
    
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboID);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::ReflectionProbe:: Framebuffer is not complete!" << std::endl;

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// ==========================================
// GameObject
// ==========================================
GameObject::GameObject(const std::string &n) : name(n), _instanceId(IDGenerator::generate()) {}

void GameObject::removeComponent(Component *comp)
{
    components.erase(
        std::remove_if(components.begin(), components.end(),
                        [comp](const std::unique_ptr<Component> &p)
                        { return p.get() == comp; }),
        components.end());
}
```

./engine/scene_object.h:
```
#pragma once

#include <vector>
#include <memory>
#include <string>
#include <algorithm>
#include <iostream>
#include <atomic>

#include "base/transform.h"
#include "base/texture2d.h"
#include "engine/model.h"
#include "light_structs.h"

// 前置声明
class GameObject;

enum class MeshShapeType
{
    Cube,
    Sphere,
    Cylinder,
    Cone,
    Prism,   // 多面棱柱
    Frustum, // 多面棱台
    Plane,
    CustomOBJ // 自定义 OBJ 文件
};

// ==========================================
// 组件类型枚举 (用于运行时识别，替代复杂的 dynamic_cast)
// ==========================================
enum class ComponentType
{
    MeshRenderer,
    Light,
    ReflectionProbe
};

enum class LightType
{
    Directional,
    Point,
    Spot
};

// 定义一个结构体来保存生成参数，防止每次切换丢失
struct MeshParams
{
    // 通用
    float size = 1.0f;
    float radius = 0.5f;
    float height = 1.0f;

    // 平面
    float width = 10.0f;
    float depth = 10.0f;

    // 圆柱/球/圆锥
    int slices = 32;
    int stacks = 16;

    // 棱柱/棱台
    float topRadius = 0.5f;
    float bottomRadius = 1.0f;
    int sides = 6; // 默认六棱柱

    // OBJ
    char objPath[256] = "";
};

// ==========================================
// 0. 辅助：ID 生成器
// ==========================================
class IDGenerator {
public:
    static int generate();
};

// ==========================================
// 1. 组件基类
// ==========================================
class Component
{
public:
    GameObject *owner = nullptr;
    bool enabled = true;

    Component();

    virtual ~Component() = default;

    int getInstanceID() const { return _instanceId; }

    // 纯虚函数：获取类型
    virtual ComponentType getType() const = 0;

protected:
    int _instanceId;
};

// ==========================================
// 2. 网格渲染组件
// ==========================================
class MeshComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::MeshRenderer;

    std::shared_ptr<Model> model;
    std::shared_ptr<ImageTexture2D> diffuseMap; // 漫反射贴图
    Material material;

    // 是否是Gizmo (编辑器辅助物体，如灯泡图标)，渲染时不受光照影响
    bool isGizmo = false;
    
    // 是否双面渲染 (默认 false，Plane 需要设为 true)
    bool doubleSided = false;

    // 是否使用硬棱角
    bool useFlatShade = false;

    // Texture设置
    bool useTriplanar = false; // 是否开启三向映射
    float triplanarScale = 1.0f; // 纹理平铺缩放大小

    MeshShapeType shapeType = MeshShapeType::Cube;
    MeshParams params;

    MeshComponent(std::shared_ptr<Model> m, bool gizmo = false);

    ComponentType getType() const override { return Type; }

    void setMesh(std::shared_ptr<Model> newModel);
};

// ==========================================
// 3. 光照组件
// ==========================================


class LightComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::Light;

    LightType type;
    glm::vec3 color = glm::vec3(1.0f);
    float intensity = 1.0f;

    // 衰减
    float constant = 1.0f;
    float linear = 0.09f;
    float quadratic = 0.032f;

    // 聚光
    float cutOff = glm::cos(glm::radians(12.5f));
    float outerCutOff = glm::cos(glm::radians(17.5f));

    // 阴影投射时的剔除面
    // GL_BACK (0x0405): 剔除背面 (默认，适合闭合物体，解决漏光)
    // GL_FRONT (0x0404): 剔除正面 (适合解决 Shadow Acne，Unity/UE常用技巧)
    unsigned int shadowCullFace = GL_BACK;

    // Unity 风格的阴影参数
    // Depth Bias: 对应 Unity 的 "Bias"，通常很小 (0.001 ~ 0.05)
    float shadowBias = 0.0010f; 
    
    // Normal Bias: 对应 Unity 的 "Normal Bias"，收缩模型的程度 (0.0 ~ 3.0)
    // 我们的单位是世界坐标单位，所以默认值设小一点，比如 0.02
    float shadowNormalBias = 0.00f;

    LightComponent(LightType t);

    ComponentType getType() const override { return Type; }
};

// ==========================================
// 4. 反射探针组件
// ==========================================
class ReflectionProbeComponent : public Component
{
public:
    static constexpr ComponentType Type = ComponentType::ReflectionProbe;

    int resolution = 2048;
    unsigned int textureID = 0;
    unsigned int fboID = 0;
    unsigned int rboID = 0;
    bool isDirty = true;
    // 影响范围/房间大小 (默认 10x10x10 的房间)
    glm::vec3 boxSize = glm::vec3(10.0f, 10.0f, 10.0f);

    ReflectionProbeComponent() = default;
    ~ReflectionProbeComponent(); // 析构移到 cpp (因为它包含 glDelete)

    void initGL(); // 核心逻辑移到 cpp
    ComponentType getType() const override { return Type; }
};

// ==========================================
// 5. 游戏对象
// ==========================================
class GameObject
{
public:
    std::string name;
    Transform transform;
    std::vector<std::unique_ptr<Component>> components;

    GameObject(const std::string &n);

    int getInstanceID() const { return _instanceId; }

    template <typename T, typename... Args>
    T *addComponent(Args &&...args)
    {
        auto comp = std::make_unique<T>(std::forward<Args>(args)...);
        comp->owner = this;
        T *ptr = comp.get();
        components.push_back(std::move(comp));
        return ptr;
    }

    template <typename T>
    T *getComponent()
    {
        for (auto &comp : components)
        {
            if (comp->getType() == T::Type)
            {
                // 安全的向下转型 (因为我们已经确认了类型)
                return static_cast<T *>(comp.get());
            }
        }
        return nullptr;
    }

    void removeComponent(Component *comp);

private:
    int _instanceId;
};
```

./engine/shadow_map_pass.cpp:
```
#include "shadow_map_pass.h"
#include <iostream>

ShadowMapPass::ShadowMapPass(int resolution) 
    : _resolution(resolution)
{
    // 定义级联层级 (分割距离)
    // 这里我们定义 4 层级联。单位是米。
    // 能够覆盖近处细节 (0-10m) 到中远距离。
    // 注意：最后一层不需要存，它就是相机的 zFar。
    _cascadeLevels = { 10.0f, 50.0f, 200.0f, 800.0f, 2000.0f };
    // 实际层级是: [0, 10], [10, 50], [50, 200], [200, 800], [800, 2000], [2000, zFar] -> 共 6 层

    // 预分配矩阵空间
    _lightSpaceMatrices.resize(_cascadeLevels.size() + 1);

    initShader();
    initFBO();
}

ShadowMapPass::~ShadowMapPass()
{
    if (_fbo) glDeleteFramebuffers(1, &_fbo);
    if (_depthMap) glDeleteTextures(1, &_depthMap);
}

void ShadowMapPass::initFBO()
{
    glGenFramebuffers(1, &_fbo);
    
    glGenTextures(1, &_depthMap);
    glBindTexture(GL_TEXTURE_2D_ARRAY, _depthMap); // 绑定为数组纹理

    // 分配 3D 内存
    // width, height, depth (层数)。我们有 4 层。
    glTexImage3D(
        GL_TEXTURE_2D_ARRAY, 0, GL_DEPTH_COMPONENT32F, 
        _resolution, _resolution, int(_cascadeLevels.size() + 1), 
        0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL
    );
    
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

    // 边界颜色设为 1.0 (最大深度，即无阴影)
    constexpr float borderColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    glTexParameterfv(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, borderColor);

    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);
    
    // 将 Texture Array 的第 0 层附加到 FBO，但这只是暂时的
    // 在渲染循环中，我们会动态改变 attachment
    glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _depthMap, 0, 0);
    
    // 我们不需要颜色缓冲，只记录深度
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
    
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::ShadowMapFBO:: Framebuffer is not complete!" << std::endl;
        
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void ShadowMapPass::initShader()
{
    // 极简 Vertex Shader：把顶点变换到光空间
    const char* vsCode = R"(
        #version 330 core
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal; // [新增] 我们需要法线

        uniform mat4 lightSpaceMatrix;
        uniform mat4 model;
        uniform float normalBias; // [新增]

        void main() {
            // 1. 计算世界空间位置
            vec3 posWS = vec3(model * vec4(aPos, 1.0));
            
            // 2. 计算世界空间法线 (简化计算，假设没有非均匀缩放，或者在CPU传NormalMatrix)
            // 为了性能，且在ShadowPass，我们简单用 model 旋转部分
            vec3 normWS = normalize(mat3(model) * aNormal);

            // 3. [核心] 应用 Normal Bias
            // 沿着法线反方向向内收缩顶点
            // 加上光线方向的修正：只有当表面朝向光源时才需要收缩 (可选，Unity的做法比较复杂，这里用最简单的收缩)
            posWS -= normWS * normalBias;

            gl_Position = lightSpaceMatrix * vec4(posWS, 1.0);
        }
    )";

    // Empty Fragment Shader：不需要做任何事，深度写入是自动的
    const char* fsCode = R"(
        #version 330 core
        void main() {
            // gl_FragDepth = gl_FragCoord.z;
        }
    )";

    _depthShader.reset(new GLSLProgram);
    _depthShader->attachVertexShader(vsCode);
    _depthShader->attachFragmentShader(fsCode);
    _depthShader->link();
}

void ShadowMapPass::render(const Scene& scene, const glm::vec3& lightDir, Camera* camera, float shadowNormalBias, unsigned int cullFaceMode)
{
    // 1. 计算每一层的矩阵
    _lightSpaceMatrices.clear();
    
    // 这里的 near/far 必须和相机的设置一致
    float camNear = 0.1f;
    float camFar = 1000.0f;

    if (auto pCam = dynamic_cast<PerspectiveCamera*>(camera)) {
        camNear = pCam->znear;
        camFar = pCam->zfar;
    } else if (auto oCam = dynamic_cast<OrthographicCamera*>(camera)) {
        camNear = oCam->znear;
        camFar = oCam->zfar;
    }

    // 循环处理每一层
    // 层级示例: 
    // 0: [near, 10]
    // 1: [10, 60]
    // 2: [60, 250]
    // 3: [250, far]
    for (size_t i = 0; i < _cascadeLevels.size() + 1; ++i)
    {
        float prevSplit = (i == 0) ? camNear : _cascadeLevels[i - 1];
        float currSplit = (i < _cascadeLevels.size()) ? _cascadeLevels[i] : camFar;

        _lightSpaceMatrices.push_back(getLightSpaceMatrix(prevSplit, currSplit, lightDir, camera));
    }

    // 2. 渲染流程
    glBindFramebuffer(GL_FRAMEBUFFER, _fbo);
    glViewport(0, 0, _resolution, _resolution);
    
    // 这里需要把每一层都清空，或者每次绘制前清空
    glClear(GL_DEPTH_BUFFER_BIT); 
    // 注意：TextureArray 的 clear 比较特殊，如果不放心，可以在下面循环里 clear，但那样效率略低。
    // 正确的做法是 glClear 会清除当前绑定的 Attachment。如果当前绑定的是 Layer 0，它只清 Layer 0 吗？
    // OpenGL 规范比较绕。为了安全起见，我们在循环里做 glClear。

    _depthShader->use();
    // 传递 Normal Bias (如果需要)
    _depthShader->setUniformFloat("normalBias", shadowNormalBias);

    // 开启剔除 (GL_BACK) 
    glEnable(GL_CULL_FACE);
    glCullFace(cullFaceMode);

    for (size_t i = 0; i < _lightSpaceMatrices.size(); ++i)
    {
        // [关键] 绑定当前层
        glFramebufferTextureLayer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, _depthMap, 0, i);
        
        // 清除这一层的深度
        glClear(GL_DEPTH_BUFFER_BIT);

        // 设置当前层的矩阵
        _depthShader->setUniformMat4("lightSpaceMatrix", _lightSpaceMatrices[i]);

        // 绘制场景
        for (const auto& go : scene.getGameObjects()) {
            auto meshComp = go->getComponent<MeshComponent>();
            if (!meshComp || !meshComp->enabled) continue;
            if (meshComp->isGizmo) continue;

            glm::mat4 model = go->transform.getLocalMatrix();
            model = model * meshComp->model->transform.getLocalMatrix();
            _depthShader->setUniformMat4("model", model);

            meshComp->model->draw();
        }
    }

    glCullFace(GL_BACK);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

std::vector<glm::vec4> ShadowMapPass::getFrustumCornersWorldSpace(const glm::mat4& proj, const glm::mat4& view)
{
    const auto inv = glm::inverse(proj * view);
    
    std::vector<glm::vec4> frustumCorners;
    for (unsigned int x = 0; x < 2; ++x) {
        for (unsigned int y = 0; y < 2; ++y) {
            for (unsigned int z = 0; z < 2; ++z) {
                const glm::vec4 pt = inv * glm::vec4(
                    2.0f * x - 1.0f,
                    2.0f * y - 1.0f,
                    2.0f * z - 1.0f,
                    1.0f);
                frustumCorners.push_back(pt / pt.w);
            }
        }
    }
    return frustumCorners;
}

glm::mat4 ShadowMapPass::getLightSpaceMatrix(const float nearPlane, const float farPlane, const glm::vec3& lightDir, Camera* camera)
{
    // 1. 根据相机类型计算当前切片的投影矩阵
    glm::mat4 proj;
    if (auto pCam = dynamic_cast<PerspectiveCamera*>(camera)) {
        proj = glm::perspective(pCam->fovy, pCam->aspect, nearPlane, farPlane);
    } 
    else if (auto oCam = dynamic_cast<OrthographicCamera*>(camera)) {
        proj = glm::ortho(oCam->left, oCam->right, oCam->bottom, oCam->top, nearPlane, farPlane);
    }
    else {
        return glm::mat4(1.0f);
    }
    
    // 2. 获取该切片的世界空间 8 个角点
    auto corners = getFrustumCornersWorldSpace(proj, camera->getViewMatrix());

    // 3. 计算几何中心
    glm::vec3 center = glm::vec3(0, 0, 0);
    for (const auto& v : corners) {
        center += glm::vec3(v);
    }
    center /= corners.size();

    // 4. 构建光照视图矩阵
    // 注意：这里的位置其实不重要，重要的是方向。我们将位置定在中心逆光方向远处
    const auto lightView = glm::lookAt(center - lightDir, center, glm::vec3(0.0f, 1.0f, 0.0f));

    // 5. 计算 AABB
    float minX = std::numeric_limits<float>::max();
    float maxX = std::numeric_limits<float>::lowest();
    float minY = std::numeric_limits<float>::max();
    float maxY = std::numeric_limits<float>::lowest();
    float minZ = std::numeric_limits<float>::max();
    float maxZ = std::numeric_limits<float>::lowest();

    for (const auto& v : corners)
    {
        const auto trf = lightView * v;
        minX = std::min(minX, trf.x);
        maxX = std::max(maxX, trf.x);
        minY = std::min(minY, trf.y);
        maxY = std::max(maxY, trf.y);
        minZ = std::min(minZ, trf.z);
        maxZ = std::max(maxZ, trf.z);
    }

    // [修复] 扩展 Z 轴范围
    // 在 View Space 中，物体通常在 -Z 方向。
    // maxZ 是"最近"的点（数值最大，例如 -10），minZ 是"最远"的点（数值最小，例如 -100）。
    // glm::ortho 的 near/far 通常是正数距离。
    // 所以 distance_near = -maxZ, distance_far = -minZ。

    // 为了捕捉位于切片前方（light 和切片之间）的遮挡物（如树干投射阴影到地面），
    // 我们需要把 Near Plane 大幅向光源方向拉伸。
    // 我们也把 Far Plane 稍微推远一点以防万一。
    float zMult = 10.0f;
if (nearPlane > 50.0f) {
    // 如果是远处的层级 (黄色/蓝色)，不要扩展那么多，甚至不扩展
    zMult = 1.0f; 
}
    if (minZ < 0) minZ *= zMult; else minZ /= zMult;
    if (maxZ < 0) maxZ /= zMult; else maxZ *= zMult;
    
    // [修正逻辑]
    // 上面原来的代码逻辑有问题。让我们用更稳健的方式：
    // 我们把 Near/Far 设置得非常大，覆盖整个场景可能范围。
    // 因为是正交投影，Z 范围大不会导致精度严重下降（不像透视投影）。
    
    // 简单的方案：以 Slice 边界为基础，向前后各扩展 200 米
    float zNear = -maxZ; 
    float zFar  = -minZ;

    // 6. 纹素对齐 (Texel Snapping) - 解决闪烁
    float unitPerPixel = (maxX - minX) / _resolution;
    float offsetX = fmod(minX, unitPerPixel);
    float offsetY = fmod(minY, unitPerPixel);
    minX -= offsetX;
    maxX -= offsetX;
    minY -= offsetY;
    maxY -= offsetY;

    float padding = 5.0f; 
    minX -= padding; maxX += padding;
    minY -= padding; maxY += padding;
    
    // 7. 构建正交投影
    // 注意：glm::ortho(l, r, b, t, zNear, zFar)
    const auto lightProjection = glm::ortho(minX, maxX, minY, maxY, zNear, zFar);

    return lightProjection * lightView;
}
```

./engine/shadow_map_pass.h:
```
#pragma once

#include <glad/gl.h>
#include <memory>
#include <vector>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "base/glsl_program.h"
#include "scene.h"
#include "base/camera.h"

class ShadowMapPass
{
public:
    // 分辨率越高，锯齿越少。4096 是现代 PC 的标准配置。
    ShadowMapPass(int resolution = 4096); 
    ~ShadowMapPass();

    // 核心渲染函数：从灯光视角渲染场景
    void render(const Scene& scene, const glm::vec3& lightDir, Camera* camera, float shadowNormalBias, unsigned int cullFaceMode);

    // 获取数据供主 Shader 使用
    GLuint getDepthMapArray() const { return _depthMap; } // 现在这是一个 Texture Array
    const std::vector<glm::mat4>& getLightSpaceMatrices() const { return _lightSpaceMatrices; }
    const std::vector<float>& getCascadeLevels() const { return _cascadeLevels; }
    int getCascadeCount() const { return _lightSpaceMatrices.size(); }

private:
    int _resolution;
    GLuint _fbo = 0;
    GLuint _depthMap = 0;
    
    // CSM 数据
    std::vector<glm::mat4> _lightSpaceMatrices;
    std::vector<float> _cascadeLevels; // 存储每一层的分割距离 (远平面)
    
    std::unique_ptr<GLSLProgram> _depthShader;

    void initFBO();
    void initShader();

    // 内部数学辅助：获取视锥体切片的 8 个角点
    std::vector<glm::vec4> getFrustumCornersWorldSpace(const glm::mat4& proj, const glm::mat4& view);
    
    // 内部数学辅助：计算单个级联的光照矩阵
    glm::mat4 getLightSpaceMatrix(const float nearPlane, const float farPlane, const glm::vec3& lightDir, Camera* camera);
};
```

./engine/utils/image_utils.cpp:
```
#include "image_utils.h"
#include <vector>
#include <iostream>
#include <algorithm> // for std::reverse (optional) or manual loop

// 这是一个单头文件库，必须在一个 CPP 文件中定义 IMPLEMENTATION 宏
#include <stb_image_write.h>
#include <glad/gl.h> // 需要包含 OpenGL 头文件以使用 glReadPixels

void ImageUtils::saveScreenshot(const std::string& filename, int width, int height)
{
    if (width <= 0 || height <= 0) return;

    // 1. 分配内存 (RGBA)
    std::vector<unsigned char> pixels(width * height * 4);

    // 2. 读取像素
    // 确保字节对齐
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    // 3. 上下翻转 (OpenGL 左下角 vs 图片 左上角)
    // 这一步是必须的，否则保存出来的图片是倒着的
    int rowSize = width * 4;
    std::vector<unsigned char> flippedPixels(width * height * 4);

    for (int y = 0; y < height; ++y)
    {
        unsigned char* srcRow = pixels.data() + y * rowSize;
        unsigned char* dstRow = flippedPixels.data() + (height - 1 - y) * rowSize;
        memcpy(dstRow, srcRow, rowSize);
    }

    // 4. 判断格式并保存
    bool success = false;
    std::string ext = filename.substr(filename.find_last_of(".") + 1);
    
    if (ext == "png") {
        success = stbi_write_png(filename.c_str(), width, height, 4, flippedPixels.data(), rowSize);
    } else if (ext == "jpg" || ext == "jpeg") {
        success = stbi_write_jpg(filename.c_str(), width, height, 4, flippedPixels.data(), 90); // 90 quality
    } else {
        // 默认存 PNG
        success = stbi_write_png((filename + ".png").c_str(), width, height, 4, flippedPixels.data(), rowSize);
    }

    if (success) {
        std::cout << "[ImageUtils] Screenshot saved to " << filename << std::endl;
    } else {
        std::cerr << "[ImageUtils] Failed to save screenshot: " << filename << std::endl;
    }
}
```

./engine/utils/image_utils.h:
```
#pragma once

#include <string>

class ImageUtils
{
public:
    // 截取当前 OpenGL 绑定的 Framebuffer 到文件
    // width, height: 图像大小
    // filename: 保存路径 (支持 .png, .jpg)
    static void saveScreenshot(const std::string& filename, int width, int height);
};
```

